<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ 面试题 | 贺腾的博客</title><meta name="author" content="贺腾"><meta name="copyright" content="贺腾"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="最近秋招，找的一些面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 面试题">
<meta property="og:url" content="https://brinjaul521.github.io/2025/09/17/C-%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="贺腾的博客">
<meta property="og:description" content="最近秋招，找的一些面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://brinjaul521.github.io/img/head.jpg">
<meta property="article:published_time" content="2025-09-17T02:35:14.000Z">
<meta property="article:modified_time" content="2025-09-18T06:31:18.246Z">
<meta property="article:author" content="贺腾">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://brinjaul521.github.io/img/head.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++ 面试题",
  "url": "https://brinjaul521.github.io/2025/09/17/C-%E9%9D%A2%E8%AF%95%E9%A2%98/",
  "image": "https://brinjaul521.github.io/img/head.jpg",
  "datePublished": "2025-09-17T02:35:14.000Z",
  "dateModified": "2025-09-18T06:31:18.246Z",
  "author": [
    {
      "@type": "Person",
      "name": "贺腾",
      "url": "https://brinjaul521.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://brinjaul521.github.io/2025/09/17/C-%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 面试题',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: rgba(255,255,255,0.15);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/background.png);"><nav id="nav"><span id="blog-info"><a href="/" title="贺腾的博客"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">贺腾的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">C++ 面试题</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++ 面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-17T02:35:14.000Z" title="发表于 2025-09-17 10:35:14">2025-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-18T06:31:18.246Z" title="更新于 2025-09-18 14:31:18">2025-09-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="睿联面试"><a href="#睿联面试" class="headerlink" title="睿联面试"></a>睿联面试</h2><h3 id="linux-swap分区什么作用"><a href="#linux-swap分区什么作用" class="headerlink" title="linux swap分区什么作用"></a>linux swap分区什么作用</h3><p>​	在Linux中，swap分区（或swap文件）的作用是当<strong>系统的物理内存（RAM）不足</strong>时，将内存中不常用的数据暂时存储到硬盘上的swap空间中，从而释放物理内存供其他更紧急的任务使用。这个过程称为“交换出”（swapping out）。当需要再次访问这些数据时，再将其从swap分区读回内存，即“交换入”（swapping in）。swap空间可以被视为物理内存的扩展，但需要注意的是，硬盘的读写速度远低于内存，因此过度依赖swap会导致系统性能下降。	</p>
<ol>
<li><strong>扩展虚拟内存</strong>：当物理内存（RAM）不足时，系统可以将不常用的内存页面移动到Swap空间中，从而释放RAM供更紧急的任务使用</li>
<li><strong>内存管理</strong>：即使系统有足够的物理内存，内核有时也会将长时间未活动的内存页面移动到Swap中</li>
<li><strong>休眠支持</strong>：当系统进入休眠状态时，会将RAM中的内容保存到Swap空间中，以便恢复时使用</li>
<li><strong>避免内存不足</strong>：防止系统因内存耗尽而意外终止关键进程</li>
</ol>
<h3 id="Linux文件有几种权限，分别是什么"><a href="#Linux文件有几种权限，分别是什么" class="headerlink" title="Linux文件有几种权限，分别是什么"></a>Linux文件有几种权限，分别是什么</h3><h4 id="Linux文件的基本权限类型"><a href="#Linux文件的基本权限类型" class="headerlink" title="Linux文件的基本权限类型"></a>Linux文件的基本权限类型</h4><p>Linux系统中，每个文件和目录都有三种基本的权限类型，每种权限类型对应三种不同的用户类别，总共形成9种权限设置。</p>
<h4 id="三种基本权限类型"><a href="#三种基本权限类型" class="headerlink" title="三种基本权限类型"></a>三种基本权限类型</h4><ol>
<li><p><strong>读取权限 (Read - r)</strong></p>
<ul>
<li>对文件：允许查看文件内容</li>
<li>对目录：允许列出目录中的内容</li>
</ul>
</li>
<li><p><strong>写入权限 (Write - w)</strong></p>
<ul>
<li>对文件：允许修改或删除文件内容</li>
<li>对目录：允许在目录中创建、删除或重命名文件</li>
</ul>
</li>
<li><p><strong>执行权限 (Execute - x)</strong></p>
<ul>
<li>对文件：允许将文件作为程序或脚本执行</li>
<li>对目录：允许进入和访问目录中的内容</li>
</ul>
</li>
</ol>
<h4 id="三种用户类别"><a href="#三种用户类别" class="headerlink" title="三种用户类别"></a>三种用户类别</h4><ol>
<li><h4 id="所有者-Owner-user-u-：文件或目录的创建者-拥有者"><a href="#所有者-Owner-user-u-：文件或目录的创建者-拥有者" class="headerlink" title="所有者 (Owner&#x2F;user - u)：文件或目录的创建者&#x2F;拥有者"></a><strong>所有者 (Owner&#x2F;user - u)</strong>：文件或目录的创建者&#x2F;拥有者</h4></li>
<li><p><strong>所属组 (Group - g)</strong>：与文件关联的用户组</p>
</li>
<li><p><strong>其他用户 (Others - o)</strong>：系统上的所有其他用户</p>
</li>
</ol>
<h4 id="权限表示方式"><a href="#权限表示方式" class="headerlink" title="权限表示方式"></a>权限表示方式</h4><h4 id="符号表示法"><a href="#符号表示法" class="headerlink" title="符号表示法"></a>符号表示法</h4><p>使用字符表示权限，例如：<code>rwxr-xr--</code></p>
<ul>
<li>前三个字符：所有者权限</li>
<li>中间三个字符：所属组权限</li>
<li>最后三个字符：其他用户权限</li>
</ul>
<h4 id="数字表示法（八进制表示）"><a href="#数字表示法（八进制表示）" class="headerlink" title="数字表示法（八进制表示）"></a>数字表示法（八进制表示）</h4><p>使用数字表示权限，例如：<code>755</code></p>
<ul>
<li>每个数字代表一组权限（所有者、组、其他用户）</li>
<li>每个数字是r(4)、w(2)、x(1)的和</li>
<li>例如：7 &#x3D; 4+2+1 (rwx)，5 &#x3D; 4+0+1 (r-x)</li>
</ul>
<h4 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h4><p>除了基本权限外，Linux还有三种特殊权限：</p>
<ol>
<li><p><strong>Set User ID (SUID - s)</strong></p>
<ul>
<li>当设置在可执行文件上时，程序会以文件所有者的权限运行</li>
<li>数字表示为4000</li>
</ul>
</li>
<li><p><strong>Set Group ID (SGID - s)</strong></p>
<ul>
<li>当设置在可执行文件上时，程序会以文件所属组的权限运行</li>
<li>当设置在目录上时，在该目录中创建的新文件会继承目录的组所有权</li>
<li>数字表示为2000</li>
</ul>
</li>
<li><p><strong>Sticky Bit (t)</strong></p>
<ul>
<li>当设置在目录上时，只有文件所有者、目录所有者或root用户才能删除目录中的文件</li>
<li>常用于&#x2F;tmp等共享目录</li>
<li>数字表示为1000</li>
</ul>
</li>
</ol>
<h4 id="查看文件权限"><a href="#查看文件权限" class="headerlink" title="查看文件权限"></a>查看文件权限</h4><p>使用<code>ls -l</code>命令可以查看文件的详细权限信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-- 1 user group 4096 Jan 1 12:00 filename</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个字符表示文件类型（-表示普通文件，d表示目录）</li>
<li>接下来的9个字符表示权限（rwxr-xr–）</li>
<li>后面跟着的数字表示链接数</li>
<li>然后显示所有者和所属组</li>
<li>最后是文件大小、修改时间和文件名</li>
</ul>
<h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><ol>
<li><p><strong>使用chmod命令</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 符号模式</span></span><br><span class="line"><span class="built_in">chmod</span> u+x filename      <span class="comment"># 给所有者添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> g-w filename      <span class="comment"># 移除所属组的写入权限</span></span><br><span class="line"><span class="built_in">chmod</span> o=r filename      <span class="comment"># 设置其他用户只有读取权限</span></span><br><span class="line"><span class="built_in">chmod</span> a+x filename      <span class="comment"># 给所有用户添加执行权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字模式</span></span><br><span class="line"><span class="built_in">chmod</span> 755 filename      <span class="comment"># rwxr-xr-x</span></span><br><span class="line"><span class="built_in">chmod</span> 644 filename      <span class="comment"># rw-r--r--</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用chown命令更改所有者和组</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> user filename     <span class="comment"># 更改文件所有者</span></span><br><span class="line"><span class="built_in">chown</span> user:group filename  <span class="comment"># 同时更改所有者和组</span></span><br><span class="line"><span class="built_in">chown</span> :group filename   <span class="comment"># 只更改组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用chgrp命令更改组</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> group filename    <span class="comment"># 更改文件所属组</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="权限示例"><a href="#权限示例" class="headerlink" title="权限示例"></a>权限示例</h4><ul>
<li><code>-rw-------</code> (600)：只有所有者可以读写</li>
<li><code>-rw-r--r--</code> (644)：所有者可以读写，其他用户只能读</li>
<li><code>-rwxr-xr-x</code> (755)：所有者可以读、写、执行，其他用户可以读和执行</li>
<li><code>-rwx--x--x</code> (711)：所有者可以读、写、执行，其他用户只能执行</li>
<li><code>drwx------</code> (700)：只有所有者可以读、写和进入目录</li>
<li><code>drwxr-xr-x</code> (755)：所有者可以完全访问，其他用户可以列出目录内容和进入目录</li>
</ul>
<p>理解Linux文件权限对于系统安全和正确管理文件访问至关重要。正确的权限设置可以保护系统免受未授权访问，同时确保合法用户能够完成所需的工作。</p>
<h3 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h3><p>在 <strong>C++ 语言层面</strong> 只有“抽象类”的概念，<strong>没有专门的 interface 关键字</strong>，因此 “接口” 只是<strong>一种设计约定</strong>。<br>可以把区别总结为一句话：</p>
<blockquote>
<p>C++ 的“接口”就是 <strong>所有成员函数都是纯虚函数（或默认实现）且没有数据成员</strong> 的一种 <strong>特殊抽象类</strong>。</p>
</blockquote>
<hr>
<ol>
<li>抽象类（general abstract class）</li>
</ol>
<ul>
<li>至少含一个纯虚函数 <code>= 0</code>。  </li>
<li>可以<strong>同时拥有</strong><br>‑ 数据成员<br>‑ 非虚成员函数 &#x2F; 虚函数 &#x2F; 纯虚函数<br>‑ 构造函数、析构函数、静态成员  </li>
<li>主要目的是 <strong>提供公共实现 + 强制接口</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractSocket</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">open</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isOpen</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _open; &#125;  <span class="comment">// 普通成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">bool</span> _open = <span class="literal">false</span>;                    <span class="comment">// 数据成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>“接口”（idiom-level interface）</li>
</ol>
<ul>
<li><strong>约定</strong> 所有函数 <strong>纯虚</strong>（C++11 后可给默认实现），<strong>无数据成员</strong>。  </li>
<li>纯接口类通常析构函数也写成纯虚或虚析构，防止泄漏。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IStream</span> &#123;                    <span class="comment">// 习惯用 I 前缀</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IStream</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">read</span><span class="params">(<span class="type">void</span>* buf, <span class="type">size_t</span> len)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> len)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>与 Java&#x2F;C# 的对比</li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>C++ 抽象类</th>
<th>Java&#x2F;C# interface</th>
</tr>
</thead>
<tbody><tr>
<td>关键字</td>
<td>无</td>
<td><code>interface</code></td>
</tr>
<tr>
<td>数据成员</td>
<td>可以有</td>
<td>不能有（Java ≤7）</td>
</tr>
<tr>
<td>默认实现</td>
<td>可以有</td>
<td>Java8+ 支持 default 方法</td>
</tr>
<tr>
<td>多继承</td>
<td>支持多继承（含接口）</td>
<td>只能多接口单继承</td>
</tr>
</tbody></table>
<ol start="4">
<li>何时用哪种</li>
</ol>
<ul>
<li><strong>需要公共代码 + 接口</strong> → 普通抽象类。  </li>
<li><strong>只想要协议&#x2F;约定</strong> → 纯虚类（接口）。  </li>
<li><strong>菱形继承</strong> → 接口 + 虚继承，避免重复数据。</li>
</ul>
<p>结论<br>在 C++ 里，“接口”就是<strong>纯虚类</strong>的另一种说法；抽象类是更宽泛的概念，两者语法上统一，区别只在于 <strong>设计意图和成员组成</strong>。</p>
<h3 id="MYSQL索引失效的几种情况"><a href="#MYSQL索引失效的几种情况" class="headerlink" title="MYSQL索引失效的几种情况"></a>MYSQL索引失效的几种情况</h3><p>MySQL索引是提高查询性能的关键工具，但在某些情况下索引可能不会按预期工作，导致查询性能下降。以下是MySQL索引失效的常见情况：</p>
<h4 id="1-对索引列使用函数或表达式"><a href="#1-对索引列使用函数或表达式" class="headerlink" title="1. 对索引列使用函数或表达式"></a>1. 对索引列使用函数或表达式</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(create_time) <span class="operator">=</span> <span class="number">2023</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">*</span> <span class="number">1.1</span> <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后（避免在索引列上使用函数）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> create_time <span class="operator">&gt;=</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> create_time <span class="operator">&lt;</span> <span class="string">&#x27;2024-01-01&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">100</span> <span class="operator">/</span> <span class="number">1.1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用LIKE模糊查询以通配符开头"><a href="#2-使用LIKE模糊查询以通配符开头" class="headerlink" title="2. 使用LIKE模糊查询以通配符开头"></a>2. 使用LIKE模糊查询以通配符开头</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引失效（前导%）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%john%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%john&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 索引有效（非前导%）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;john%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解决方案：考虑全文索引或其他搜索技术</span></span><br></pre></td></tr></table></figure>

<h4 id="3-隐式类型转换"><a href="#3-隐式类型转换" class="headerlink" title="3. 隐式类型转换"></a>3. 隐式类型转换</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设user_id是字符串类型，但使用了数字</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">123</span>; <span class="comment">-- 索引失效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确写法</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>; <span class="comment">-- 索引有效</span></span><br></pre></td></tr></table></figure>

<h4 id="4-使用OR条件且部分列无索引"><a href="#4-使用OR条件且部分列无索引" class="headerlink" title="4. 使用OR条件且部分列无索引"></a>4. 使用OR条件且部分列无索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果age列没有索引，即使name有索引也会失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">OR</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化方案1：使用UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化方案2：为age列添加索引</span></span><br></pre></td></tr></table></figure>

<h4 id="5-不符合最左前缀原则（复合索引）"><a href="#5-不符合最左前缀原则（复合索引）" class="headerlink" title="5. 不符合最左前缀原则（复合索引）"></a>5. 不符合最左前缀原则（复合索引）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设有复合索引 (col1, col2, col3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 索引有效（使用最左前缀）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> col2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 索引失效（跳过最左列）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">AND</span> col3 <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col3 <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 索引部分有效（使用部分前缀）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> col3 <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>; <span class="comment">-- 只用到col1索引</span></span><br></pre></td></tr></table></figure>

<h4 id="6-使用不等于-或-操作"><a href="#6-使用不等于-或-操作" class="headerlink" title="6. 使用不等于(!&#x3D;或&lt;&gt;)操作"></a>6. 使用不等于(!&#x3D;或&lt;&gt;)操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引通常失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> status <span class="operator">!=</span> <span class="string">&#x27;active&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化方案：考虑重写查询或使用其他条件</span></span><br></pre></td></tr></table></figure>

<h4 id="7-对索引列使用IS-NULL或IS-NOT-NULL"><a href="#7-对索引列使用IS-NULL或IS-NOT-NULL" class="headerlink" title="7. 对索引列使用IS NULL或IS NOT NULL"></a>7. 对索引列使用IS NULL或IS NOT NULL</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可能使索引失效，取决于数据分布和MySQL版本</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果NULL值很少，可以考虑使用默认值代替NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="8-数据分布不均匀"><a href="#8-数据分布不均匀" class="headerlink" title="8. 数据分布不均匀"></a>8. 数据分布不均匀</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当某个值占比过高时，MySQL可能认为全表扫描更快</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;completed&#x27;</span>; <span class="comment">-- 假设90%订单都是completed状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解决方案：考虑使用FORCE INDEX或优化查询</span></span><br></pre></td></tr></table></figure>

<h4 id="9-使用ORDER-BY与索引不匹配"><a href="#9-使用ORDER-BY与索引不匹配" class="headerlink" title="9. 使用ORDER BY与索引不匹配"></a>9. 使用ORDER BY与索引不匹配</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设有索引 (category, price)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 索引有效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;electronics&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> price;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 索引失效（排序方向不一致）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;electronics&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>, name <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 索引失效（排序字段不在WHERE条件中）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> price;</span><br></pre></td></tr></table></figure>

<h4 id="10-表数据量很小"><a href="#10-表数据量很小" class="headerlink" title="10. 表数据量很小"></a>10. 表数据量很小</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当表很小（如少于1000行）时，MySQL可能选择全表扫描而不是使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> small_table <span class="keyword">WHERE</span> indexed_column <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="11-索引统计信息过时"><a href="#11-索引统计信息过时" class="headerlink" title="11. 索引统计信息过时"></a>11. 索引统计信息过时</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当表数据发生重大变化后，索引统计信息可能不准确</span></span><br><span class="line"><span class="comment">-- 解决方案：定期分析表</span></span><br><span class="line">ANALYZE <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="12-使用负向查询条件"><a href="#12-使用负向查询条件" class="headerlink" title="12. 使用负向查询条件"></a>12. 使用负向查询条件</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引通常失效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">AND</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化方案：重写查询逻辑</span></span><br></pre></td></tr></table></figure>

<h4 id="诊断索引使用情况"><a href="#诊断索引使用情况" class="headerlink" title="诊断索引使用情况"></a>诊断索引使用情况</h4><p>可以使用EXPLAIN命令检查查询是否使用了索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查看结果中的<code>key</code>列可以知道使用了哪个索引，<code>Extra</code>列可以提供额外信息。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ol>
<li>定期分析查询性能并使用EXPLAIN诊断</li>
<li>确保索引统计信息最新</li>
<li>考虑查询模式设计复合索引</li>
<li>避免过度索引，因为索引会占用空间并降低写操作性能</li>
<li>使用覆盖索引（索引包含所有查询字段）提高性能</li>
</ol>
<p>通过理解这些索引失效的情况，可以更好地设计和优化数据库索引，提高查询性能。</p>
<h3 id="C-网络编程如何处理粘包，超时重传，断点续传"><a href="#C-网络编程如何处理粘包，超时重传，断点续传" class="headerlink" title="C++网络编程如何处理粘包，超时重传，断点续传"></a>C++网络编程如何处理粘包，超时重传，断点续传</h3><p>好的，这是一个非常深入的C++网络编程问题，涉及到实现可靠网络通信的核心机制。我将为你详细解释这三个问题的处理方案。</p>
<hr>
<h4 id="1-粘包-拆包问题-Sticky-Packet-Unpacking"><a href="#1-粘包-拆包问题-Sticky-Packet-Unpacking" class="headerlink" title="1. 粘包&#x2F;拆包问题 (Sticky Packet &#x2F; Unpacking)"></a>1. 粘包&#x2F;拆包问题 (Sticky Packet &#x2F; Unpacking)</h4><p><strong>问题根源</strong>：TCP是面向字节流的协议，它只保证数据的有序和可靠传输，不维护消息边界。发送端多次发送的数据可能会被接收端一次接收（粘包），或者一次发送的数据被多次接收（拆包）。</p>
<h4 id="解决方案：设计应用层协议"><a href="#解决方案：设计应用层协议" class="headerlink" title="解决方案：设计应用层协议"></a>解决方案：设计应用层协议</h4><p>需要在应用层设计协议来界定消息的边界。以下是四种常见方案：</p>
<p><strong>方案一：定长消息</strong></p>
<ul>
<li>每个消息都是固定长度（例如128字节）。</li>
<li>不足部分用特定字符（如<code>\0</code>）填充。</li>
<li><strong>优点</strong>：处理简单。</li>
<li><strong>缺点</strong>：浪费带宽，不灵活。</li>
</ul>
<p><strong>方案二：分隔符</strong></p>
<ul>
<li>使用特殊字符或字符串作为消息结束标志（如<code>\r\n\r\n</code>）。</li>
<li><strong>优点</strong>：简单，类似HTTP等文本协议。</li>
<li><strong>缺点</strong>：消息内容本身不能包含分隔符，需要转义，增加复杂度。</li>
</ul>
<p><strong>方案三：长度前缀（最常用、最推荐）</strong></p>
<ul>
<li>在消息体前附加一个固定长度的包头，包头中包含消息体的长度。</li>
<li>接收方先读固定长度的包头，解析出长度N，再读取后续N字节的数据。</li>
</ul>
<p><strong>C++ 代码示例（长度前缀法）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendPacket</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 构造包头：通常使用固定长度的整型（如uint32_t）来存储长度</span></span><br><span class="line">    <span class="type">uint32_t</span> dataLength = <span class="built_in">htonl</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(data.<span class="built_in">size</span>())); <span class="comment">// 主机序转网络序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 先发送包头（4字节）</span></span><br><span class="line">    <span class="type">ssize_t</span> sent = <span class="built_in">send</span>(sockfd, &amp;dataLength, <span class="built_in">sizeof</span>(dataLength), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sent != <span class="built_in">sizeof</span>(dataLength)) &#123;</span><br><span class="line">        <span class="comment">// 错误处理...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 再发送实际数据</span></span><br><span class="line">    sent = <span class="built_in">send</span>(sockfd, data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sent != data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// 错误处理...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="function">std::string <span class="title">receivePacket</span><span class="params">(<span class="type">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 先读取固定长度的包头，获取消息长度</span></span><br><span class="line">    <span class="type">uint32_t</span> dataLengthNetwork;</span><br><span class="line">    <span class="type">ssize_t</span> received = <span class="built_in">recv</span>(sockfd, &amp;dataLengthNetwork, <span class="built_in">sizeof</span>(dataLengthNetwork), MSG_WAITALL);</span><br><span class="line">    <span class="keyword">if</span> (received != <span class="built_in">sizeof</span>(dataLengthNetwork)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (received == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">ConnectionClosedException</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">ReadHeaderException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint32_t</span> dataLength = <span class="built_in">ntohl</span>(dataLengthNetwork); <span class="comment">// 网络序转主机序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 根据长度读取消息体</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(dataLength)</span></span>;</span><br><span class="line">    received = <span class="built_in">recv</span>(sockfd, buffer.<span class="built_in">data</span>(), dataLength, MSG_WAITALL);</span><br><span class="line">    <span class="keyword">if</span> (received != dataLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (received == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">ConnectionClosedException</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">ReadBodyException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>(buffer.<span class="built_in">data</span>(), dataLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意：<code>MSG_WAITALL</code> 标志会尝试阻塞直到读取到请求的字节数，但并非所有系统都保证完全做到。生产环境需要循环读取。</em></p>
<hr>
<h4 id="2-超时重传-Timeout-Retransmission"><a href="#2-超时重传-Timeout-Retransmission" class="headerlink" title="2. 超时重传 (Timeout Retransmission)"></a>2. 超时重传 (Timeout Retransmission)</h4><p><strong>问题根源</strong>：网络是不稳定的，数据包可能会丢失、损坏或严重延迟。发送方需要一种机制来确认对方已收到数据，否则应重新发送。</p>
<h4 id="解决方案：确认应答（ACK）-超时计时器"><a href="#解决方案：确认应答（ACK）-超时计时器" class="headerlink" title="解决方案：确认应答（ACK） + 超时计时器"></a>解决方案：确认应答（ACK） + 超时计时器</h4><p>这本质上是实现一个类似TCP的简易可靠传输机制。</p>
<ol>
<li><strong>序列号 (Sequence Number)</strong>：为每个发送的数据包分配一个唯一的、递增的序列号（Seq）。</li>
<li><strong>确认应答 (Acknowledgment, ACK)</strong>：接收方收到数据包后，必须向发送方发送一个ACK包，ACK包中包含它期望收到的下一个序列号（即上一个Seq+1）。</li>
<li><strong>重传计时器 (Retransmission Timer)</strong>：发送方每发送一个数据包，就启动一个计时器。如果在计时器超时前未收到对应的ACK，则重新发送该数据包。</li>
</ol>
<p><strong>C++ 伪代码逻辑：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送方逻辑</span></span><br><span class="line">std::unordered_map&lt;<span class="type">uint32_t</span>, Packet&gt; unAckedPackets; <span class="comment">// 未确认的包队列</span></span><br><span class="line">std::mutex unAckedMutex;</span><br><span class="line">std::condition_variable ackCV;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendingThread</span><span class="params">(<span class="type">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> nextSeqNum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (hasDataToSend) &#123;</span><br><span class="line">        Packet pkt = <span class="built_in">getNextDataToSend</span>();</span><br><span class="line">        pkt.seq = nextSeqNum++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送前存入未确认队列，并启动定时器</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(unAckedMutex)</span></span>;</span><br><span class="line">            unAckedPackets[pkt.seq] = pkt;</span><br><span class="line">            <span class="built_in">startTimer</span>(pkt.seq, RETRANSMISSION_TIMEOUT_MS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sendToNetwork</span>(sockfd, pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onAckReceived</span><span class="params">(<span class="type">uint32_t</span> ackSeqNum)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(unAckedMutex)</span></span>;</span><br><span class="line">    <span class="comment">// 收到ACK，从重传队列中移除对应的包并停止其定时器</span></span><br><span class="line">    <span class="keyword">if</span> (unAckedPackets.<span class="built_in">erase</span>(ackSeqNum) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">stopTimer</span>(ackSeqNum);</span><br><span class="line">        ackCV.<span class="built_in">notify_all</span>(); <span class="comment">// 通知可能阻塞的发送线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onTimerExpired</span><span class="params">(<span class="type">uint32_t</span> seqNum)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(unAckedMutex)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> it = unAckedPackets.<span class="built_in">find</span>(seqNum);</span><br><span class="line">    <span class="keyword">if</span> (it != unAckedPackets.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">// 超时未收到ACK，重新发送</span></span><br><span class="line">        <span class="built_in">sendToNetwork</span>(sockfd, it-&gt;second);</span><br><span class="line">        <span class="comment">// 重启这个包的定时器</span></span><br><span class="line">        <span class="built_in">restartTimer</span>(seqNum, RETRANSMISSION_TIMEOUT_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>超时时间 (RTO)</strong>：动态计算（如Jacobson&#x2F;Karels算法）比固定值更优，可根据网络RTT（往返时间）调整。</li>
<li><strong>重复ACK</strong>：快速重传机制（收到3个重复ACK立即重传）可以更快地修复丢包，而不必等待超时。</li>
<li><strong>窗口机制</strong>：上述是停等协议，效率低。通常使用滑动窗口协议进行流水线传输，允许多个包未被确认。</li>
</ul>
<hr>
<h4 id="3-断点续传-Resume-from-Breakpoint"><a href="#3-断点续传-Resume-from-Breakpoint" class="headerlink" title="3. 断点续传 (Resume from Breakpoint)"></a>3. 断点续传 (Resume from Breakpoint)</h4><p><strong>问题根源</strong>：在传输大文件（如视频、安装包）时，网络中断或程序崩溃。重新传输时，不希望从0开始，而是从上次中断的地方继续。</p>
<h4 id="解决方案：记录已传输进度-校验"><a href="#解决方案：记录已传输进度-校验" class="headerlink" title="解决方案：记录已传输进度 + 校验"></a>解决方案：记录已传输进度 + 校验</h4><p>这通常发生在应用层，尤其是文件传输协议中（如FTP、HTTP&#x2F;1.1的<code>Range</code>头）。</p>
<ol>
<li><strong>发送方</strong>：能够根据偏移量读取文件的一部分。</li>
<li><strong>接收方</strong>：<ul>
<li><strong>记录进度</strong>：在本地非易失性存储（如磁盘文件）中记录已成功接收的文件大小（偏移量）。</li>
<li><strong>请求续传</strong>：在重新建立连接后，首先询问发送方文件信息（如文件名、大小、MD5），然后告知对方自己已接收的偏移量。</li>
</ul>
</li>
<li><strong>发送方</strong>：从接收方指定的偏移量开始发送数据。</li>
</ol>
<p><strong>C++ 伪代码逻辑：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收端主逻辑</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">resumeDownload</span><span class="params">(<span class="type">const</span> std::string&amp; serverIp, <span class="type">int</span> port, <span class="type">const</span> std::string&amp; localFilePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查本地已存在部分文件的大小</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(localFilePath, std::ios::binary | std::ios::ate)</span></span>;</span><br><span class="line">    <span class="type">uint64_t</span> existingFileSize = file.<span class="built_in">tellg</span>();</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">connectToServer</span>(serverIp, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 发送下载请求，并告知服务器我已有的字节数（偏移量）</span></span><br><span class="line">    <span class="built_in">SendDownloadRequest</span>(sockfd, localFilePath, existingFileSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 接收服务器的响应。可能同意续传，也可能文件已变更需重新下载</span></span><br><span class="line">    ServerResponse resp = <span class="built_in">receiveResponse</span>(sockfd);</span><br><span class="line">    <span class="keyword">if</span> (resp.status == RESPONSE_FILE_CHANGED) &#123;</span><br><span class="line">        <span class="comment">// 文件变了，删除本地残破文件，从头开始</span></span><br><span class="line">        std::<span class="built_in">remove</span>(localFilePath.<span class="built_in">c_str</span>());</span><br><span class="line">        existingFileSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 以追加模式打开文件</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outFile</span><span class="params">(localFilePath, std::ios::binary | std::ios::app)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!outFile.<span class="built_in">is_open</span>()) &#123; <span class="comment">/* handle error */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 开始接收数据（从服务器响应的偏移量开始）</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Packet pkt = <span class="built_in">receivePacket</span>(sockfd); <span class="comment">// 使用前面解决粘包的方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEndOfFile</span>(pkt)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入文件末尾</span></span><br><span class="line">        outFile.<span class="built_in">write</span>(pkt.data.<span class="built_in">data</span>(), pkt.data.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">// 更新本地进度记录（可定期更新，避免每次写磁盘）</span></span><br><span class="line">        <span class="built_in">updateProgressMetadata</span>(localFilePath, outFile.<span class="built_in">tellp</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="comment">// 7. 最后可校验文件MD5是否与服务器一致</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">verifyFileChecksum</span>(localFilePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li><strong>进度存储</strong>：必须可靠地存储在磁盘上，防止程序崩溃后进度丢失。</li>
<li><strong>文件校验</strong>：使用哈希（如MD5、SHA1）在传输结束后验证文件完整性，防止传输错误或文件在服务端发生变化。</li>
<li><strong>原子性</strong>：文件写入和进度更新要尽可能保证原子性，避免产生中间状态。</li>
</ul>
<h4 id="总结与关联"><a href="#总结与关联" class="headerlink" title="总结与关联"></a>总结与关联</h4><table>
<thead>
<tr>
<th align="left">机制</th>
<th align="left">解决的核心问题</th>
<th align="left">关键技术点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>粘包处理</strong></td>
<td align="left">消息边界</td>
<td align="left"><strong>应用层协议设计</strong>（长度前缀法）</td>
</tr>
<tr>
<td align="left"><strong>超时重传</strong></td>
<td align="left">数据丢失</td>
<td align="left"><strong>序列号、ACK、重传计时器</strong>（简易ARQ协议）</td>
</tr>
<tr>
<td align="left"><strong>断点续传</strong></td>
<td align="left">传输中断</td>
<td align="left"><strong>记录偏移量、校验和</strong></td>
</tr>
</tbody></table>
<p>在实际项目中，这三个机制往往需要结合使用：</p>
<ol>
<li>你使用<strong>长度前缀法</strong>来封装你的消息（Packet），每个Packet可以携带文件数据、ACK信息、断点续传的控制命令等。</li>
<li>在传输文件数据Packet时，使用<strong>序列号和ACK机制</strong>来保证可靠性。</li>
<li>同时，接收方需要将已成功接收并确认（ACK）的数据<strong>安全地写入文件并记录进度</strong>，以实现断点续传。</li>
</ol>
<p>实现这些机制非常复杂，通常建议优先使用现有的、成熟的网络库（如Boost.Asio）或协议，它们已经高效、稳定地实现了这些功能。自己实现主要是为了理解和学习底层原理。</p>
<h3 id="TCP的流式传输如何理解"><a href="#TCP的流式传输如何理解" class="headerlink" title="TCP的流式传输如何理解"></a>TCP的流式传输如何理解</h3><p>好的，这是一个非常核心的网络概念。理解TCP的流式传输（Stream-Oriented Transmission）是理解TCP所有行为和特性的基石。</p>
<p>我会用一个非常形象的比喻来帮你彻底理解它。</p>
<hr>
<h4 id="核心比喻：水管送积木"><a href="#核心比喻：水管送积木" class="headerlink" title="核心比喻：水管送积木"></a>核心比喻：水管送积木</h4><p>想象一下，有两个小朋友，小明和小红，他们隔着墙用一根<strong>水管</strong>来传送<strong>积木</strong>。</p>
<ol>
<li><strong>水管 (TCP连接)</strong>：这根水管很神奇，它保证水的流动是<strong>有序的</strong>（先倒进去的水先出来）和<strong>可靠的</strong>（不会漏掉任何一滴水）。</li>
<li><strong>积木 (应用层消息)</strong>：小明想送给小红一些搭好的积木，比如一座小房子和一辆小汽车。</li>
<li><strong>水 (字节数据)</strong>：小明无法直接塞积木，他必须把积木<strong>拆成</strong>最基础的<strong>小木块（字节）</strong>，然后混在水里，通过水管送过去。</li>
</ol>
<p><strong>这就是TCP流式传输的核心：它传输的不是一块块完整的“积木”（消息），而是无结构的“小木块”字节流（byte stream）。</strong></p>
<hr>
<h4 id="流式传输的关键特征与影响"><a href="#流式传输的关键特征与影响" class="headerlink" title="流式传输的关键特征与影响"></a>流式传输的关键特征与影响</h4><p>基于这个比喻，我们可以推导出TCP的所有重要特性：</p>
<h4 id="1-无消息边界-No-Message-Boundaries"><a href="#1-无消息边界-No-Message-Boundaries" class="headerlink" title="1. 无消息边界 (No Message Boundaries)"></a>1. 无消息边界 (No Message Boundaries)</h4><ul>
<li><strong>小明这边</strong>：他分两次倒水：第一次倒“房子积木”的小木块，第二次倒“汽车积木”的小木块。</li>
<li><strong>小红这边</strong>：她拿桶接水，她<strong>无法直接知道</strong>小木块什么时候是“房子”的结束，什么时候是“汽车”的开始。她可能：<ul>
<li>一次接到所有“房子”和“汽车”的木块。（<strong>粘包</strong>）</li>
<li>先接到“房子”的一部分木块，过了一会儿又接到剩下的“房子”木块和全部“汽车”木块。（<strong>拆包</strong>）</li>
<li>以任意其他方式接收到这些木块。</li>
</ul>
</li>
</ul>
<p><strong>这就是“粘包&#x2F;拆包”问题的根本原因。TCP不维护应用层的消息边界，它只保证字节的顺序是正确的。</strong></p>
<p><strong>应对策略（应用层的责任）：</strong><br>小红和小明必须事先约定好如何区分积木。例如：</p>
<ul>
<li><strong>长度前缀法</strong>：小明先发送一个数字，告诉小红下一个积木由多少个小木块组成。这是<strong>最常用、最有效</strong>的方法。<br><code>[4字节长度][房子数据][4字节长度][汽车数据]</code></li>
<li><strong>分隔符法</strong>：在每个积木的木块后面放一个特殊的、积木本身不会有的小木块（如一个红色木块）作为结束标志。<br><code>[房子数据][红色木块][汽车数据][红色木块]</code></li>
<li><strong>固定长度法</strong>：所有积木都必须由同样数量的小木块组成。</li>
</ul>
<h4 id="2-有序和可靠-Ordered-Reliable"><a href="#2-有序和可靠-Ordered-Reliable" class="headerlink" title="2. 有序和可靠 (Ordered &amp; Reliable)"></a>2. 有序和可靠 (Ordered &amp; Reliable)</h4><ul>
<li><strong>有序</strong>：水管保证先倒进去的小木块一定先出来。即使网络路径很复杂，TCP协议栈也会对收到的数据包进行排序，确保提交给应用层的是正确的字节流顺序。</li>
<li><strong>可靠</strong>：如果一个小木块在水管里丢了（网络丢包），小明会发现小红没有确认收到，他就会<strong>重新发送</strong>那个丢失的木块（超时重传）。这保证了最终所有小木块都会到达小红那里。</li>
</ul>
<h4 id="3-面向连接-Connection-Oriented"><a href="#3-面向连接-Connection-Oriented" class="headerlink" title="3. 面向连接 (Connection-Oriented)"></a>3. 面向连接 (Connection-Oriented)</h4><p>在开始传送小木块之前，小明和小红必须先建立连接（打个电话：“喂，我们开始用水管了哦？”）。传送结束后，他们也要断开连接（“喂，我传完了，关水管了哦？”）。这就是著名的<strong>三次握手</strong>和<strong>四次挥手</strong>。</p>
<hr>
<h4 id="与UDP数据报传输的对比"><a href="#与UDP数据报传输的对比" class="headerlink" title="与UDP数据报传输的对比"></a>与UDP数据报传输的对比</h4><p>为了更好地理解“流”，我们和UDP的“数据报”（Datagram）模式做个对比。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><strong>TCP (流式)</strong></th>
<th align="left"><strong>UDP (数据报式)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>比喻</strong></td>
<td align="left"><strong>水管送积木（字节流）</strong></td>
<td align="left"><strong>邮局寄信（消息&#x2F;包）</strong></td>
</tr>
<tr>
<td align="left"><strong>数据视图</strong></td>
<td align="left">无边界的数据流</td>
<td align="left">有边界的独立数据包</td>
</tr>
<tr>
<td align="left"><strong>是否维护边界</strong></td>
<td align="left"><strong>否</strong>，可能合并或拆分</td>
<td align="left"><strong>是</strong>，接收到的永远是发送方发送的完整数据包</td>
</tr>
<tr>
<td align="left"><strong>可靠性</strong></td>
<td align="left">可靠，自动重传、校验</td>
<td align="left">不可靠，可能丢失、重复、乱序</td>
</tr>
<tr>
<td align="left"><strong>连接性</strong></td>
<td align="left">面向连接</td>
<td align="left">无连接</td>
</tr>
<tr>
<td align="left"><strong>顺序</strong></td>
<td align="left">保证数据顺序</td>
<td align="left">不保证顺序</td>
</tr>
<tr>
<td align="left"><strong>开销</strong></td>
<td align="left">较大（有头部、重传等机制）</td>
<td align="left">较小</td>
</tr>
</tbody></table>
<ul>
<li>如果你用UDP发送3条消息：“Hello”、“World”、“!”，接收方会<strong>精确地</strong>收到3次数据，每次分别得到”Hello”, “World”, “!”。</li>
<li>如果你用TCP发送同样的3条消息，接收方可能一次收到”HelloWorld!”，也可能分两次收到”Hell”和”oWorld!”，或者任何其他组合。<strong>应用层看到的是一个连续的字节流，需要自己去找消息的边界。</strong></li>
</ul>
<h4 id="编程模型上的体现"><a href="#编程模型上的体现" class="headerlink" title="编程模型上的体现"></a>编程模型上的体现</h4><p>在C&#x2F;C++中使用Socket编程时，这种感觉非常明显：</p>
<ul>
<li><p><strong>发送端</strong>：你可以调用多次 <code>send()</code> 来发送一份完整的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">send</span>(sockfd, <span class="string">&quot;Hello &quot;</span>, <span class="number">6</span>, <span class="number">0</span>); <span class="comment">// 发送第一部分</span></span><br><span class="line"><span class="built_in">send</span>(sockfd, <span class="string">&quot;World&quot;</span>, <span class="number">5</span>, <span class="number">0</span>);  <span class="comment">// 发送第二部分</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>接收端</strong>：你可能一次 <code>recv()</code> 就收到 “Hello World”，也可能第一次 <code>recv()</code> 收到 “Hello W”，第二次 <code>recv()</code> 才收到 “orld”。</p>
</li>
</ul>
<p><strong>接收方的 <code>recv()</code> 函数返回的是当前内核接收缓冲区中有多少字节可读，而不是发送方一次 <code>send()</code> 的字节数。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>TCP的流式传输</strong>可以理解为：</p>
<ol>
<li><strong>一个双向的、连续的、有序的字节流管道</strong>：数据像水一样在这个管道中流动。</li>
<li><strong>对应用层消息无感知</strong>：TCP只关心字节的正确性和顺序，不关心也不维护这些字节代表什么业务含义、哪几个字节是一条完整消息。</li>
<li><strong>优势</strong>：这种模型极大地简化了网络底层复杂性（如分片、重组、路由），为上层提供了一个极其简单、稳定、可靠的<strong>字节传输通道</strong>。</li>
<li><strong>代价</strong>：<strong>应用层开发者必须自己负责定义消息的格式和边界</strong>（即“协议”），这是所有基于TCP的应用编程（如HTTP、FTP、自定义游戏协议）的首要任务。</li>
</ol>
<p>理解了“流”，你就理解了TCP行为的本质，也就明白了为什么必须处理粘包，以及为什么TCP如此强大和流行。</p>
<h2 id="面试官会从基础概念、深入原理和实战应用三个层面"><a href="#面试官会从基础概念、深入原理和实战应用三个层面" class="headerlink" title="面试官会从基础概念、深入原理和实战应用三个层面"></a>面试官会从<strong>基础概念</strong>、<strong>深入原理</strong>和<strong>实战应用</strong>三个层面</h2><p>来考察你。以下是他们很可能会问的问题，我为你进行了分类和梳理：</p>
<hr>
<h3 id="一、进程与线程-Process-Thread"><a href="#一、进程与线程-Process-Thread" class="headerlink" title="一、进程与线程 (Process &amp; Thread)"></a>一、进程与线程 (Process &amp; Thread)</h3><p>这是面试的重点，问题会由浅入深。</p>
<h4 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h4><ul>
<li><strong>进程和线程的根本区别是什么？</strong><ul>
<li><strong>期望答案</strong>：进程是操作系统<strong>资源分配</strong>的基本单位（拥有独立的地址空间、文件句柄、系统资源），而线程是<strong>CPU调度和执行</strong>的基本单位（是进程内的一个执行流，共享进程的资源）。创建进程开销大，创建线程开销小。一个进程崩溃一般不会影响其他进程，但一个线程崩溃会导致整个进程崩溃。</li>
</ul>
</li>
<li><strong>在Windows中，创建进程和线程的API是什么？</strong><ul>
<li><strong>期望答案</strong>：创建进程主要是 <code>CreateProcess</code> 函数，它可以指定可执行文件路径、命令行参数、安全属性等。创建线程是 <code>CreateThread</code> 函数（或C运行时库的 <code>_beginthreadex</code>，后者在多线程CRT中更安全，会初始化线程局部存储）。</li>
</ul>
</li>
<li><strong>线程有哪些状态？</strong><ul>
<li><strong>期望答案</strong>：就绪（Ready）、运行（Running）、等待&#x2F;阻塞（Waiting&#x2F;Blocked）、终止（Terminated）。</li>
</ul>
</li>
</ul>
<h4 id="2-线程同步与通信（必问！）"><a href="#2-线程同步与通信（必问！）" class="headerlink" title="2. 线程同步与通信（必问！）"></a>2. 线程同步与通信（必问！）</h4><p>这是核心中的核心，一定会深入问。</p>
<ul>
<li><p><strong>为什么需要线程同步？</strong></p>
<ul>
<li><strong>期望答案</strong>：当多个线程访问<strong>共享资源</strong>（全局变量、内存数据、文件等）时，为了防止出现<strong>竞态条件（Race Condition）</strong> 和数据不一致，必须进行同步。</li>
</ul>
</li>
<li><p><strong>请说出你知道的Windows线程同步机制，并比较它们的区别和适用场景。</strong></p>
<ul>
<li><strong>期望答案</strong>：（这是一个综合题，考察知识体系）<ul>
<li><strong>临界区（CRITICAL_SECTION）</strong>：<strong>用户态</strong>同步对象，只能在<strong>同一进程</strong>的线程间使用。速度快，但不可跨进程。</li>
<li><strong>互斥量（Mutex）</strong>：<strong>内核态</strong>同步对象。可以跨进程使用（有名字），但速度比临界区慢。拥有“所有权”，哪个线程锁定（<code>WaitForSingleObject</code>）就必须由哪个线程释放（<code>ReleaseMutex</code>）。</li>
<li><strong>信号量（Semaphore）</strong>：<strong>内核态</strong>同步对象。维护一个计数器，用于控制同时访问共享资源的<strong>线程数量</strong>。可以跨进程。</li>
<li><strong>事件（Event）</strong>：<strong>内核态</strong>同步对象。用于通知一个或多个线程“某个事件已发生”。分为手动重置（Manual-Reset）和自动重置（Auto-Reset）两种，非常灵活，是实现生产者-消费者模型的利器。</li>
<li><strong>互锁函数（Interlocked Functions）</strong>：如 <code>InterlockedIncrement</code>, <code>InterlockedCompareExchange</code>。用于对单个变量进行原子操作，效率最高。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>WaitForSingleObject</code> 和 <code>WaitForMultipleObjects</code> 是做什么的？</strong></p>
<ul>
<li><strong>期望答案</strong>：它们是等待内核对象变为“有信号”状态的核心API。可以等待Mutex、Event、Semaphore、Process、Thread等多种对象。</li>
</ul>
</li>
<li><p><strong>什么是死锁（Deadlock）？产生死锁的必要条件是什么？如何避免和预防死锁？</strong></p>
<ul>
<li><strong>期望答案</strong>：两个或以上的线程互相等待对方持有的资源，导致都无法继续执行。</li>
<li><strong>必要条件</strong>：互斥、持有并等待、非抢占、循环等待。</li>
<li><strong>预防</strong>：按固定的顺序申请锁；使用 <code>WaitForMultipleObjects</code> 来同时申请所有需要的锁；设置超时时间（<code>WaitForSingleObject</code> 的超时参数）。</li>
</ul>
</li>
</ul>
<h4 id="3-进程间通信（IPC）"><a href="#3-进程间通信（IPC）" class="headerlink" title="3. 进程间通信（IPC）"></a>3. 进程间通信（IPC）</h4><ul>
<li><strong>Windows下有哪些进程间通信的方式？</strong><ul>
<li><strong>期望答案</strong>：<ol>
<li><strong>内存映射文件（Memory-Mapped File）</strong>：最常用、效率最高的方式之一。</li>
<li>命名管道（Named Pipe）</li>
<li>邮件槽（Mailslot）</li>
<li>共享内存（通常通过内存映射文件实现）</li>
<li>Windows消息（<code>PostMessage</code>, <code>SendMessage</code>，但有限制，如只能用于GUI进程）</li>
<li>Socket（即使是本机进程间也可用）</li>
<li>RPC（远程过程调用）</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、内存管理-Memory-Management"><a href="#二、内存管理-Memory-Management" class="headerlink" title="二、内存管理 (Memory Management)"></a>二、内存管理 (Memory Management)</h3><h4 id="1-基础概念-1"><a href="#1-基础概念-1" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h4><ul>
<li><p><strong>虚拟内存是什么？为什么需要它？</strong></p>
<ul>
<li><strong>期望答案</strong>：让每个进程都拥有一个独立的、连续的虚拟地址空间，由操作系统和CPU硬件共同映射到物理内存。它提供了内存保护（进程隔离）、简化了内存管理（程序员使用虚拟地址）、允许使用比物理内存更大的地址空间（通过分页到磁盘）。</li>
</ul>
</li>
<li><p><strong>Windows中，一个进程的虚拟地址空间布局是怎样的？</strong></p>
<ul>
<li><strong>期望答案</strong>：以32位进程为例（4GB空间），<strong>用户模式</strong>（0x00000000 - 0x7FFFFFFF，2GB），<strong>内核模式</strong>（0x80000000 - 0xFFFFFFFF，2GB）。代码、堆、栈、DLL等都分布在用户模式空间。64位系统空间巨大，布局原理类似。</li>
</ul>
</li>
</ul>
<h4 id="2-API与机制"><a href="#2-API与机制" class="headerlink" title="2. API与机制"></a>2. API与机制</h4><ul>
<li><strong>Windows提供了哪些操作内存的API？</strong><ul>
<li><strong>期望答案</strong>：<ul>
<li><code>VirtualAlloc</code> &#x2F; <code>VirtualFree</code>：直接从操作系统 reserve（保留） 或 commit（提交） 虚拟内存页，粒度较大（通常64KB），是堆管理的基础。</li>
<li><code>HeapAlloc</code> &#x2F; <code>HeapFree</code>：在堆上分配内存，是对 <code>VirtualAlloc</code> 的封装，粒度更小，更常用。C的 <code>malloc</code> 和 C++ 的 <code>new</code> 最终可能会调用它们。</li>
</ul>
</li>
</ul>
</li>
<li><strong>什么是内存泄漏？在Windows下如何检测和调试内存泄漏？</strong><ul>
<li><strong>期望答案</strong>：程序未能释放不再使用的内存。</li>
<li><strong>检测方法</strong>：使用工具如 <strong>Visual Studio 诊断工具</strong>、<strong>CRT库内置的检测功能</strong>（<code>_CrtDumpMemoryLeaks</code>）、<strong>第三方工具（VLD, Dr. Memory, WinDbg）</strong>。</li>
</ul>
</li>
<li><strong>什么是堆碎片？如何避免？</strong><ul>
<li><strong>期望答案</strong>：频繁地分配和释放不同大小的内存块，会导致大量小的空闲内存块分散在堆中，虽然总空闲内存足够，但无法分配连续的大块内存。避免方法：<strong>使用内存池（Memory Pool）</strong> 对象池来管理固定大小的对象分配。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三、消息机制-Message-Mechanism"><a href="#三、消息机制-Message-Mechanism" class="headerlink" title="三、消息机制 (Message Mechanism)"></a>三、消息机制 (Message Mechanism)</h3><p>这主要针对Windows GUI程序，但消息循环的概念也适用于其他场景（如 <code>PeekMessage</code> 实现的游戏循环）。</p>
<ul>
<li><strong>什么是消息循环（Message Loop）？它的基本流程是什么？</strong><ul>
<li><strong>期望答案</strong>：Windows GUI程序的核心，一个不断调用 <code>GetMessage</code>&#x2F;<code>PeekMessage</code> -&gt; <code>TranslateMessage</code> -&gt; <code>DispatchMessage</code> 的循环。用于从消息队列中获取消息（鼠标、键盘、窗口消息等），并将其分发给对应的窗口过程（Window Procedure）处理。</li>
</ul>
</li>
<li><strong><code>PostMessage</code> 和 <code>SendMessage</code> 有什么区别？</strong><ul>
<li><strong>期望答案</strong>：这是经典问题。<ul>
<li><code>PostMessage</code>：<strong>异步</strong>。将消息放入消息队列后立即返回，不等待处理。</li>
<li><code>SendMessage</code>：<strong>同步</strong>。直接调用目标窗口的窗口过程，等待它处理完毕后才返回。</li>
</ul>
</li>
</ul>
</li>
<li><strong>什么是窗口过程（Window Procedure, <code>WndProc</code>）？</strong><ul>
<li><strong>期望答案</strong>：每个窗口都有一个处理消息的函数，它是一个回调函数，原型为 <code>LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM)</code>。里面通常是一个巨大的 <code>switch-case</code> 结构来处理不同的消息（<code>WM_PAINT</code>, <code>WM_DESTROY</code>, <code>WM_COMMAND</code>等）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四、综合与实战-C-Specific-Practical"><a href="#四、综合与实战-C-Specific-Practical" class="headerlink" title="四、综合与实战 (C++ Specific &amp; Practical)"></a>四、综合与实战 (C++ Specific &amp; Practical)</h3><ul>
<li><strong>C++的 <code>new</code> 操作符在Windows下底层是如何实现的？它与 <code>malloc</code> 和 <code>HeapAlloc</code> 有什么关系？</strong><ul>
<li><strong>期望答案</strong>：<code>new</code> 操作符通常会调用C运行时库的 <code>malloc</code>，而CRT的 <code>malloc</code> 在Windows下最终会调用 <code>HeapAlloc</code> 来从默认的进程堆中分配内存。<code>new</code> 还会调用构造函数。</li>
</ul>
</li>
<li><strong>在多线程环境中使用C++ STL容器需要注意什么？</strong><ul>
<li><strong>期望答案</strong>：STL容器本身<strong>不是线程安全</strong>的。如果多个线程同时读写同一个容器，需要<strong>手动加锁</strong>进行同步。通常的做法是用一个临界区或互斥量保护对容器的所有访问操作。</li>
</ul>
</li>
<li><strong>如果你有一个GUI程序无响应（“未响应”状态），你可能如何排查？</strong><ul>
<li><strong>期望答案</strong>：这通常是<strong>主线程（UI线程）被长时间阻塞</strong>导致的。可以使用 <strong>Windbg</strong> 或 <strong>Visual Studio</strong> 附加到进程，<strong>暂停（Break）</strong> 执行，查看所有线程的调用栈（Call Stack）。很可能会发现主线程卡在某个耗时的操作（如文件读写、网络请求、复杂计算）或死锁上。<strong>黄金法则：不要在UI线程上做任何耗时操作！</strong></li>
</ul>
</li>
</ul>
<h3 id="面试建议"><a href="#面试建议" class="headerlink" title="面试建议"></a>面试建议</h3><ol>
<li><strong>结合代码示例</strong>：在解释概念时，如果能说出相关的API函数名甚至简单伪代码，会大大加分。例如，解释事件时，可以提到 <code>CreateEvent</code>, <code>SetEvent</code>, <code>WaitForSingleObject</code>。</li>
<li><strong>强调实战经验</strong>：如果你有过相关开发经验，一定要说出来。例如，“我在之前的项目中用命名管道实现过进程通信…”或“我用内存映射文件处理过大型数据文件…”。</li>
<li><strong>理解原理，不止于表面</strong>：不要只背概念，要理解为什么这么设计。例如，为什么有临界区还要有互斥量？（因为要跨进程）。</li>
<li><strong>准备一个项目</strong>：准备一个能体现你Windows编程能力的项目，并清晰地阐述你在其中负责的模块，用到了哪些上述技术。</li>
</ol>
<p>祝你面试顺利！这表明你面对的将是一个技术含量很高的职位，好好准备，机会很大</p>
<h2 id="腾讯一面C"><a href="#腾讯一面C" class="headerlink" title="腾讯一面C++"></a>腾讯一面C++</h2><p>好的，我们来逐一解答这些问题。答案会保持简洁、直击要点，便于理解和记忆。</p>
<hr>
<h3 id="1-开发一个-TCP-客户端，要分几步？"><a href="#1-开发一个-TCP-客户端，要分几步？" class="headerlink" title="1. 开发一个 TCP 客户端，要分几步？"></a>1. 开发一个 TCP 客户端，要分几步？</h3><p>通常分为 4 个核心步骤：</p>
<ol>
<li><strong>创建套接字 (Socket)</strong>：调用 <code>socket(AF_INET, SOCK_STREAM, 0)</code> 创建一个流式套接字。</li>
<li><strong>建立连接 (Connect)</strong>：调用 <code>connect()</code> 函数，指定服务器的 IP 地址和端口号，进行三次握手。</li>
<li><strong>数据传输 (Send&#x2F;Receive)</strong>：连接成功后，使用 <code>send()</code> 和 <code>recv()</code> 函数与服务器进行通信。</li>
<li><strong>关闭连接 (Close)</strong>：通信完毕，调用 <code>close()</code> 或 <code>closesocket()</code> 关闭套接字，发起四次挥手。</li>
</ol>
<h3 id="2-TCP-协议具体是干嘛的？"><a href="#2-TCP-协议具体是干嘛的？" class="headerlink" title="2. TCP 协议具体是干嘛的？"></a>2. TCP 协议具体是干嘛的？</h3><p>TCP（传输控制协议）是一种<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<ul>
<li><strong>面向连接</strong>：通信前必须先建立连接（三次握手）。</li>
<li><strong>可靠性</strong>：通过序列号、确认应答、超时重传、流量控制、拥塞控制等机制来保证数据不丢失、不重复、按序到达。</li>
<li><strong>基于字节流</strong>：传输的数据没有消息边界，应用层需要自己处理粘包&#x2F;拆包问题。</li>
</ul>
<h3 id="3-讲讲三次握手和四次挥手？"><a href="#3-讲讲三次握手和四次挥手？" class="headerlink" title="3. 讲讲三次握手和四次挥手？"></a>3. 讲讲三次握手和四次挥手？</h3><ul>
<li><p><strong>三次握手 (建立连接)</strong>：</p>
<ol>
<li><strong>客户端 -&gt; 服务器</strong>：发送 SYN 包 (SYN&#x3D;1, seq&#x3D;x)，进入 SYN_SENT 状态。</li>
<li><strong>服务器 -&gt; 客户端</strong>：发送 SYN-ACK 包 (SYN&#x3D;1, ACK&#x3D;1, ack&#x3D;x+1, seq&#x3D;y)，进入 SYN_RCVD 状态。</li>
<li><strong>客户端 -&gt; 服务器</strong>：发送 ACK 包 (ACK&#x3D;1, ack&#x3D;y+1)，双方进入 ESTABLISHED 状态，连接建立。</li>
</ol>
</li>
<li><p><strong>四次挥手 (断开连接)</strong>：</p>
<ol>
<li><strong>主动方 -&gt; 被动方</strong>：发送 FIN 包 (FIN&#x3D;1, seq&#x3D;u)，进入 FIN_WAIT_1 状态。</li>
<li><strong>被动方 -&gt; 主动方</strong>：发送 ACK 包 (ACK&#x3D;1, ack&#x3D;u+1)，进入 CLOSE_WAIT 状态。<em>（此时半关闭，被动方可能还有数据要发送）</em></li>
<li><strong>被动方 -&gt; 主动方</strong>：数据发送完毕后，发送 FIN 包 (FIN&#x3D;1, seq&#x3D;w, ack&#x3D;u+1)，进入 LAST_ACK 状态。</li>
<li><strong>主动方 -&gt; 被动方</strong>：发送 ACK 包 (ACK&#x3D;1, ack&#x3D;w+1)，进入 TIME_WAIT 状态（等待 2MSL 确保对方收到ACK），之后关闭。被动方收到ACK后立即关闭。</li>
</ol>
</li>
</ul>
<h3 id="4-一个-UDP-包最多能装多少数据？"><a href="#4-一个-UDP-包最多能装多少数据？" class="headerlink" title="4. 一个 UDP 包最多能装多少数据？"></a>4. 一个 UDP 包最多能装多少数据？</h3><p>理论上，一个 UDP 数据包的最大负载长度是 <strong>65507 字节</strong>。</p>
<ul>
<li>计算方式：IP 数据包最大长度 65535 字节 - IP 头部最小 20 字节 - UDP 头部 8 字节 &#x3D; 65507 字节。</li>
<li><strong>但实际上</strong>，为了避免被网络层分片（分片容易丢失导致整个包无效），通常应保证 <strong>UDP 包大小 &lt;&#x3D; MTU - IP头 - UDP头</strong>。在以太网中，MTU通常是1500字节，所以推荐的有效载荷约为 <code>1500 - 20 - 8 = 1472</code> 字节。</li>
</ul>
<h3 id="5-结构体和模板类有啥区别？"><a href="#5-结构体和模板类有啥区别？" class="headerlink" title="5. 结构体和模板类有啥区别？"></a>5. 结构体和模板类有啥区别？</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">结构体 (struct)</th>
<th align="left">模板类 (template class)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心目的</strong></td>
<td align="left"><strong>组织数据</strong>。将不同类型的数据组合成一个新的复合类型。</td>
<td align="left"><strong>泛型编程</strong>。编写与数据类型无关的通用代码。</td>
</tr>
<tr>
<td align="left"><strong>默认访问权限</strong></td>
<td align="left">public</td>
<td align="left">private</td>
</tr>
<tr>
<td align="left"><strong>编程范式</strong></td>
<td align="left">更偏向于面向过程&#x2F;数据抽象</td>
<td align="left">是泛型编程和元编程的核心</td>
</tr>
<tr>
<td align="left"><strong>实例化</strong></td>
<td align="left">编译时确定其成员和大小</td>
<td align="left">是一个<strong>代码生成工具</strong>，根据传入的类型参数在编译时生成具体的类</td>
</tr>
</tbody></table>
<p><strong>简单说</strong>：<code>struct</code> 是一种数据类型，<code>template class</code> 是生成各种 <code>class</code> 的“模具”。</p>
<h3 id="6-Linux-的-proc-目录是干嘛的？"><a href="#6-Linux-的-proc-目录是干嘛的？" class="headerlink" title="6. Linux 的 &#x2F;proc 目录是干嘛的？"></a>6. Linux 的 &#x2F;proc 目录是干嘛的？</h3><p><code>/proc</code> 是一个<strong>虚拟文件系统</strong>，它不占用磁盘空间，而是内核映射到内存中的一个接口。</p>
<ul>
<li><strong>作用</strong>：提供了<strong>查看和动态修改内核运行参数和系统状态</strong>的窗口。</li>
<li><strong>内容示例</strong>：<ul>
<li><code>/proc/cpuinfo</code>：CPU 信息</li>
<li><code>/proc/meminfo</code>：内存信息</li>
<li><code>/proc/&lt;PID&gt;/</code>：某个进程的详细信息（如命令行、内存映射、打开的文件等）</li>
<li><code>/proc/sys/</code>：内核参数，可以 <code>sysctl</code> 命令修改</li>
</ul>
</li>
</ul>
<h3 id="7-说几个你用过的调试工具？"><a href="#7-说几个你用过的调试工具？" class="headerlink" title="7. 说几个你用过的调试工具？"></a>7. 说几个你用过的调试工具？</h3><ul>
<li><strong>GDB</strong>：Linux 下强大的命令行调试器，用于 C&#x2F;C++。</li>
<li><strong>Strace</strong>：跟踪进程执行的系统调用，排查程序行为异常的神器。</li>
<li><strong>Valgrind</strong>：主要用于检测内存泄漏、内存越界等问题。</li>
<li><strong>Wireshark</strong>：网络抓包分析工具，用于分析网络协议、排查网络问题。</li>
<li><strong>IDE 内置调试器</strong>：如 Visual Studio, CLion, VSCode 的调试插件，提供图形化界面。</li>
</ul>
<h3 id="8-MySQL-引擎是啥？"><a href="#8-MySQL-引擎是啥？" class="headerlink" title="8. MySQL 引擎是啥？"></a>8. MySQL 引擎是啥？</h3><p>MySQL 存储引擎是<strong>负责数据的存储、检索和管理的底层软件组件</strong>。MySQL 采用了<strong>插件式架构</strong>，支持多种存储引擎，你可以为不同的表选择不同的引擎。</p>
<ul>
<li><strong>InnoDB</strong> (默认)：支持<strong>事务</strong>、<strong>行级锁</strong>、<strong>外键</strong>，提供崩溃恢复能力，适用于大多数需要ACID特性的应用。</li>
<li><strong>MyISAM</strong> (旧默认)：不支持事务和行级锁，只有表锁，但读性能很高，适用于大量读、少量写且不需要事务的场景（现已被淘汰）。</li>
<li><strong>Memory</strong>：所有数据存储在内存中，速度极快，但服务器重启后数据丢失。</li>
</ul>
<h3 id="9-DDoS-是啥？"><a href="#9-DDoS-是啥？" class="headerlink" title="9. DDoS 是啥？"></a>9. DDoS 是啥？</h3><p><strong>分布式拒绝服务攻击</strong>。</p>
<ul>
<li><strong>目的</strong>：通过海量的恶意流量（如伪造的请求、垃圾数据包）淹没目标服务器、服务或网络，耗尽其资源（带宽、CPU、内存），使其无法为正常用户提供服务的攻击方式。</li>
<li><strong>“分布式”含义</strong>：攻击流量来自被黑客控制的、分布在全球的大量“肉鸡”（被感染的计算机、IoT设备等）组成的僵尸网络，难以简单屏蔽。</li>
</ul>
<h3 id="10-Redis-有哪些数据结构？"><a href="#10-Redis-有哪些数据结构？" class="headerlink" title="10. Redis 有哪些数据结构？"></a>10. Redis 有哪些数据结构？</h3><p>Redis 不仅是简单的 Key-Value 存储，其 Value 支持多种丰富的数据结构：</p>
<ol>
<li><strong>String</strong>：字符串，最基础的类型。</li>
<li><strong>List</strong>：列表，双向链表，支持左右推送。</li>
<li><strong>Hash</strong>：哈希表，适合存储对象。</li>
<li><strong>Set</strong>：无序集合，自动去重。</li>
<li><strong>Sorted Set</strong>：有序集合，每个元素关联一个分数（score）用于排序。</li>
<li><strong>Bitmap &#x2F; HyperLogLog &#x2F; Geospatial</strong>：更高级的特殊类型。</li>
</ol>
<h3 id="11-Redis-缓存慢了怎么办？怎么做持久化？"><a href="#11-Redis-缓存慢了怎么办？怎么做持久化？" class="headerlink" title="11. Redis 缓存慢了怎么办？怎么做持久化？"></a>11. Redis 缓存慢了怎么办？怎么做持久化？</h3><ul>
<li><p><strong>慢了怎么办 (排查思路)</strong>：</p>
<ol>
<li><strong>排查慢查询</strong>：使用 <code>SLOWLOG GET</code> 命令。</li>
<li><strong>检查持久化阻塞</strong>：如果配置了 RDB 快照或 AOF 重写，大数据量时可能会阻塞主线程。</li>
<li><strong>检查内存使用</strong>：是否达到上限，触发淘汰策略？使用 <code>info memory</code>。</li>
<li><strong>检查网络</strong>：是否存在带宽瓶颈或延迟。</li>
<li><strong>检查 bigkey</strong>：大的复合结构（如包含百万元素的hash）的操作会很慢。</li>
<li><strong>考虑分片</strong>：使用 Redis Cluster 将数据分布到多个实例。</li>
</ol>
</li>
<li><p><strong>持久化方式</strong>：</p>
<ol>
<li><strong>RDB (快照)</strong>：在指定时间间隔生成数据的二进制快照文件（<code>.rdb</code>）。<strong>优点</strong>：文件小，恢复快。<strong>缺点</strong>：可能会丢失最后一次快照之后的数据。</li>
<li><strong>AOF (追加文件)</strong>：记录每一个写操作命令到日志文件。<strong>优点</strong>：数据 durability 高，最多丢失1秒数据。<strong>缺点</strong>：文件大，恢复慢。</li>
<li><strong>混合持久化</strong> (推荐)：同时开启 RDB 和 AOF。重写时，先把当前数据以 RDB 格式写入 AOF 文件开头，再将期间的写命令以 AOF 格式追加到文件。兼具速度和数据安全性。</li>
</ol>
</li>
</ul>
<h3 id="12-聊聊消息队列？"><a href="#12-聊聊消息队列？" class="headerlink" title="12. 聊聊消息队列？"></a>12. 聊聊消息队列？</h3><p>消息队列是一种<strong>异步的服务间通信方式</strong>。发送者（生产者）将消息放入队列，接收者（消费者）从队列中取出并处理消息。</p>
<ul>
<li><strong>核心作用</strong>：<ol>
<li><strong>解耦</strong>：分离生产者和消费者，互不影响。</li>
<li><strong>异步</strong>：生产者发送后即可返回，无需等待消费者处理完成。</li>
<li><strong>削峰填谷</strong>：应对突发流量，消息队列作为缓冲区，避免系统被冲垮。</li>
</ol>
</li>
<li><strong>常见产品</strong>：Kafka, RabbitMQ, RocketMQ, Redis Stream。</li>
</ul>
<h3 id="13-说几个-Agent-框架？"><a href="#13-说几个-Agent-框架？" class="headerlink" title="13. 说几个 Agent 框架？"></a>13. 说几个 Agent 框架？</h3><p>Agent 指常驻在被管理机器上的代理程序，用于采集数据、执行任务、接受控制。</p>
<ul>
<li><strong>Telegraf</strong>： metrics 采集 Agent，是监控系统 InfluxDB 的组成部分。</li>
<li><strong>Datadog Agent</strong>： Datadog 监控平台的代理。</li>
<li><strong>Elastic Beat</strong> (如 Filebeat, Metricbeat)： Elastic Stack (ELK) 的数据采集器。</li>
<li><strong>Prometheus Node Exporter</strong>： 用于暴露主机 metrics 给 Prometheus 抓取。</li>
<li><strong>Zabbix Agent</strong>： Zabbix 监控系统的代理。</li>
</ul>
<h3 id="14-MCP-是啥？"><a href="#14-MCP-是啥？" class="headerlink" title="14. MCP 是啥？"></a>14. MCP 是啥？</h3><p><strong>M</strong>odel <strong>C</strong>ontext <strong>P</strong>rotocol (模型上下文协议)。</p>
<ul>
<li><strong>背景</strong>：由 Anthropic 等公司提出，旨在解决 AI 助手（如 Claude）如何与外部工具、数据源和工作流更安全、高效地集成的问题。</li>
<li><strong>作用</strong>：它是一个<strong>开放标准</strong>，定义了 AI 模型与外部服务器（提供工具、数据等的“资源”）之间如何进行通信。它让模型能够动态地<strong>发现、调用</strong>外部资源，而无需将这些功能的细节硬编码到模型本身。</li>
</ul>
<h3 id="15-MCP-用的是什么通信协议？"><a href="#15-MCP-用的是什么通信协议？" class="headerlink" title="15. MCP 用的是什么通信协议？"></a>15. MCP 用的是什么通信协议？</h3><p>MCP 的核心通信<strong>不绑定于某一特定传输层协议</strong>，它可以在不同的协议上运行。<br>但其 <strong>消息格式</strong> 是基于 <strong>JSON-RPC 2.0</strong> 的。</p>
<ul>
<li><p>通信可以在 <strong>stdio</strong> (标准输入输出)、<strong>SSE</strong> (Server-Sent Events) 或 <strong>WebSocket</strong> 等传输协议上进行。</p>
</li>
<li><p>例如，一个常见的部署方式是 MCP 服务器（资源提供方）与 AI 客户端（如 Claude IDE 插件）通过 <strong>stdio</strong> 进行通信，交换 JSON-RPC 2.0 格式的消息。</p>
</li>
</ul>
<h2 id="字节一面C"><a href="#字节一面C" class="headerlink" title="字节一面C++"></a>字节一面C++</h2><p>  好的，我们来逐一解答这些问题。答案会保持简洁、直击要点，便于面试时快速组织语言。</p>
<h3 id="1-Http请求中有哪些请求方式？"><a href="#1-Http请求中有哪些请求方式？" class="headerlink" title="1. Http请求中有哪些请求方式？"></a>1. Http请求中有哪些请求方式？</h3><p>  最常用的有5种，总共有9种（但一些不常用）：</p>
<ul>
<li><strong>GET</strong>：请求获取指定的资源。</li>
<li><strong>POST</strong>：向指定资源提交数据，请求服务器进行处理（例如提交表单或上传文件）。</li>
<li><strong>PUT</strong>：替换指定的资源（全部更新）。</li>
<li><strong>DELETE</strong>：请求服务器删除指定的资源。</li>
<li><strong>PATCH</strong>：对资源进行部分修改。</li>
<li>其他（了解即可）：HEAD（获取报文头）、OPTIONS（询问支持的方法）、TRACE、CONNECT。</li>
</ul>
<h3 id="2-说一下Https是如何保证链接安全的？"><a href="#2-说一下Https是如何保证链接安全的？" class="headerlink" title="2. 说一下Https是如何保证链接安全的？"></a>2. 说一下Https是如何保证链接安全的？</h3><p>  HTTPS 通过 <strong>SSL&#x2F;TLS 协议</strong>在 HTTP 之下提供了一个安全层，从三个方面保证安全：</p>
<pre><code>1.  **加密**：防止通信内容被窃听。（混合加密机制）
2.  **认证**：防止身份被冒充。（数字证书机制）
3.  **完整性保护**：防止内容被篡改。（摘要算法）
</code></pre>
<h3 id="3-Https的加密方式是怎样的？对称还是非对称？"><a href="#3-Https的加密方式是怎样的？对称还是非对称？" class="headerlink" title="3. Https的加密方式是怎样的？对称还是非对称？"></a>3. Https的加密方式是怎样的？对称还是非对称？</h3><p>  HTTPS 采用 <strong>混合加密</strong> 机制，结合了<strong>非对称加密</strong>和<strong>对称加密</strong>的优点：</p>
<pre><code>1.  **非对称加密 (用于握手阶段)**：在建立连接时，使用非对称加密（如RSA、ECDSA）来安全地交换一个**会话密钥**（`Pre-Master Secret`）。这个过程可以防止密钥被窃听。
2.  **对称加密 (用于传输阶段)**：连接建立后，双方使用上一步协商出的同一个会话密钥（`Master Secret`）进行对称加密（如AES、ChaCha20）通信。这是因为对称加密的计算效率远高于非对称加密。
</code></pre>
<h3 id="4-Http的状态码都有哪些，代表什么意思？"><a href="#4-Http的状态码都有哪些，代表什么意思？" class="headerlink" title="4. Http的状态码都有哪些，代表什么意思？"></a>4. Http的状态码都有哪些，代表什么意思？</h3><p>  状态码分为5类：</p>
<ul>
<li><strong>1xx (信息性)</strong>：请求已被接收，继续处理。 (如 100 Continue)</li>
<li><strong>2xx (成功)</strong>：请求已成功被服务器接收、理解、并接受。 (如 <strong>200 OK</strong>, 201 Created)</li>
<li><strong>3xx (重定向)</strong>：需要后续操作才能完成这一请求。 (如 <strong>301 Moved Permanently</strong>, <strong>302 Found</strong>, 304 Not Modified)</li>
<li><strong>4xx (客户端错误)</strong>：请求含有词法错误或者无法被执行。 (如 <strong>400 Bad Request</strong>, <strong>401 Unauthorized</strong>, <strong>403 Forbidden</strong>, <strong>404 Not Found</strong>)</li>
<li><strong>5xx (服务器错误)</strong>：服务器在处理某个正确请求时发生错误。 (如 <strong>500 Internal Server Error</strong>, <strong>502 Bad Gateway</strong>, <strong>503 Service Unavailable</strong>)</li>
</ul>
<h3 id="5-TCP是如何实现可靠传输的呢？"><a href="#5-TCP是如何实现可靠传输的呢？" class="headerlink" title="5. TCP是如何实现可靠传输的呢？"></a>5. TCP是如何实现可靠传输的呢？</h3><p>  主要通过以下机制：</p>
<pre><code>1.  **序列号与确认应答 (ACK)**：每个字节都有序号，接收方收到后必须发送ACK确认。如果发送方在一定时间内没收到ACK，就认为丢包。
2.  **超时重传**：对未收到ACK的包进行重传。
3.  **连接管理**：通过三次握手建立可靠连接，四次挥手释放连接。
4.  **流量控制**：通过滑动窗口机制，根据接收方的处理能力来动态调整发送速率，防止接收方缓冲区溢出。
5.  **拥塞控制**：通过慢启动、拥塞避免、快重传、快恢复等算法来探测网络状况，防止过多的数据注入网络导致网络瘫痪。
</code></pre>
<h3 id="6-在浏览器中输入url后会发生哪些事情？"><a href="#6-在浏览器中输入url后会发生哪些事情？" class="headerlink" title="6. 在浏览器中输入url后会发生哪些事情？"></a>6. 在浏览器中输入url后会发生哪些事情？</h3><p>  这是一个经典问题，过程非常复杂，简化后核心步骤如下：</p>
<pre><code>1.  **DNS解析**：浏览器将域名解析为对应的IP地址。
2.  **建立TCP连接**：与服务器进行三次握手，建立TCP连接。
3.  **发送HTTP请求**：浏览器构建HTTP请求报文，并通过TCP连接发送给服务器。
4.  **服务器处理请求并返回响应**：服务器处理请求，并返回HTTP响应报文（包含状态码、HTML文件等）。
5.  **浏览器解析渲染页面**：
    *   解析HTML构建DOM树。
    *   解析CSS构建CSSOM树。
    *   将DOM和CSSOM合并成渲染树（Render Tree）。
    *   进行布局（Layout）计算每个节点的几何信息。
    *   绘制（Painting）页面像素信息。
    *   合成（Compositing）层并显示到屏幕上。
6.  **断开连接**：完成数据交换后，通过四次挥手断开TCP连接。
</code></pre>
<h3 id="7-C-指针和引用的差别是什么？"><a href="#7-C-指针和引用的差别是什么？" class="headerlink" title="7. C++指针和引用的差别是什么？"></a>7. C++指针和引用的差别是什么？</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">指针 (Pointer)</th>
<th align="left">引用 (Reference)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left">是一个变量，存储的是另一个变量的<strong>内存地址</strong></td>
<td align="left">是一个变量的<strong>别名</strong>，和原变量是同一个东西</td>
</tr>
<tr>
<td align="left"><strong>初始化</strong></td>
<td align="left">可以不初始化（但危险），可以指向NULL</td>
<td align="left"><strong>必须初始化</strong>，且一旦绑定不能改变指向</td>
</tr>
<tr>
<td align="left"><strong>操作</strong></td>
<td align="left">可以进行<code>++</code>, <code>--</code>等算术运算</td>
<td align="left">没有这种算术运算</td>
</tr>
<tr>
<td align="left"><strong>空值</strong></td>
<td align="left">可以指向<code>nullptr</code></td>
<td align="left">不能绑定到空值</td>
</tr>
<tr>
<td align="left"><strong>多级</strong></td>
<td align="left">可以有指针的指针 (<code>**ptr</code>)</td>
<td align="left">没有引用的引用</td>
</tr>
</tbody></table>
<h3 id="8-说一下动态链接和静态链接是什么，以及各自的优缺点"><a href="#8-说一下动态链接和静态链接是什么，以及各自的优缺点" class="headerlink" title="8. 说一下动态链接和静态链接是什么，以及各自的优缺点"></a>8. 说一下动态链接和静态链接是什么，以及各自的优缺点</h3><ul>
<li><p><strong>静态链接</strong>：在<strong>编译链接期</strong>，将库的代码直接拷贝到最终的可执行文件中。</p>
<ul>
<li><strong>优点</strong>：执行速度快（无需运行时加载），移植性好（不依赖系统环境）。</li>
<li><strong>缺点</strong>：可执行文件体积大，库升级需要重新编译整个程序。</li>
</ul>
</li>
<li><p><strong>动态链接</strong>：在<strong>运行时</strong>才将所需的库文件加载到内存中并与程序连接。</p>
<ul>
<li><strong>优点</strong>：可执行文件体积小，多个程序可共享同一个库（节省内存），库升级方便（只需替换库文件）。</li>
<li><strong>缺点</strong>：执行速度稍慢，有依赖问题（程序运行时需要系统存在对应版本的库）。</li>
</ul>
</li>
</ul>
<h3 id="9-说一下深拷贝和浅拷贝的区别"><a href="#9-说一下深拷贝和浅拷贝的区别" class="headerlink" title="9. 说一下深拷贝和浅拷贝的区别"></a>9. 说一下深拷贝和浅拷贝的区别</h3><ul>
<li><strong>浅拷贝</strong>：只拷贝对象的基本数据成员和<strong>指针的值</strong>（即地址），而不拷贝指针所指向的内存。结果是两个对象的指针成员指向<strong>同一块内存</strong>。容易引发重复释放、悬垂指针等问题。</li>
<li><strong>深拷贝</strong>：不仅拷贝基本数据成员，还会为指针成员<strong>重新分配内存</strong>，并拷贝指针所指向的<strong>内容</strong>。结果是两个对象完全独立，互不影响。</li>
</ul>
<p>  <strong>简单比喻</strong>：浅拷贝是复制一张名片（只复制了地址），深拷贝是按照名片地址找到那栋楼并自己也盖一栋一模一样的（复制了内容）。</p>
<h3 id="10-进程通信的解耦机制？"><a href="#10-进程通信的解耦机制？" class="headerlink" title="10. 进程通信的解耦机制？"></a>10. 进程通信的解耦机制？</h3><p>  解耦的核心是让进程<strong>不直接通信</strong>，而是通过一个<strong>中间实体（Intermediary）</strong> 来间接通信。常见的解耦机制有：</p>
<ul>
<li><strong>消息队列 (Message Queue)</strong>：进程将消息放入队列，另一个进程从队列中取出。发送者和接收者不需要同时运行，也不需要知道对方的存在。</li>
<li><strong>共享内存 (Shared Memory)</strong>：虽然需要同步机制（如信号量）配合，但它将通信的“数据缓冲区”与进程解耦，任何进程都可以访问。</li>
<li><strong>命名管道 (FIFO)</strong> 或 <strong>网络Socket</strong>：提供了一种标准的通信通道，进程只需向通道读写，而不关心另一端是谁。</li>
</ul>
<h3 id="11-linux进程通信的几种方式以及各自的应用场景"><a href="#11-linux进程通信的几种方式以及各自的应用场景" class="headerlink" title="11. linux进程通信的几种方式以及各自的应用场景"></a>11. linux进程通信的几种方式以及各自的应用场景</h3><pre><code>1.  **管道 (Pipe)**：单向通信。用于有亲缘关系（父子进程）的进程间通信。`ls | grep test`。
2.  **命名管道 (FIFO)**：克服了管道没有名字的限制，可用于无亲缘关系的进程。
3.  **消息队列 (Message Queue)**：消息的链表，克服了管道字节流模型的限制。用于需要按特定消息单元通信的场景。
4.  **共享内存 (Shared Memory)**：最快的IPC方式。多个进程共享同一块内存空间。需要与信号量等同步机制配合使用。适用于对通信速度要求极高的场景，如大数据交换。
5.  **信号量 (Semaphore)**：主要用作**进程间同步**，控制多个进程对共享资源的访问。
6.  **信号 (Signal)**：一种异步通信机制，用于通知接收进程某个事件已经发生（如 `kill -9`）。
7.  **套接字 (Socket)**：最通用的IPC方式，不仅可用于同一台主机的进程间通信，还可用于网络通信。
</code></pre>
<h3 id="12-说一下数据库的范式"><a href="#12-说一下数据库的范式" class="headerlink" title="12. 说一下数据库的范式"></a>12. 说一下数据库的范式</h3><p>  范式是设计数据库表结构的规范，目的是减少数据冗余，提高数据一致性。</p>
<ul>
<li><strong>第一范式 (1NF)</strong>：<strong>原子性</strong>。字段是不可再分的最小单元。</li>
<li><strong>第二范式 (2NF)</strong>：在满足1NF的基础上，<strong>消除非主属性对候选码的部分函数依赖</strong>。即每个非主字段必须完全依赖于整个主键（针对联合主键）。</li>
<li><strong>第三范式 (3NF)</strong>：在满足2NF的基础上，<strong>消除非主属性对候选码的传递函数依赖</strong>。即非主字段不能依赖于另一个非主字段。</li>
<li><strong>巴斯-科德范式 (BCNF)</strong>：在3NF的基础上，<strong>消除主属性对候选码的部分和传递函数依赖</strong>。</li>
</ul>
<p>  通常，设计到<strong>第三范式</strong>就足够满足大多数应用需求。</p>
<h3 id="13-说一下多线程死锁的原因吧"><a href="#13-说一下多线程死锁的原因吧" class="headerlink" title="13. 说一下多线程死锁的原因吧"></a>13. 说一下多线程死锁的原因吧</h3><p>  死锁是指两个或两个以上的线程在执行过程中，因<strong>争夺资源</strong>而造成的一种互相等待的现象。死锁产生的<strong>四个必要条件</strong>（缺一不可）：</p>
<pre><code>1.  **互斥条件**：一个资源每次只能被一个线程使用。
2.  **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3.  **不剥夺条件**：线程已获得的资源，在未使用完之前，不能强行剥夺。
4.  **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系。
</code></pre>
<h3 id="14-如何避免死锁呢？"><a href="#14-如何避免死锁呢？" class="headerlink" title="14. 如何避免死锁呢？"></a>14. 如何避免死锁呢？</h3><p>  只要破坏死锁四个必要条件中的<strong>任意一个</strong>即可。<br>    1.  <strong>破坏“请求与保持”</strong>：一次性申请所有所需资源，否则不执行。<br>    2.  <strong>破坏“不剥夺”</strong>：如果一个线程申请新资源失败，它必须释放已占有的所有资源。<br>    3.  <strong>破坏“循环等待”</strong>：给所有资源统一编号，线程必须按编号的<strong>递增顺序</strong>申请资源。（最常用且实用的策略）<br>    4.  <strong>使用超时机制</strong>：在尝试获取锁时设置超时时间，超时后放弃并释放已有资源，避免无限期等待。</p>
<h2 id="百度一面C"><a href="#百度一面C" class="headerlink" title="百度一面C++"></a>百度一面C++</h2><p>好的，我们来逐一解答这些面试题。答案会保持清晰、准确，并包含必要的深度。</p>
<hr>
<h3 id="C-的多态是如何实现的？"><a href="#C-的多态是如何实现的？" class="headerlink" title="C++的多态是如何实现的？"></a>C++的多态是如何实现的？</h3><p>C++的多态主要通过 <strong>虚函数 (Virtual Function)</strong> 和 <strong>动态绑定 (Dynamic Binding)</strong> 来实现，其核心技术是 <strong>虚函数表 (vtable)</strong> 和 <strong>虚函数表指针 (vptr)</strong>。</p>
<p><strong>实现机制：</strong></p>
<ol>
<li><p><strong>虚函数表 (vtable)</strong>：</p>
<ul>
<li>编译器会为每一个<strong>包含虚函数的类</strong>自动生成一个虚函数表。</li>
<li>虚函数表是一个函数指针数组，其中的每个元素指向该类的一个虚函数的实际实现地址。</li>
</ul>
</li>
<li><p><strong>虚函数表指针 (vptr)</strong>：</p>
<ul>
<li>编译器会在包含虚函数的类的对象中自动添加一个隐藏的成员变量——虚函数表指针 (<code>vptr</code>)。</li>
<li>当一个对象被创建时，它的 <code>vptr</code> 会被初始化，指向其所属类的 <code>vtable</code>。</li>
</ul>
</li>
<li><p><strong>动态绑定过程</strong>：</p>
<ul>
<li>当程序通过一个<strong>基类指针或引用</strong>调用一个虚函数时（例如 <code>basePtr-&gt;func();</code>），编译器不会直接生成调用具体函数的代码。</li>
<li>Instead，它会生成代码来执行以下操作：<br>a.  通过对象内部的 <code>vptr</code> 找到该对象对应的 <code>vtable</code>。<br>b.  在 <code>vtable</code> 中找到被调用虚函数对应的函数指针（位置在编译时就已确定）。<br>c.  通过该函数指针调用正确的函数（派生类的覆盖版本）。</li>
</ul>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 覆盖虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    basePtr-&gt;<span class="built_in">func</span>(); <span class="comment">// 输出 &quot;Derived&quot;</span></span><br><span class="line">    <span class="comment">// 1. 通过basePtr找到Derived对象</span></span><br><span class="line">    <span class="comment">// 2. 通过Derived对象内部的vptr找到Derived类的vtable</span></span><br><span class="line">    <span class="comment">// 3. 在vtable中找到Derived::func的地址并调用</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 多态的实现代价是每个对象需要额外的空间（<code>vptr</code>）和每次调用虚函数需要一次间接寻址（查表），但换来了极大的灵活性。</p>
<hr>
<h3 id="vector的插入复杂度，map的插入复杂度"><a href="#vector的插入复杂度，map的插入复杂度" class="headerlink" title="vector的插入复杂度，map的插入复杂度"></a>vector的插入复杂度，map的插入复杂度</h3><ul>
<li><p><strong><code>std::vector</code> 的插入复杂度</strong>：</p>
<ul>
<li><strong>在末尾插入 (<code>push_back</code>)</strong>：<strong>平均复杂度为 O(1)</strong>。虽然在某些情况下需要重新分配内存并拷贝所有元素（此时为 O(n)），但通过扩容策略（通常是翻倍），其<strong>均摊 (Amortized)</strong> 复杂度是 O(1)。</li>
<li><strong>在中间或开头插入 (<code>insert</code>)</strong>：<strong>复杂度为 O(n)</strong>。因为需要将插入点之后的所有元素都向后移动一位。</li>
</ul>
</li>
<li><p><strong><code>std::map</code> (通常用红黑树实现) 的插入复杂度</strong>：</p>
<ul>
<li><strong>插入一个元素 (<code>insert</code>)</strong>：<strong>O(log n)</strong>。因为红黑树是平衡二叉搜索树，插入操作需要先查找位置 (O(log n))，再进行最多常数次的旋转调整以保持平衡。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="了解std-move-吗？…"><a href="#了解std-move-吗？…" class="headerlink" title="了解std::move()吗？…"></a>了解std::move()吗？…</h3><ul>
<li><p><strong><code>std::move()</code> 是什么？</strong><br><code>std::move()</code> 本质上是一个<strong>类型转换函数</strong>，而非“移动”操作。它将一个左值强制转换为右值引用。它的作用是<strong>标识一个对象的值不再需要，其资源可以被“移动”而非拷贝</strong>，从而允许高效的资源转移。</p>
</li>
<li><p><strong>如果想使用std::move()，在类中做什么样的配合？</strong><br>要配合 <code>std::move</code> 实现高效的资源转移，类需要定义<strong>移动构造函数 (Move Constructor)</strong> 和<strong>移动赋值运算符 (Move Assignment Operator)</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 关键：置空源对象，防止其析构时释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;       <span class="comment">// 释放自己的资源</span></span><br><span class="line">            data = other.data;   <span class="comment">// 接管资源</span></span><br><span class="line">            other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 拷贝构造、析构等函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>int a = 3; int b = move(3);</code>，那a和b的值现在分别是什么？</strong></p>
<ul>
<li><code>int a = 3;</code>：<code>a</code> 的值是 <strong>3</strong>。</li>
<li><code>int b = move(3);</code>：<code>3</code> 是一个字面量，本身就是右值。<code>std::move(3)</code> 的结果仍然是右值。对于内置类型（如 <code>int</code>），移动和拷贝是<strong>没有区别</strong>的，因为它们的“资源”就是值本身，复制成本极低。所以 <code>b</code> 的值也是 <strong>3</strong>。</li>
<li><strong>关键点</strong>：<code>std::move()</code> 本身不产生任何移动操作，它只是将一个表达式转换为右值。只有当一个类<strong>定义了移动语义</strong>（如移动构造函数）时，这个右值才会被用来触发移动操作而不是拷贝操作。对于没有移动语义的类或内置类型，<code>std::move()</code> 后依然会进行拷贝。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="了解C-中的模板吗？实际使用过吗？"><a href="#了解C-中的模板吗？实际使用过吗？" class="headerlink" title="了解C++中的模板吗？实际使用过吗？"></a>了解C++中的模板吗？实际使用过吗？</h3><ul>
<li><p><strong>了解</strong>：C++模板是一种支持<strong>泛型编程</strong>的工具。它允许你编写与类型无关的代码。编译器会根据使用时提供的具体类型，在编译期实例化出对应的代码。</p>
<ul>
<li><strong>模板函数</strong>：<code>template &lt;typename T&gt; T max(T a, T b) &#123; return (a &gt; b) ? a : b; &#125;</code></li>
<li><strong>模板类</strong>：<code>template &lt;typename T&gt; class Stack &#123; ... &#125;;</code></li>
</ul>
</li>
<li><p><strong>实际使用</strong>：</p>
<ul>
<li><strong>STL容器</strong>：每天都在用，如 <code>vector&lt;int&gt;</code>, <code>map&lt;string, int&gt;</code>。</li>
<li><strong>STL算法</strong>：如 <code>sort(myVec.begin(), myVec.end())</code>，<code>find</code> 等，都是函数模板。</li>
<li><strong>自定义工具</strong>：比如编写一个泛型的日志函数、一个序列化工具类，或者实现一个线程安全的队列模板。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="std-sort-底层使用什么排序算法？…"><a href="#std-sort-底层使用什么排序算法？…" class="headerlink" title="std::sort()底层使用什么排序算法？…"></a>std::sort()底层使用什么排序算法？…</h3><ul>
<li><p><strong><code>std::sort()</code> 的底层算法</strong>：它并非单一算法，而是一种混合算法 <strong>内省排序 (Introsort)</strong>。</p>
<ol>
<li><strong>主要使用快速排序</strong>。</li>
<li>当递归深度过深（接近最坏情况 O(n²) 时，转为<strong>堆排序</strong>（保证最坏时间复杂度为 O(n log n)）。</li>
<li>当排序的元素数量很少时（例如 &lt;&#x3D; 16），转为<strong>插入排序</strong>（因为对于小数据量，插入排序的常数因子小，实际效率更高）。</li>
</ol>
</li>
<li><p><strong>排序算法复杂度</strong>：</p>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">平均时间复杂度</th>
<th align="left">最坏时间复杂度</th>
<th align="left">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>快速排序</strong></td>
<td align="left">O(n log n)</td>
<td align="left">O(n²)</td>
<td align="left">O(log n) ~ O(n)</td>
</tr>
<tr>
<td align="left"><strong>堆排序</strong></td>
<td align="left">O(n log n)</td>
<td align="left">O(n log n)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><strong>插入排序</strong></td>
<td align="left">O(n²)</td>
<td align="left">O(n²)</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="用过多线程编程吗？"><a href="#用过多线程编程吗？" class="headerlink" title="用过多线程编程吗？"></a>用过多线程编程吗？</h3><p><strong>是的，用过。</strong></p>
<ul>
<li><strong>使用的API&#x2F;库</strong>：主要使用 C++11 标准库中的 <code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code>, <code>&lt;condition_variable&gt;</code>, <code>&lt;future&gt;</code> 等。也使用过 POSIX Threads (pthreads)。</li>
<li><strong>常见任务</strong>：<ul>
<li>创建线程执行并发任务（计算、I&#x2F;O）。</li>
<li>使用<strong>互斥锁 (<code>std::mutex</code>)</strong> 和<strong>锁保护 (<code>std::lock_guard</code>)</strong> 来保护共享数据，避免竞态条件。</li>
<li>使用<strong>条件变量 (<code>std::condition_variable</code>)</strong> 来实现线程间的等待和通知机制（生产者-消费者模型）。</li>
<li>使用<strong>异步操作 (<code>std::async</code>, <code>std::future</code>)</strong> 来获取后台任务的结果。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="遍历求和效率问题…"><a href="#遍历求和效率问题…" class="headerlink" title="遍历求和效率问题…"></a>遍历求和效率问题…</h3><p><strong>先遍历行再遍历列的效率远高于先遍历列再遍历行。</strong></p>
<p><strong>原因：这与CPU缓存的工作机制（局部性原理）密切相关。</strong></p>
<ol>
<li><strong>内存布局</strong>：C&#x2F;C++中的多维数组在内存中是<strong>行主序 (Row-Major)</strong> 连续存储的。<code>array[0][0]</code>, <code>array[0][1]</code>, <code>array[0][2]</code> … 的地址是连续的。</li>
<li><strong>CPU缓存与缓存行 (Cache Line)</strong>：<ul>
<li>CPU访问内存时，并非一次只读一个字节，而是会一次性读取一个<strong>缓存行</strong>（通常为64字节）到高速缓存中。</li>
<li>如果你按行遍历，<code>array[i][j]</code> 之后访问的 <code>array[i][j+1]</code> 有很大的概率已经在缓存中了（<strong>空间局部性</strong>），CPU直接命中缓存，速度极快。</li>
</ul>
</li>
<li><strong>低效的列遍历</strong>：<ul>
<li>如果你按列遍历，例如访问 <code>array[0][0]</code> 后跳去访问 <code>array[1][0]</code>，这两个元素在内存中相距 <code>10000 * sizeof(int)</code> 个字节。它们极不可能在同一个缓存行内。</li>
<li>每次访问都会导致<strong>缓存未命中 (Cache Miss)</strong>，CPU必须去速度慢得多的主内存中读取数据，这会浪费大量等待时间（称为停滞周期）。</li>
<li>这还会导致之前被加载到缓存中的有效数据（如一整行的数据）可能被频繁换出，缓存利用率极低。</li>
</ul>
</li>
</ol>
<p><strong>结论：</strong> 编写循环时，应尽量让<strong>最内层的循环遍历连续的内存地址</strong>，以最大化缓存命中率，这是最重要的性能优化手段之一。</p>
<hr>
<h3 id="机器学习方面了解哪些？知道有几种优化器吗？"><a href="#机器学习方面了解哪些？知道有几种优化器吗？" class="headerlink" title="机器学习方面了解哪些？知道有几种优化器吗？"></a>机器学习方面了解哪些？知道有几种优化器吗？</h3><ul>
<li><p><strong>了解方面</strong>：了解机器学习的基本流程（数据预处理、模型定义、训练、评估）、常见的监督学习（分类、回归）和无监督学习（聚类）任务，以及深度学习的基础（神经网络、反向传播）。</p>
</li>
<li><p><strong>优化器 (Optimizer)</strong>：优化器是用于在训练过程中更新模型参数（权重和偏置）以最小化损失函数的算法。</p>
<ul>
<li><strong>SGD (随机梯度下降)</strong>：最基础，但容易震荡，收敛慢。</li>
<li><strong>SGD with Momentum</strong>：引入“动量”概念，加速SGD并抑制震荡。</li>
<li><strong>AdaGrad</strong>：为每个参数自适应地调整学习率，适合稀疏数据。</li>
<li><strong>RMSprop</strong>：是AdaGrad的改进，解决其学习率急剧下降的问题。</li>
<li><strong>Adam (最常用)</strong>：结合了Momentum和RMSprop的优点，通常收敛快且效果好，是默认的推荐选择。</li>
<li><strong>AdamW</strong>：Adam的变体，修正了权重衰减（L2正则化）的实现，通常泛化能力更好。</li>
</ul>
</li>
</ul>
<h2 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h2><p>以下是对这些问题的详细解答，涵盖 C++ 语言特性、内存模型、设计模式、操作系统、编译链接、网络协议等多个方面：</p>
<hr>
<h3 id="1️⃣-一个-C-类的大小会受哪些因素影响？"><a href="#1️⃣-一个-C-类的大小会受哪些因素影响？" class="headerlink" title="1️⃣ 一个 C++ 类的大小会受哪些因素影响？"></a>1️⃣ 一个 C++ 类的大小会受哪些因素影响？</h3><ul>
<li><strong>非静态成员变量</strong>：每个非静态成员变量占用内存，对齐（alignment）会影响总大小。</li>
<li><strong>虚函数</strong>：引入虚函数会导致类中包含一个虚表指针（vptr），通常为 4 或 8 字节（32&#x2F;64 位系统）。</li>
<li><strong>继承</strong>：基类的成员变量会并入派生类，可能引入额外的 vptr（多继承时可能多个）。</li>
<li><strong>对齐（Alignment）</strong>：编译器会根据成员变量的对齐要求插入填充字节（padding）。</li>
<li><strong>空类</strong>：大小为 1 字节（用于区分不同实例）。</li>
<li><strong>静态成员变量</strong>：不占用实例大小（存放在全局数据区）。</li>
</ul>
<hr>
<h3 id="2️⃣-虚表指针在类里是怎么分布的？"><a href="#2️⃣-虚表指针在类里是怎么分布的？" class="headerlink" title="2️⃣ 虚表指针在类里是怎么分布的？"></a>2️⃣ 虚表指针在类里是怎么分布的？</h3><ul>
<li>通常位于类实例的<strong>起始位置</strong>（最常见，便于多态访问），但也可能在其他位置（取决于编译器实现）。</li>
<li>每个多态类（含虚函数或继承自多态类）至少有一个 vptr。</li>
<li>多继承时，可能包含多个 vptr（每个基类一个）。</li>
</ul>
<hr>
<h3 id="3️⃣-多继承且每个父类都有虚函数时，内存布局和虚表指针如何分布？"><a href="#3️⃣-多继承且每个父类都有虚函数时，内存布局和虚表指针如何分布？" class="headerlink" title="3️⃣ 多继承且每个父类都有虚函数时，内存布局和虚表指针如何分布？"></a>3️⃣ 多继承且每个父类都有虚函数时，内存布局和虚表指针如何分布？</h3><ul>
<li>派生类实例包含<strong>所有基类的子对象</strong>（按声明顺序排列）。</li>
<li>每个基类子对象可能包含自己的 vptr（如果该基类有多态性）。</li>
<li>派生类可能有一个额外的 vptr（用于自己的虚函数）。</li>
<li>虚表（vtable）包含：<ul>
<li>基类的虚函数指针（可能被重写）</li>
<li>派生类新增的虚函数指针</li>
</ul>
</li>
<li>可能引入<strong>虚基类指针（vbptr）</strong>（如果涉及虚继承）。</li>
</ul>
<p>示例（假设两个基类）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>内存布局（简化）：</p>
<ul>
<li><code>C</code> 对象包含 <code>A</code> 子对象（vptr_A）、<code>B</code> 子对象（vptr_B）、<code>C</code> 的成员（如果有）</li>
<li><code>vptr_A</code> 指向的虚表包含：<code>A::f</code>（或 <code>C::f</code> 若重写）、<code>C::h</code></li>
<li><code>vptr_B</code> 指向的虚表包含：<code>B::g</code>（或 <code>C::g</code> 若重写）、以及可能的调整信息（thunk）</li>
</ul>
<hr>
<h3 id="4️⃣-若基类构造函数里调用自身被派生类重写的虚函数，最终调到哪里？"><a href="#4️⃣-若基类构造函数里调用自身被派生类重写的虚函数，最终调到哪里？" class="headerlink" title="4️⃣ 若基类构造函数里调用自身被派生类重写的虚函数，最终调到哪里？"></a>4️⃣ 若基类构造函数里调用自身被派生类重写的虚函数，最终调到哪里？</h3><ul>
<li>调用的是<strong>基类自己的版本</strong>（不是派生类的重写版本）。</li>
<li>原因：在基类构造期间，派生类尚未构造完成，虚表指针指向基类的虚表（动态类型是基类）。</li>
</ul>
<hr>
<h3 id="5️⃣-虚函数调用相比普通函数有哪些性能开销？"><a href="#5️⃣-虚函数调用相比普通函数有哪些性能开销？" class="headerlink" title="5️⃣ 虚函数调用相比普通函数有哪些性能开销？"></a>5️⃣ 虚函数调用相比普通函数有哪些性能开销？</h3><ul>
<li><strong>间接调用</strong>：通过 vptr 找到虚表，再通过偏移找到函数地址（多一次指针解引用）。</li>
<li><strong>无法内联</strong>：通常编译器无法内联虚函数（除非 devirtualization 优化）。</li>
<li><strong>缓存不友好</strong>：虚表访问可能导致缓存未命中（尤其是跨多态层次调用）。</li>
</ul>
<hr>
<h3 id="6️⃣-讲一下-C-11-的右值引用。"><a href="#6️⃣-讲一下-C-11-的右值引用。" class="headerlink" title="6️⃣ 讲一下 C++11 的右值引用。"></a>6️⃣ 讲一下 C++11 的右值引用。</h3><ul>
<li>右值引用（<code>T&amp;&amp;</code>）用于标识可移动的临时对象（右值）。</li>
<li>允许高效转移资源（如动态内存、文件句柄），避免深拷贝。</li>
<li>支持移动语义（move semantics）和完美转发（perfect forwarding）。</li>
</ul>
<hr>
<h3 id="7️⃣-右值引用实现移动语义主要用来做什么？"><a href="#7️⃣-右值引用实现移动语义主要用来做什么？" class="headerlink" title="7️⃣ 右值引用实现移动语义主要用来做什么？"></a>7️⃣ 右值引用实现移动语义主要用来做什么？</h3><ul>
<li><strong>避免不必要的拷贝</strong>：将资源（如指针）从临时对象“窃取”到新对象。</li>
<li>典型应用：容器（<code>vector</code>、<code>string</code>）的移动构造&#x2F;赋值、智能指针、<code>std::unique_ptr</code>。</li>
</ul>
<hr>
<h3 id="8️⃣-为什么移动构造函数通常标记为-noexcept？"><a href="#8️⃣-为什么移动构造函数通常标记为-noexcept？" class="headerlink" title="8️⃣ 为什么移动构造函数通常标记为 noexcept？"></a>8️⃣ 为什么移动构造函数通常标记为 noexcept？</h3><ul>
<li>保证移动操作不会抛出异常，允许标准库在异常安全时使用移动（如 <code>vector</code> 扩容）。</li>
<li>若未标记 <code>noexcept</code>，容器可能选择拷贝（以保证强异常安全）。</li>
</ul>
<hr>
<h3 id="9️⃣-std-forward-的作用是什么？"><a href="#9️⃣-std-forward-的作用是什么？" class="headerlink" title="9️⃣ std::forward 的作用是什么？"></a>9️⃣ std::forward 的作用是什么？</h3><ul>
<li>用于<strong>完美转发</strong>（perfect forwarding），保持参数的值类别（左值&#x2F;右值）。</li>
<li>在模板中转发参数时，避免不必要的拷贝或丢失右值属性。</li>
<li>通常与通用引用（<code>T&amp;&amp;</code>）配合使用。</li>
</ul>
<hr>
<h3 id="🔟-解释一下-RAII。"><a href="#🔟-解释一下-RAII。" class="headerlink" title="🔟 解释一下 RAII。"></a>🔟 解释一下 RAII。</h3><ul>
<li><strong>资源获取即初始化</strong>（Resource Acquisition Is Initialization）：<ul>
<li>在构造函数中获取资源（如内存、文件、锁）。</li>
<li>在析构函数中释放资源。</li>
</ul>
</li>
<li>确保资源不被泄露（即使发生异常）。</li>
</ul>
<hr>
<h3 id="1️⃣1️⃣-RAII-与异常处理机制如何配合？"><a href="#1️⃣1️⃣-RAII-与异常处理机制如何配合？" class="headerlink" title="1️⃣1️⃣ RAII 与异常处理机制如何配合？"></a>1️⃣1️⃣ RAII 与异常处理机制如何配合？</h3><ul>
<li>析构函数会在栈展开（stack unwinding）过程中被调用，确保资源释放。</li>
<li>例如：<code>std::lock_guard</code> 在异常时自动释放锁；智能指针自动释放内存。</li>
</ul>
<hr>
<h3 id="1️⃣2️⃣-了解-C-的异常安全吗？"><a href="#1️⃣2️⃣-了解-C-的异常安全吗？" class="headerlink" title="1️⃣2️⃣ 了解 C++ 的异常安全吗？"></a>1️⃣2️⃣ 了解 C++ 的异常安全吗？</h3><ul>
<li>四个级别（由 Herb Sutter 提出）：<ol>
<li><strong>无保证</strong>（No guarantee）：可能泄露资源或破坏状态。</li>
<li><strong>基本保证</strong>（Basic guarantee）：不发生泄露，状态有效（但不一定原始状态）。</li>
<li><strong>强保证</strong>（Strong guarantee）：操作成功或状态回滚（如事务）。</li>
<li><strong>不抛保证</strong>（Nothrow guarantee）：承诺不抛出异常。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="1️⃣3️⃣-std-shared-ptr-管理动态数组时如何正确释放？"><a href="#1️⃣3️⃣-std-shared-ptr-管理动态数组时如何正确释放？" class="headerlink" title="1️⃣3️⃣ std::shared_ptr 管理动态数组时如何正确释放？"></a>1️⃣3️⃣ std::shared_ptr 管理动态数组时如何正确释放？</h3><ul>
<li>默认的 <code>delete</code> 不支持数组，需提供自定义删除器：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line"><span class="comment">// C++17 起支持 shared_ptr&lt;T[]&gt;（但需手动指定删除器或使用 std::make_shared 的数组形式）</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1️⃣4️⃣-dynamic-cast-与-static-cast-有什么区别？"><a href="#1️⃣4️⃣-dynamic-cast-与-static-cast-有什么区别？" class="headerlink" title="1️⃣4️⃣ dynamic_cast 与 static_cast 有什么区别？"></a>1️⃣4️⃣ dynamic_cast 与 static_cast 有什么区别？</h3><ul>
<li><code>dynamic_cast</code>：<ul>
<li>用于多态类型（含虚函数），在运行时检查转换安全性。</li>
<li>失败返回 <code>nullptr</code>（指针）或抛出异常（引用）。</li>
</ul>
</li>
<li><code>static_cast</code>：<ul>
<li>编译时转换，不进行运行时检查（可能不安全）。</li>
<li>可用于非多态类型、数值转换、向上&#x2F;向下转换（但向下转换不安全）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1️⃣5️⃣-设计模式了解吗？"><a href="#1️⃣5️⃣-设计模式了解吗？" class="headerlink" title="1️⃣5️⃣ 设计模式了解吗？"></a>1️⃣5️⃣ 设计模式了解吗？</h3><ul>
<li>是，设计模式是解决常见软件设计问题的可重用方案（如单例、工厂、观察者等）。</li>
</ul>
<hr>
<h3 id="1️⃣6️⃣-设计模式的-SOLID-原则清楚吗？"><a href="#1️⃣6️⃣-设计模式的-SOLID-原则清楚吗？" class="headerlink" title="1️⃣6️⃣ 设计模式的 SOLID 原则清楚吗？"></a>1️⃣6️⃣ 设计模式的 SOLID 原则清楚吗？</h3><ul>
<li><strong>S</strong>：单一职责原则（一个类只负责一个功能）。</li>
<li><strong>O</strong>：开闭原则（对扩展开放，对修改关闭）。</li>
<li><strong>L</strong>：里氏替换原则（子类应能替换基类）。</li>
<li><strong>I</strong>：接口隔离原则（多个专用接口优于一个通用接口）。</li>
<li><strong>D</strong>：依赖倒置原则（依赖抽象而非具体实现）。</li>
</ul>
<hr>
<h3 id="1️⃣7️⃣-STL-的-allocator-干什么用？"><a href="#1️⃣7️⃣-STL-的-allocator-干什么用？" class="headerlink" title="1️⃣7️⃣ STL 的 allocator 干什么用？"></a>1️⃣7️⃣ STL 的 allocator 干什么用？</h3><ul>
<li>用于管理内存分配和释放，实现与容器解耦。</li>
<li>允许自定义内存分配策略（如池分配器、共享内存分配器）。</li>
</ul>
<hr>
<h3 id="1️⃣8️⃣-vector-的动态扩容机制是怎样的？"><a href="#1️⃣8️⃣-vector-的动态扩容机制是怎样的？" class="headerlink" title="1️⃣8️⃣ vector 的动态扩容机制是怎样的？"></a>1️⃣8️⃣ vector 的动态扩容机制是怎样的？</h3><ul>
<li>当 <code>size() == capacity()</code> 时，插入新元素会触发扩容：<ul>
<li>分配新内存（通常为原大小的 2 倍或 1.5 倍，取决于实现）。</li>
<li>将旧元素移动或拷贝到新内存。</li>
<li>释放旧内存。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1️⃣9️⃣-vector-扩容后如何决定使用-move-还是-copy？"><a href="#1️⃣9️⃣-vector-扩容后如何决定使用-move-还是-copy？" class="headerlink" title="1️⃣9️⃣ vector 扩容后如何决定使用 move 还是 copy？"></a>1️⃣9️⃣ vector 扩容后如何决定使用 move 还是 copy？</h3><ul>
<li>如果元素类型具有 <code>noexcept</code> 移动构造函数，则使用移动（否则可能拷贝以保证强异常安全）。</li>
<li>可通过 <code>std::move_if_noexcept</code> 判断。</li>
</ul>
<hr>
<h3 id="2️⃣0️⃣-SFINAE-知道吗？"><a href="#2️⃣0️⃣-SFINAE-知道吗？" class="headerlink" title="2️⃣0️⃣ SFINAE 知道吗？"></a>2️⃣0️⃣ SFINAE 知道吗？</h3><ul>
<li><strong>替换失败不是错误</strong>（Substitution Failure Is Not An Error）：<ul>
<li>在模板重载解析时，如果替换模板参数失败，则跳过该候选，而不是报错。</li>
<li>用于 enable&#x2F;disable 模板重载（常与 <code>std::enable_if</code> 配合）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2️⃣1️⃣-std-shared-ptr-的控制块通常有哪些数据成员？"><a href="#2️⃣1️⃣-std-shared-ptr-的控制块通常有哪些数据成员？" class="headerlink" title="2️⃣1️⃣ std::shared_ptr 的控制块通常有哪些数据成员？"></a>2️⃣1️⃣ std::shared_ptr 的控制块通常有哪些数据成员？</h3><ul>
<li><strong>引用计数</strong>（use_count）：共享所有权计数。</li>
<li><strong>弱引用计数</strong>（weak_count）：弱引用计数（用于 <code>weak_ptr</code>）。</li>
<li><strong>删除器</strong>（deleter）：自定义释放函数。</li>
<li><strong>分配器</strong>（allocator）：用于分配控制块和内存（可选）。</li>
</ul>
<hr>
<h3 id="2️⃣2️⃣-原子引用计数如何实现？"><a href="#2️⃣2️⃣-原子引用计数如何实现？" class="headerlink" title="2️⃣2️⃣ 原子引用计数如何实现？"></a>2️⃣2️⃣ 原子引用计数如何实现？</h3><ul>
<li>使用原子操作（如 <code>std::atomic&lt;int&gt;</code>）确保线程安全。</li>
<li>操作（递增&#x2F;递减）使用原子指令（如 <code>fetch_add</code>、<code>compare_exchange_strong</code>）。</li>
</ul>
<hr>
<h3 id="2️⃣3️⃣-原子引用计数存放于何处？"><a href="#2️⃣3️⃣-原子引用计数存放于何处？" class="headerlink" title="2️⃣3️⃣ 原子引用计数存放于何处？"></a>2️⃣3️⃣ 原子引用计数存放于何处？</h3><ul>
<li>在 <code>std::shared_ptr</code> 的<strong>控制块</strong>（control block）中（动态分配）。</li>
</ul>
<hr>
<h3 id="2️⃣4️⃣-描述一个程序的完整编译过程。"><a href="#2️⃣4️⃣-描述一个程序的完整编译过程。" class="headerlink" title="2️⃣4️⃣ 描述一个程序的完整编译过程。"></a>2️⃣4️⃣ 描述一个程序的完整编译过程。</h3><ol>
<li><strong>预处理</strong>：处理宏、头文件包含等（生成 <code>.i</code> 文件）。</li>
<li><strong>编译</strong>：词法分析、语法分析、语义分析、优化，生成汇编代码（<code>.s</code>）。</li>
<li><strong>汇编</strong>：将汇编代码转换为机器码（目标文件 <code>.o</code>）。</li>
<li><strong>链接</strong>：合并目标文件和库，解析符号引用（生成可执行文件）。</li>
</ol>
<hr>
<h3 id="2️⃣5️⃣-动态链接的大致过程？"><a href="#2️⃣5️⃣-动态链接的大致过程？" class="headerlink" title="2️⃣5️⃣ 动态链接的大致过程？"></a>2️⃣5️⃣ 动态链接的大致过程？</h3><ul>
<li>程序运行时由动态链接器（如 <code>ld-linux.so</code>）加载共享库（<code>.so</code>&#x2F;<code>.dll</code>）。</li>
<li>步骤：<ol>
<li>查找共享库（在标准路径或 <code>LD_LIBRARY_PATH</code>）。</li>
<li>映射库到进程地址空间。</li>
<li>重定位符号地址。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2️⃣6️⃣-动态链接的重定位过程？"><a href="#2️⃣6️⃣-动态链接的重定位过程？" class="headerlink" title="2️⃣6️⃣ 动态链接的重定位过程？"></a>2️⃣6️⃣ 动态链接的重定位过程？</h3><ul>
<li><strong>重定位</strong>：修改代码中的符号引用（如函数、变量），使其指向正确的地址。</li>
<li>使用 <strong>PLT（过程链接表）</strong> 和 <strong>GOT（全局偏移表）</strong> 实现延迟绑定（lazy binding）。</li>
</ul>
<hr>
<h3 id="2️⃣7️⃣-ELF-文件结构是怎样的？"><a href="#2️⃣7️⃣-ELF-文件结构是怎样的？" class="headerlink" title="2️⃣7️⃣ ELF 文件结构是怎样的？"></a>2️⃣7️⃣ ELF 文件结构是怎样的？</h3><ul>
<li><strong>ELF 头</strong>：标识文件类型、架构等。</li>
<li><strong>节区（Sections）</strong>：存储代码、数据（如 <code>.text</code>、<code>.data</code>、<code>.bss</code>、<code>.rodata</code>）。</li>
<li><strong>段（Segments）</strong>：用于加载（如可加载的代码段、数据段）。</li>
<li><strong>符号表</strong>、<strong>重定位表</strong>等。</li>
</ul>
<hr>
<h3 id="2️⃣8️⃣-BSS-段的作用？"><a href="#2️⃣8️⃣-BSS-段的作用？" class="headerlink" title="2️⃣8️⃣ BSS 段的作用？"></a>2️⃣8️⃣ BSS 段的作用？</h3><ul>
<li>存储<strong>未初始化</strong>的全局变量和静态变量（实际不占文件空间，运行时初始化为0）。</li>
</ul>
<hr>
<h3 id="2️⃣9️⃣-操作系统如何把-ELF-文件加载成进程？"><a href="#2️⃣9️⃣-操作系统如何把-ELF-文件加载成进程？" class="headerlink" title="2️⃣9️⃣ 操作系统如何把 ELF 文件加载成进程？"></a>2️⃣9️⃣ 操作系统如何把 ELF 文件加载成进程？</h3><ol>
<li>解析 ELF 头，检查有效性。</li>
<li>映射段到内存（代码段只读，数据段可写）。</li>
<li>初始化 BSS 段为0。</li>
<li>设置堆栈。</li>
<li>动态链接（如果需要）。</li>
<li>跳转到入口点（如 <code>_start</code>）。</li>
</ol>
<hr>
<h3 id="3️⃣0️⃣-系统调用时参数如何传递并进入内核？"><a href="#3️⃣0️⃣-系统调用时参数如何传递并进入内核？" class="headerlink" title="3️⃣0️⃣ 系统调用时参数如何传递并进入内核？"></a>3️⃣0️⃣ 系统调用时参数如何传递并进入内核？</h3><ul>
<li><strong>x86-64</strong>：通过寄存器（<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>r10</code>、<code>r8</code>、<code>r9</code>）传递参数，使用 <code>syscall</code> 指令。</li>
<li><strong>x86</strong>：通过寄存器传递，使用 <code>int 0x80</code> 或 <code>sysenter</code>。</li>
<li>内核态切换：CPU 切换到特权模式，跳转到系统调用处理函数。</li>
</ul>
<hr>
<h3 id="3️⃣1️⃣-用户态传递大-buffer-时内核如何处理？"><a href="#3️⃣1️⃣-用户态传递大-buffer-时内核如何处理？" class="headerlink" title="3️⃣1️⃣ 用户态传递大 buffer 时内核如何处理？"></a>3️⃣1️⃣ 用户态传递大 buffer 时内核如何处理？</h3><ul>
<li>通过指针传递（用户空间地址），内核需要验证地址合法性并拷贝数据（如 <code>copy_from_user</code>）。</li>
<li>避免直接访问用户空间（防止内核崩溃或安全漏洞）。</li>
</ul>
<hr>
<h3 id="3️⃣2️⃣-为什么操作系统使用多级页表管理虚拟内存？"><a href="#3️⃣2️⃣-为什么操作系统使用多级页表管理虚拟内存？" class="headerlink" title="3️⃣2️⃣ 为什么操作系统使用多级页表管理虚拟内存？"></a>3️⃣2️⃣ 为什么操作系统使用多级页表管理虚拟内存？</h3><ul>
<li>节省内存：多级页表仅分配实际使用的部分（稀疏地址空间），而不像单级页表需要连续完整映射。</li>
</ul>
<hr>
<h3 id="3️⃣3️⃣-多级页表如何进行地址映射？"><a href="#3️⃣3️⃣-多级页表如何进行地址映射？" class="headerlink" title="3️⃣3️⃣ 多级页表如何进行地址映射？"></a>3️⃣3️⃣ 多级页表如何进行地址映射？</h3><ul>
<li>虚拟地址分割为多个索引（如四级页表：PML4、PDP、PD、PT），逐级查表得到物理地址。</li>
<li>每级页表项（PTE）存储下一级页表的物理地址或最终页框地址。</li>
</ul>
<hr>
<h3 id="3️⃣4️⃣-发生缺页中断时操作系统会做哪些事？"><a href="#3️⃣4️⃣-发生缺页中断时操作系统会做哪些事？" class="headerlink" title="3️⃣4️⃣ 发生缺页中断时操作系统会做哪些事？"></a>3️⃣4️⃣ 发生缺页中断时操作系统会做哪些事？</h3><ol>
<li>检查访问是否合法（地址是否在进程空间）。</li>
<li>分配物理页帧（可能需换出其他页）。</li>
<li>从磁盘（如交换区或文件）读取数据到物理页。</li>
<li>更新页表。</li>
<li>重新执行触发缺页的指令。</li>
</ol>
<hr>
<h3 id="3️⃣5️⃣-操作系统如何管理堆内存？"><a href="#3️⃣5️⃣-操作系统如何管理堆内存？" class="headerlink" title="3️⃣5️⃣ 操作系统如何管理堆内存？"></a>3️⃣5️⃣ 操作系统如何管理堆内存？</h3><ul>
<li>通过 <strong>brk</strong> 和 <strong>mmap</strong> 系统调用扩展堆空间。</li>
<li>使用内存分配器（如 glibc 的 malloc）管理空闲块（链表或树结构），处理分配和释放。</li>
</ul>
<hr>
<h3 id="3️⃣6️⃣-操作系统如何实现互斥锁？"><a href="#3️⃣6️⃣-操作系统如何实现互斥锁？" class="headerlink" title="3️⃣6️⃣ 操作系统如何实现互斥锁？"></a>3️⃣6️⃣ 操作系统如何实现互斥锁？</h3><ul>
<li>原子指令（如 CAS）实现用户态锁（如自旋锁）。</li>
<li>系统调用（如 <code>futex</code>）在竞争时使线程睡眠，避免忙等待。</li>
</ul>
<hr>
<h3 id="3️⃣7️⃣-如何避免死锁？"><a href="#3️⃣7️⃣-如何避免死锁？" class="headerlink" title="3️⃣7️⃣ 如何避免死锁？"></a>3️⃣7️⃣ 如何避免死锁？</h3><ul>
<li>破坏死锁条件：<ul>
<li>互斥：无法避免。</li>
<li>持有并等待：一次性获取所有资源。</li>
<li>不可抢占：允许抢占资源。</li>
<li>循环等待：按顺序申请资源（资源排序）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3️⃣8️⃣-死锁已发生时如何定位？"><a href="#3️⃣8️⃣-死锁已发生时如何定位？" class="headerlink" title="3️⃣8️⃣ 死锁已发生时如何定位？"></a>3️⃣8️⃣ 死锁已发生时如何定位？</h3><ul>
<li>工具：<code>pstack</code>、<code>gdb</code> 查看线程堆栈，分析锁的持有和等待关系。</li>
<li>日志：记录锁获取顺序。</li>
</ul>
<hr>
<h3 id="3️⃣9️⃣-了解-AddressSanitizer-的实现原理吗？"><a href="#3️⃣9️⃣-了解-AddressSanitizer-的实现原理吗？" class="headerlink" title="3️⃣9️⃣ 了解 AddressSanitizer 的实现原理吗？"></a>3️⃣9️⃣ 了解 AddressSanitizer 的实现原理吗？</h3><ul>
<li>通过编译时插桩和影子内存（shadow memory）检测内存错误（如越界、use-after-free）。</li>
<li>每 8 字节应用内存对应 1 字节影子内存，标识可访问性。</li>
</ul>
<hr>
<h3 id="4️⃣0️⃣-计算机网络的五层协议有哪些？"><a href="#4️⃣0️⃣-计算机网络的五层协议有哪些？" class="headerlink" title="4️⃣0️⃣ 计算机网络的五层协议有哪些？"></a>4️⃣0️⃣ 计算机网络的五层协议有哪些？</h3><ol>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层（IP）</li>
<li>传输层（TCP&#x2F;UDP）</li>
<li>应用层（HTTP&#x2F;FTP等）</li>
</ol>
<hr>
<h3 id="4️⃣1️⃣-ping-命令工作在哪一层？"><a href="#4️⃣1️⃣-ping-命令工作在哪一层？" class="headerlink" title="4️⃣1️⃣ ping 命令工作在哪一层？"></a>4️⃣1️⃣ ping 命令工作在哪一层？</h3><ul>
<li>网络层（使用 ICMP 协议）。</li>
</ul>
<hr>
<h3 id="4️⃣2️⃣-IP-协议头部有哪些字段？"><a href="#4️⃣2️⃣-IP-协议头部有哪些字段？" class="headerlink" title="4️⃣2️⃣ IP 协议头部有哪些字段？"></a>4️⃣2️⃣ IP 协议头部有哪些字段？</h3><ul>
<li>版本、头部长度、服务类型、总长度、标识、分片偏移、生存时间（TTL）、协议、校验和、源&#x2F;目的IP地址等。</li>
</ul>
<hr>
<h3 id="4️⃣3️⃣-TCP-三次握手过程？"><a href="#4️⃣3️⃣-TCP-三次握手过程？" class="headerlink" title="4️⃣3️⃣ TCP 三次握手过程？"></a>4️⃣3️⃣ TCP 三次握手过程？</h3><ol>
<li>Client → Server：SYN（seq&#x3D;x）</li>
<li>Server → Client：SYN-ACK（seq&#x3D;y, ack&#x3D;x+1）</li>
<li>Client → Server：ACK（seq&#x3D;x+1, ack&#x3D;y+1）</li>
</ol>
<hr>
<h3 id="4️⃣4️⃣-为什么握手三次、挥手四次？"><a href="#4️⃣4️⃣-为什么握手三次、挥手四次？" class="headerlink" title="4️⃣4️⃣ 为什么握手三次、挥手四次？"></a>4️⃣4️⃣ 为什么握手三次、挥手四次？</h3><ul>
<li><strong>握手三次</strong>：确保双方收发能力正常（最少三次）。</li>
<li><strong>挥手四次</strong>：因为 TCP 半关闭（一方发送 FIN 后仍可接收数据），需分别关闭读写方向。</li>
</ul>
<hr>
<h3 id="4️⃣5️⃣-描述-CMakeLists-txt-的基本结构。"><a href="#4️⃣5️⃣-描述-CMakeLists-txt-的基本结构。" class="headerlink" title="4️⃣5️⃣ 描述 CMakeLists.txt 的基本结构。"></a>4️⃣5️⃣ 描述 CMakeLists.txt 的基本结构。</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app PRIVATE some_lib)</span><br></pre></td></tr></table></figure>

<hr>
<p>如有进一步探讨需求，可随时提出。</p>
<h2 id="心影随行C-一面"><a href="#心影随行C-一面" class="headerlink" title="心影随行C++一面"></a>心影随行C++一面</h2><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><span style="font-size:1.1em;">volatile关键字</span></h3><p>好的，我们来详细、深入地探讨一下 <code>volatile</code> 关键字。这是一个非常重要但又容易被误解的关键字，尤其是在涉及多线程编程时。</p>
<h4 id="核心思想：为什么需要-volatile？"><a href="#核心思想：为什么需要-volatile？" class="headerlink" title="核心思想：为什么需要 volatile？"></a>核心思想：为什么需要 <code>volatile</code>？</h4><p><code>volatile</code> 的根本作用是<strong>禁止编译器进行某些激进的优化</strong>。这些优化在操作普通内存时是安全且有效的，但在操作“特殊内存”时会导致程序行为错误。</p>
<p>所谓“特殊内存”，指的是其值可能被程序本身之外的代理改变的内存。例如：</p>
<ol>
<li><strong>内存映射的硬件寄存器</strong>：例如，一个指向硬件状态的指针。硬件可以随时改变这个状态，而编译器并不知道。</li>
<li><strong>被中断服务程序修改的变量</strong>：在主程序流程中，一个变量可能被中断服务程序（ISR）修改。</li>
<li><strong>被另一个线程修改的变量</strong>（注意：这是常见的误解，我们后面会详细说）。</li>
</ol>
<p>如果没有 <code>volatile</code>，编译器会基于它对程序流的理解来进行优化，它假设程序是唯一能改变内存中值的实体。</p>
<h4 id="volatile-到底做了什么？"><a href="#volatile-到底做了什么？" class="headerlink" title="volatile 到底做了什么？"></a><code>volatile</code> 到底做了什么？</h4><p>当你将一个变量声明为 <code>volatile</code> 后，你是在给编译器一个强烈的提示：“这个变量的值可能会以编译器无法察觉的方式突然改变”。</p>
<p>具体来说，<code>volatile</code> 关键字确保了两点：</p>
<ol>
<li><p><strong>禁止编译器优化掉读写操作</strong>：</p>
<ul>
<li><strong>无优化</strong>：对于普通变量，如果编译器发现两次读取该变量之间没有代码修改它，它可能会为了效率而将第二次读取优化掉，直接使用第一次读取时缓存在寄存器中的值。</li>
<li><strong>有 <code>volatile</code></strong>：<strong>每次使用 <code>volatile</code> 变量时，都必须从它的内存地址中重新读取</strong>；<strong>每次赋值给 <code>volatile</code> 变量时，都必须立即写回它的内存地址中</strong>。编译器不能做任何“省略”或“缓存”其值的优化。</li>
</ul>
</li>
<li><p><strong>防止指令重排</strong>（在与硬件交互时尤为重要）：</p>
<ul>
<li>编译器或CPU为了优化性能，可能会在不影响单线程程序逻辑的前提下，对指令的执行顺序进行重排。</li>
<li>对于 <code>volatile</code> 变量的访问，编译器会<strong>在生成的指令序列中插入“内存屏障”，确保所有对 <code>volatile</code> 变量的读写操作之间的顺序不会被重排</strong>。例如，对一个 <code>volatile</code> 变量的写操作一定不会重排到另一个 <code>volatile</code> 变量的读操作之后。</li>
</ul>
</li>
</ol>
<h4 id="经典示例：没有-volatile-导致的错误"><a href="#经典示例：没有-volatile-导致的错误" class="headerlink" title="经典示例：没有 volatile 导致的错误"></a>经典示例：没有 <code>volatile</code> 导致的错误</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 普通变量</span></span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这个循环等待一个中断服务程序将 status 改为 1</span></span><br><span class="line">    <span class="keyword">while</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 空循环，等待 status 变化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Status changed!\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：当你启用编译器优化（如 <code>-O2</code>）时，这个程序很可能会陷入<strong>死循环</strong>。</p>
<p><strong>原因</strong>：<br>编译器在优化时看到 <code>while (status == 0)</code> 循环，它发现循环体内没有任何代码能修改 <code>status</code> 的值。因此，它“聪明地”得出结论：<code>status</code> 永远为 0。于是，它将代码优化成类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov    eax, DWORD PTR [status]  ; 第一次从内存读取 status 到寄存器 eax</span><br><span class="line">.L2:</span><br><span class="line">test   eax, eax                 ; 检查 eax 是否为 0</span><br><span class="line">je     .L2                      ; 如果为0，则跳回 .L2 继续循环</span><br><span class="line">; ... 后续代码</span><br></pre></td></tr></table></figure>

<p>注意，<code>status</code> 的值只被读取了一次并缓存在寄存器 <code>eax</code> 中，之后循环永远检查的是 <code>eax</code>，而不是真正的内存地址。即使中断服务程序修改了内存中 <code>status</code> 的值，这个循环也永远看不到。</p>
<p><strong>解决方案</strong>：使用 <code>volatile</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> status = <span class="number">0</span>; <span class="comment">// 告诉编译器，这个值可能“突然”改变</span></span><br></pre></td></tr></table></figure>

<p>现在，编译器每次判断 <code>status == 0</code> 时，都必须从 <code>status</code> 的真实内存地址重新读取值。生成的汇编代码会像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L2:</span><br><span class="line">mov    eax, DWORD PTR [status] ; 每次循环都从内存读取！</span><br><span class="line">test   eax, eax</span><br><span class="line">je     .L2</span><br><span class="line">; ... 后续代码</span><br></pre></td></tr></table></figure>

<p>这样，当中断服务程序修改 <code>status</code> 后，循环就能正确退出。</p>
<h4 id="volatile-与多线程编程（非常重要！）"><a href="#volatile-与多线程编程（非常重要！）" class="headerlink" title="volatile 与多线程编程（非常重要！）"></a><code>volatile</code> 与多线程编程（非常重要！）</h4><p>这是一个非常常见的<strong>误区</strong>：<strong>试图用 <code>volatile</code> 来解决多线程数据竞争和可见性问题。</strong></p>
<p><strong>结论：<code>volatile</code> 不适用于多线程同步。</strong></p>
<p><strong>为什么？</strong></p>
<ol>
<li><p><strong>原子性（Atomicity）</strong>：</p>
<ul>
<li><code>volatile</code> <strong>不保证操作的原子性</strong>。像 <code>x++</code> 这样的操作（读-改-写），即使 <code>x</code> 是 <code>volatile</code>，在多线程下仍然是一个非原子操作，会导致数据竞争。</li>
<li>正确的工具是：<strong>原子类型（<code>std::atomic</code>）</strong> 或 <strong>互斥锁（<code>std::mutex</code>）</strong>。</li>
</ul>
</li>
<li><p><strong>顺序性（Ordering）</strong>：</p>
<ul>
<li><code>volatile</code> 防止了编译器重排，但<strong>不足以防止现代CPU的运行时指令重排</strong>（内存重排）。</li>
<li><code>std::atomic</code> 提供了严格的内存顺序控制（如 <code>memory_order_seq_cst</code>），可以防止CPU级别的重排，从而确保一个线程的写操作能被另一个线程以正确的顺序观察到。</li>
</ul>
</li>
<li><p><strong>可见性（Visibility）</strong>：</p>
<ul>
<li>这是 <code>volatile</code> 唯一能部分提供的属性（确保每次从内存读，每次写回内存）。</li>
<li>然而，在现代多核CPU架构中，由于每个核心可能有自己的缓存，一个线程的写操作即使写回了主内存，其他线程的缓存也可能不会立即失效并更新。这需要<strong>内存屏障</strong>指令来保证。</li>
<li><code>std::atomic</code> 在执行操作时会插入适当的内存屏障，确保修改对其他线程立即可见。而 <code>volatile</code> 在C&#x2F;C++标准中<strong>并不要求</strong>生成内存屏障。</li>
</ul>
</li>
</ol>
<p><strong>简单比喻</strong>：</p>
<ul>
<li><code>volatile</code>：像是说“别偷懒，每次都要去黑板上看最新通知，别用你笔记本上记的旧内容”。</li>
<li><code>std::atomic</code> 或 <code>mutex</code>：像是不仅要求大家看黑板，还安排了一个老师（锁&#x2F;内存屏障）来协调大家看通知的顺序，防止拥挤和混乱（数据竞争）。</li>
</ul>
<p><strong>因此，在多线程中，应该使用 <code>std::atomic&lt;bool&gt;</code> 或 <code>std::mutex</code>，而不是 <code>volatile bool</code>。</strong></p>
<h4 id="volatile-的正确使用场景"><a href="#volatile-的正确使用场景" class="headerlink" title="volatile 的正确使用场景"></a><code>volatile</code> 的正确使用场景</h4><ol>
<li><p><strong>内存映射I&#x2F;O（Memory-mapped I&#x2F;O）</strong>：<br>这是 <code>volatile</code> 最经典的使用场景。操作硬件时，你会将指针指向一个特定的硬件地址，通过读写这个地址来与控制寄存器或数据缓冲区进行交互。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> *<span class="type">const</span> hardware_reg = (<span class="type">uint32_t</span>*)<span class="number">0xFEEDBEEF</span>;</span><br><span class="line">*hardware_reg = <span class="number">0x1</span>; <span class="comment">// 发送一个命令给硬件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>被信号处理程序修改的变量</strong>：<br>在主程序中，一个变量可能会被一个信号处理函数异步地修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> signal_received = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    signal_received = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGINT, signal_handler);</span><br><span class="line">    <span class="keyword">while</span> (!signal_received) &#123; <span class="comment">// 必须 volatile 以确保检查最新值</span></span><br><span class="line">        <span class="comment">// 正常工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal, exiting...\\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在裸机嵌入式系统中的全局变量</strong>：<br>在没有任何操作系统的嵌入式系统中，如果存在一个主循环和一个中断服务程序共享的全局变量，这个变量必须声明为 <code>volatile</code>。</p>
</li>
</ol>
<h3 id="C-与-Java-C-中-volatile-的区别"><a href="#C-与-Java-C-中-volatile-的区别" class="headerlink" title="C++ 与 Java&#x2F;C# 中 volatile 的区别"></a>C++ 与 Java&#x2F;C# 中 <code>volatile</code> 的区别</h3><p>请注意，这个区别非常重要：</p>
<ul>
<li><strong>在 Java 和 C# 中</strong>：<code>volatile</code> 关键字被赋予了更强的语义。它确实能保证变量的可见性和一定的顺序性（禁止指令重排），可以用于简单的无锁多线程编程。它的行为更接近于 C++ 中的 <code>std::atomic</code> 默认内存顺序（顺序一致性）。</li>
<li><strong>在 C 和 C++ 中</strong>：<code>volatile</code> 的语义要弱得多，如前所述，它只与编译器优化和“特殊内存”相关，<strong>与多线程同步无关</strong>。</li>
</ul>
<p><strong>切勿将 Java 中对 <code>volatile</code> 的理解套用到 C++ 中！</strong></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>volatile</code></th>
<th align="left"><code>std::atomic</code> (默认)</th>
<th align="left"><code>std::mutex</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>防止编译器优化</strong></td>
<td align="left"><strong>是</strong></td>
<td align="left">是</td>
<td align="left">是（通过锁的API）</td>
</tr>
<tr>
<td align="left"><strong>保证原子性</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>是</strong>（保护代码块）</td>
</tr>
<tr>
<td align="left"><strong>保证顺序性</strong></td>
<td align="left">有限（仅编译器）</td>
<td align="left"><strong>是</strong>（CPU内存屏障）</td>
<td align="left"><strong>是</strong>（更强的顺序保证）</td>
</tr>
<tr>
<td align="left"><strong>保证可见性</strong></td>
<td align="left">有限（仅编译器）</td>
<td align="left"><strong>是</strong>（CPU缓存一致性）</td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>主要用途</strong></td>
<td align="left">内存映射IO、信号处理</td>
<td align="left">无锁多线程编程</td>
<td align="left">保护临界区</td>
</tr>
</tbody></table>
<p><strong>核心建议</strong>：</p>
<ul>
<li>当你操作<strong>硬件寄存器</strong>或<strong>被异步修改（如中断）的变量</strong>时，使用 <code>volatile</code>。</li>
<li>当你在进行<strong>多线程编程</strong>时，需要共享数据，请使用 <code>std::atomic</code>（对于简单变量）或 <code>std::mutex</code>（对于代码块或复杂数据结构）。<strong>不要使用 <code>volatile</code></strong>。</li>
</ul>
<h2 id="影石一面"><a href="#影石一面" class="headerlink" title="影石一面"></a>影石一面</h2><p>好的，这是一份对这些经典C++和计算机基础面试题的详细解答，旨在帮助您准备面试。</p>
<hr>
<h3 id="C-核心"><a href="#C-核心" class="headerlink" title="C++ 核心"></a>C++ 核心</h3><p><strong>1. C++类的大小由什么决定？</strong></p>
<ul>
<li><strong>非静态成员变量</strong>：所有非静态数据成员的大小之和。遵循内存对齐规则。</li>
<li><strong>内存对齐（Padding）</strong>：编译器为了提升访问效率，会在成员之间或末尾插入空白字节，确保成员在自然边界上对齐。</li>
<li><strong>虚函数（vptr）</strong>：如果类包含虚函数（或继承自有虚函数的类），则会有一个指向虚函数表（vtable）的指针（vptr）。在64位系统上通常占8字节。</li>
<li><strong>继承</strong>：基类的非静态成员也会成为派生类的一部分，影响其大小。</li>
<li><em>注意</em>：静态成员变量、成员函数、普通函数都不占用类实例的大小。</li>
</ul>
<p><strong>2. 单继承下虚函数表数量？多继承为什么会有多个虚函数表及对应表头指针？</strong></p>
<ul>
<li><strong>单继承</strong>：通常只有一个虚函数表（vtable）。派生类和基类共享一个vtable，派生类的新虚函数会追加到这个vtable的末尾。</li>
<li><strong>多继承</strong>：<ul>
<li>派生类会拥有<strong>多个虚函数表</strong>，每个直接基类对应一个（如果该基类有虚函数）。</li>
<li><strong>原因</strong>：为了满足不同基类指针的动态绑定。当一个 <code>Derived*</code> 被转换为 <code>Base2*</code> 时，它的地址可能需要调整（<code>this</code>指针偏移）。每个基类对应的vtable中，不仅记录了该视角下可用的虚函数地址，也隐含了进行这种 <code>this</code> 指针偏移的信息。多个vptr（每个位于子对象开始处）可以快速定位到对应的vtable。</li>
</ul>
</li>
</ul>
<p><strong>3. 虚函数相比普通函数的性能开销？</strong></p>
<ul>
<li><strong>间接调用开销</strong>：需要通过vptr找到vtable，再通过vtable中的偏移找到函数地址，比直接调用多两次内存访问。</li>
<li><strong>编译器优化障碍</strong>：虚函数通常是运行时绑定（动态多态），阻碍了内联、过程间优化等编译期优化。</li>
<li><strong>缓存不友好</strong>：vtable和函数代码可能不在缓存中，导致缓存缺失（Cache Miss）。但vptr本身通常在缓存中。</li>
<li><em>注意</em>：在绝对性能要求极高的场景（如硬件驱动、高频交易核心循环）需谨慎使用，但在大多数应用场景下，这点开销是值得的，它带来了设计的灵活性。</li>
</ul>
<p><strong>4. 虚函数重写的时机？</strong></p>
<ul>
<li><strong>时机</strong>：发生在运行时（Runtime）。当通过基类的指针或引用调用虚函数时，具体调用哪个版本的函数（基类还是派生类）取决于指针或引用所指向的对象的实际类型。</li>
</ul>
<p><strong>5. 什么是右值引用？</strong></p>
<ul>
<li><strong>定义</strong>：右值引用（<code>T&amp;&amp;</code>）是C++11引入的一种引用类型，它专门用于绑定到<strong>即将被销毁&#x2F;临时的对象</strong>（右值）。</li>
<li><strong>目的</strong>：支持移动语义（Move Semantics）和完美转发（Perfect Forwarding），从而避免不必要的深拷贝，提升性能。</li>
</ul>
<p><strong>6. move 的操作过程？</strong></p>
<ul>
<li><code>std::move()</code> 本质上是一个<strong>静态转换</strong>，它不做任何实际的移动操作。</li>
<li><strong>过程</strong>：<code>std::move(x)</code> 将左值 <code>x</code> 无条件地转换为右值引用（<code>static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t)</code>）。</li>
<li><strong>效果</strong>：转换后，<code>x</code> 被标记为一个“可被移动的”右值。随后，当这个结果被传递给一个接受右值引用参数的函数（如移动构造函数、移动赋值运算符）时，该函数才会真正执行“移动”操作（通常是 pilfering（窃取）资源并将源对象置于有效但未定义的状态）。</li>
</ul>
<p><strong>7. string 类型的移动构造做了哪些事情？</strong></p>
<pre><code>  1. 直接“窃取”源字符串（右值）内部的指针（指向堆上的字符数组）。
  2. 将本对象的内部指针指向这块偷来的内存。
  3. 将源对象的内部指针设置为 `nullptr`（或一个指向空字符串的小缓冲区），使其变为空字符串状态。
  4. 拷贝大小、容量等信息。
</code></pre>
<ul>
<li><strong>结果</strong>：避免了为目标字符串分配新内存和拷贝字符内容的昂贵操作，操作复杂度接近O(1)。</li>
</ul>
<p><strong>8. forward 函数？为什么不用forward会变成左值？</strong></p>
<ul>
<li><strong>完美转发（Perfect Forwarding）</strong>：<code>std::forward&lt;T&gt;(arg)</code> 用于在模板函数中保持参数原有的值类别（左值性或右值性）。</li>
<li><strong>为什么不用会变左值</strong>：在模板函数内部，所有具名的参数（包括右值引用参数，如 <code>T&amp;&amp; t</code>）本身都是<strong>左值</strong>（因为它们有名字，可以取地址）。如果直接将这个左值 <code>t</code> 传递给另一个函数，它永远会被当作左值处理，无法触发接收函数的移动语义版本。<code>std::forward</code> 会根据模板参数 <code>T</code> 的推导结果，有条件地将 <code>t</code> 转换回它原始的值类别（如果是用右值初始化的，就转回右值），从而实现“完美”转发。</li>
</ul>
<p><strong>9. C++ 的 RAII 机制核心是什么？</strong></p>
<ul>
<li><strong>核心思想</strong>：将<strong>资源</strong>（内存、文件句柄、锁、套接字等）的<strong>生命周期</strong>与<strong>对象的生命周期</strong>相绑定。</li>
<li><strong>具体实现</strong>：在<strong>构造函数</strong>中获取资源，在<strong>析构函数</strong>中释放资源。这样，只要对象超出作用域（无论是正常离开还是因异常离开），其析构函数就会被自动调用，从而确保资源被安全释放。</li>
</ul>
<p><strong>10. RAII 如何配合异常处理的流程？</strong><br>    - RAII是C++中处理异常安全性的基石。<br>    - 当异常被抛出时，会发生<strong>栈展开（Stack Unwinding）</strong>：当前作用域内已构造的局部对象的析构函数会被自动调用。<br>    - 因此，即使函数因异常而提前退出，RAII对象（如 <code>std::lock_guard</code>, <code>std::unique_ptr</code>, <code>std::ifstream</code>）也会被正常销毁，它们所管理的资源会被自动释放，从而避免了资源泄漏。</p>
<p><strong>11. dynamic_cast、static_cast 的区别？</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>static_cast</code></th>
<th align="left"><code>dynamic_cast</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>时间</strong></td>
<td align="left">编译期</td>
<td align="left">运行时</td>
</tr>
<tr>
<td align="left"><strong>检查</strong></td>
<td align="left">无运行时检查，不安全</td>
<td align="left">有运行时类型检查（RTTI），安全</td>
</tr>
<tr>
<td align="left"><strong>开销</strong></td>
<td align="left">无额外开销</td>
<td align="left">有查找RTTI的开销</td>
</tr>
<tr>
<td align="left"><strong>用途</strong></td>
<td align="left">相关类型间的转换（如数值类型、void*、有继承关系的指针**（向下转换不安全）**）</td>
<td align="left">主要用于<strong>沿继承层级的安全向下转换</strong>（Downcasting）</td>
</tr>
<tr>
<td align="left"><strong>失败</strong></td>
<td align="left">不安全转换导致未定义行为</td>
<td align="left">对指针返回<code>nullptr</code>，对引用抛出<code>std::bad_cast</code></td>
</tr>
</tbody></table>
<p><strong>12. 设计模式的原则？</strong></p>
<ul>
<li><strong>SOLID 原则</strong>：<ul>
<li><strong>S</strong>：单一职责原则（Single Responsibility）</li>
<li><strong>O</strong>：开闭原则（Open-Closed）</li>
<li><strong>L</strong>：里氏替换原则（Liskov Substitution）</li>
<li><strong>I</strong>：接口隔离原则（Interface Segregation）</li>
<li><strong>D</strong>：依赖倒置原则（Dependency Inversion）</li>
</ul>
</li>
</ul>
<p><strong>13. 单例模式怎么实现？</strong></p>
<ul>
<li><p><strong>核心</strong>：保证一个类只有一个实例，并提供一个全局访问点。</p>
</li>
<li><p><strong>C++实现要点（懒汉式，C++11线程安全）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// C++11保证局部静态变量初始化是线程安全的</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>; <span class="comment">// 私有化构造函数</span></span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>14. 观察者模式的应用场景？</strong></p>
<ul>
<li><strong>场景</strong>：当一个对象（Subject）的状态变化需要通知其他多个对象（Observers），且这些对象是未知的或动态变化的。</li>
<li><strong>例子</strong>：GUI事件处理（按钮点击通知多个处理器）、发布-订阅系统、模型-视图（MVC）架构中模型通知视图更新。</li>
</ul>
<p><strong>15. 工厂模式的分类及作用？</strong></p>
<ul>
<li><strong>简单工厂</strong>：一个工厂类根据传入的参数不同创建不同的产品对象。不属于GoF 23种设计模式。</li>
<li><strong>工厂方法</strong>：定义一个创建对象的接口，但让子类决定实例化哪一个类。将对象的创建延迟到子类。</li>
<li><strong>抽象工厂</strong>：提供一个接口，用于创建<strong>相关或依赖对象家族</strong>，而不需要指定它们的具体类。</li>
<li><strong>作用</strong>：解耦客户端代码和具体类的创建过程，提高代码的灵活性和可维护性。</li>
</ul>
<hr>
<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p><strong>16. STL 的空间分配器是怎么设计的？</strong></p>
<ul>
<li>STL的 <code>std::allocator</code> 在现代C++中主要是一个薄包装，底层通常调用 <code>::operator new</code> 和 <code>::operator delete</code>。</li>
<li>但STL容器的设计允许用户<strong>自定义分配器</strong>。为了效率，SGI STL等实现设计了<strong>两级分配器</strong>：<ul>
<li><strong>第一级</strong>：直接使用 <code>malloc</code> 和 <code>free</code>，处理大块内存请求。</li>
<li><strong>第二级</strong>：使用<strong>内存池</strong>和<strong>自由链表</strong>来管理小块内存，避免频繁向系统申请释放内存，减少内存碎片，提升小对象分配效率。</li>
</ul>
</li>
</ul>
<p><strong>17. STL 是怎么调用 allocator 的？（如 vector<string> 的构造过程）</strong></p>
<pre><code>  1. `vector` 模板类内部会 typedef 其分配器类型 `using allocator_type = Allocator;`。
  2. `vector` 内部持有一个分配器成员和一个指向动态数组的指针。
  3. 当 `vector` 需要分配内存时（如在构造函数或 `resize` 时），它会通过 `std::allocator_traits&lt;Allocator&gt;::allocate(allocator, n)` 来请求分配 `n * sizeof(T)` 字节的内存。
  4. 在分配的内存上构造对象时，会调用 `std::allocator_traits&lt;Allocator&gt;::construct(allocator, p, args...)`，这通常会使用 **placement new** 在地址 `p` 上以 `args` 为参数构造一个 `T` 类型的对象。
  5. 析构时，先调用 `destroy` 销毁对象，再调用 `deallocate` 释放内存。
</code></pre>
<p><strong>18. vector 扩容过程？</strong></p>
<pre><code>  1. 当 `push_back` 等操作导致 `size() == capacity()` 时，`vector` 需要扩容。
  2. 分配一块新的、更大的内存（通常是旧容量的 **2倍** 或 **1.5倍**，取决于实现）。
  3. 将旧内存中的所有元素**移动**或**拷贝**到新内存中。

 - C++11后，如果元素类型提供了 `noexcept` 的移动构造函数，会优先使用**移动**，否则使用**拷贝**。

  4. **析构**并**释放**旧内存中的所有对象和旧内存块本身。
  5. 更新内部的指针，指向新内存，并更新容量值。
</code></pre>
<p><strong>19. vector 扩容时如何判断哪些元素需要移动哪些需要拷贝？</strong></p>
<ul>
<li>编译器在编译期通过 <code>std::is_nothrow_move_constructible&lt;T&gt;::value</code> 这类类型特质（type trait）来查询。</li>
<li><strong>判断规则</strong>：如果 <code>T</code> 的<strong>移动构造函数是 <code>noexcept</code> 的</strong>（或者不抛出异常），则扩容时会使用移动构造。否则，出于<strong>强异常安全保证</strong>的考虑，会使用拷贝构造，因为如果在移动中途抛出异常，源对象可能已被修改，无法恢复原有状态。</li>
</ul>
<p><strong>20. push_back 和 emplace_back 区别？</strong></p>
<ul>
<li><code>push_back(const T&amp; value)</code>: 接受一个已存在的对象，将其<strong>拷贝</strong>或<strong>移动</strong>到容器末尾。</li>
<li><code>push_back(T&amp;&amp; value)</code>: 接受一个右值，将其<strong>移动</strong>到容器末尾。</li>
<li><code>emplace_back(Args&amp;&amp;... args)</code>: 接受<strong>构造参数包</strong>，直接在容器末尾的内存处<strong>原地构造</strong>（in-place construction）一个新对象，无需创建临时对象。</li>
<li><strong>优势</strong>：<code>emplace_back</code> 避免了临时对象的创建和拷贝&#x2F;移动操作，通常更高效。</li>
</ul>
<hr>
<h3 id="智能指针-内存管理"><a href="#智能指针-内存管理" class="headerlink" title="智能指针 &amp; 内存管理"></a>智能指针 &amp; 内存管理</h3><p><strong>21. shared_ptr 的控制块设计？</strong></p>
<ul>
<li><code>shared_ptr</code> 包含两个原始指针：一个指向被管理的对象，一个指向<strong>控制块</strong>。</li>
<li><strong>控制块</strong>是一个动态分配的对象，通常包含：<ul>
<li><strong>引用计数（use_count）</strong>：当前有多少个 <code>shared_ptr</code> 共享 ownership。</li>
<li><strong>弱引用计数（weak_count）</strong>：当前有多少个 <code>weak_ptr</code> 在观察。</li>
<li><strong>删除器（Deleter）</strong>：如何删除被管理对象。</li>
<li><strong>分配器（Allocator）</strong>：如何分配&#x2F;释放控制块本身（通常可忽略）。</li>
</ul>
</li>
</ul>
<p><strong>22. shared_ptr 的引用计数存储在哪里？</strong></p>
<ul>
<li>存储在<strong>控制块</strong>中。控制块的内存是在创建第一个 <code>shared_ptr</code>（通常通过 <code>std::make_shared</code> 或 <code>std::allocate_shared</code>）时动态分配的。</li>
</ul>
<p><strong>23. 程序编译过程？（源码到二进制）</strong></p>
<pre><code>  1. **预处理（Preprocessing）**：处理宏（`#define`）、文件包含（`#include`）、条件编译（`#ifdef`）等，生成一个单一的翻译单元（`.i` 文件）。
  2. **编译（Compilation）**：将预处理后的源代码进行词法分析、语法分析、语义分析、优化，**翻译成汇编代码**（`.s` 文件）。
  3. **汇编（Assembly）**：将汇编代码**翻译成机器指令**，生成**目标文件**（`.o` 或 `.obj` 文件），包含二进制代码和数据。
  4. **链接（Linking）**：将一个或多个目标文件以及所需的库文件合并在一起，**解析符号引用**（如函数调用），分配最终的内存地址，生成最终的可执行文件（`.exe`, `.out`）或库文件。
</code></pre>
<p><strong>24. 动态链接为什么要加上 -fPIC 标记？</strong></p>
<ul>
<li><strong>PIC（Position-Independent Code）</strong>：位置无关代码。</li>
<li><strong>原因</strong>：动态链接库（<code>.so</code>, <code>.dll</code>）在运行时可以被加载到进程内存空间的<strong>任意地址</strong>。使用 <code>-fPIC</code> 编译可以生成这样的代码：它不包含绝对地址，而是通过<strong>全局偏移表（GOT）</strong> 来访问全局变量和函数。这样，库代码只需加载一份到内存，就可以被多个进程共享，每个进程只需有自己的数据段副本，极大地节省了内存。</li>
</ul>
<hr>
<h3 id="操作系统-系统编程"><a href="#操作系统-系统编程" class="headerlink" title="操作系统 &amp; 系统编程"></a>操作系统 &amp; 系统编程</h3><p><strong>25. 进程初始化时操作系统做了什么？</strong></p>
<pre><code>  1. 创建独立的**虚拟地址空间**。
  2. 建立**页表**，将可执行文件的**代码段（.text）和数据段（.data, .bss）** 映射到该地址空间。
  3. 设置**栈**和**堆**区域。
  4. 将CPU的指令寄存器（如EIP/RIP）设置为程序的入口点（如 `_start`），开始执行程序。
</code></pre>
<p><strong>26. 操作系统怎么分配进程的虚拟地址？</strong></p>
<ul>
<li>操作系统内核为每个进程维护一个<strong>虚拟内存地址空间的布局结构</strong>（例如，在Linux中是通过 <code>mm_struct</code> 描述的）。</li>
<li>布局通常是标准的：代码段、数据段、BSS段、堆（向上增长）、内存映射区域、栈（向下增长）、内核空间。</li>
<li>当进程通过 <code>malloc()</code> 或 <code>brk()/sbrk()</code> 请求堆内存，或通过 <code>mmap()</code> 请求内存映射时，内核的虚拟内存管理器会在进程的虚拟地址空间中<strong>找到一段足够大的空闲区域（hole）</strong> 分配给该请求，并更新页表。</li>
</ul>
<p><strong>27. 操作系统怎么实现从虚拟地址到物理地址的映射？</strong></p>
<ul>
<li>通过<strong>页表（Page Table）</strong> 数据结构来实现。</li>
<li><strong>过程（MMU）</strong>：<ol>
<li>CPU发出一个虚拟地址。</li>
<li><strong>内存管理单元（MMU）</strong> 拦截该地址。</li>
<li>MMU查询<strong>页表</strong>，找到该虚拟页号（VPN）对应的物理页框号（PFN）。</li>
<li>如果该页表项有效，MMU将PFN与页内偏移组合成物理地址。</li>
<li>如果页表项无效（页不在内存中），则触发<strong>缺页异常（Page Fault）</strong>，由操作系统负责将所需的页从磁盘调入物理内存，并更新页表，然后重新执行导致异常的指令。</li>
</ol>
</li>
</ul>
<p><strong>28. 页表初始化时会不会把所有虚拟内存都映射到物理内存？</strong></p>
<ul>
<li><strong>不会</strong>。那样做极其低效，浪费物理内存。</li>
<li><strong>延迟分配（Demand Paging）</strong>：操作系统只建立最基本的映射（如代码段、数据段）。对于堆、栈等大部分区域，只在进程<strong>首次访问</strong>某虚拟页时，才通过<strong>缺页异常</strong>处理程序为其分配物理页框并建立映射。这是一种“按需分配”的策略。</li>
</ul>
<p><strong>29. C++ 常见的锁的类型？</strong></p>
<ul>
<li><code>std::mutex</code>：基本的互斥锁。</li>
<li><code>std::recursive_mutex</code>：可重入互斥锁。</li>
<li><code>std::timed_mutex</code>：带超时功能的互斥锁。</li>
<li><code>std::shared_mutex</code> (C++17)：读写锁，允许共享读，独占写。</li>
<li><code>std::lock_guard</code> &#x2F; <code>std::unique_lock</code> &#x2F; <code>std::shared_lock</code>：RAII包装器，用于自动管理锁的生命周期。</li>
</ul>
<p><strong>30. 互斥锁怎么实现？</strong></p>
<ul>
<li><strong>用户态实现</strong>：通常使用<strong>原子操作</strong>（如CAS, Compare-And-Swap）来实现自旋锁（Spinlock），但纯自旋会浪费CPU。</li>
<li><strong>内核态协助</strong>：现代操作系统的互斥锁（如futex）是<strong>混合型</strong>的：<ul>
<li><strong>Fast Path</strong>：先在用户态尝试一次原子操作获取锁，如果成功则立即返回，开销很小。</li>
<li><strong>Slow Path</strong>：如果获取失败，则通过<strong>系统调用</strong>进入内核，将线程挂起到等待队列上休眠，让出CPU。当锁被释放时，内核会唤醒等待的线程。</li>
</ul>
</li>
</ul>
<p><strong>31. 死锁的四个必要条件？</strong></p>
<pre><code>  1. **互斥**：一个资源每次只能被一个进程使用。
  2. **占有并等待**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
  3. **不可抢占**：进程已获得的资源，在未使用完之前，不能强行被剥夺。
  4. **循环等待**：若干进程之间形成一种头尾相接的循环等待资源关系。
</code></pre>
<p><strong>32. 死锁怎么调试？</strong></p>
<ul>
<li><strong>观察现象</strong>：程序卡住，CPU占用率低。</li>
<li><strong>工具</strong>：<ul>
<li><strong>GDB</strong>： attach到进程，<code>thread apply all bt</code> 查看所有线程的调用栈。通常会发现多个线程都在 <code>__lll_lock_wait</code> 等类似的锁等待函数中，并且调用栈显示它们正在相互等待对方持有的锁。</li>
<li><strong>Helgrind &#x2F; DRD</strong> (Valgrind工具)：用于检测线程错误，包括死锁。</li>
<li><strong>操作系统命令</strong>：如Linux下的 <code>pstack &lt;pid&gt;</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><strong>33. 计算机网络协议分层？</strong></p>
<ul>
<li><strong>OSI七层模型</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li>
<li><strong>TCP&#x2F;IP五层模型</strong>（更实用）：<ul>
<li><strong>物理层</strong></li>
<li><strong>数据链路层</strong>（如Ethernet）</li>
<li><strong>网络层</strong>（如IP, ICMP）</li>
<li><strong>传输层</strong>（如TCP, UDP）</li>
<li><strong>应用层</strong>（如HTTP, DNS, FTP）</li>
</ul>
</li>
</ul>
<p><strong>34. ping 命令工作在哪一层？</strong></p>
<ul>
<li><strong>网络层</strong>。它使用 <strong>ICMP</strong>（Internet Control Message Protocol）协议的回送请求（Echo Request）和回送应答（Echo Reply）报文。</li>
</ul>
<p><strong>35. IP 头字段有哪些？</strong></p>
<ul>
<li><strong>重要字段</strong>：版本（4&#x2F;6）、首部长度、服务类型（TOS）、总长度、标识、标志、片偏移、生存时间（TTL）、协议（指示上层是TCP&#x2F;UDP等）、首部校验和、源IP地址、目的IP地址、选项（可选）。</li>
</ul>
<p><strong>36. TCP 三次握手流程？</strong></p>
<pre><code>  1. **SYN**：客户端发送一个SYN=1，seq=`x` 的包给服务器。进入SYN_SENT状态。
  2. **SYN-ACK**：服务器收到后，回复一个SYN=1，ACK=1，ack=`x+1`，seq=`y` 的包。进入SYN_RCVD状态。
  3. **ACK**：客户端收到后，再发送一个ACK=1，ack=`y+1`，seq=`x+1` 的包给服务器。完成连接，双方进入ESTABLISHED状态。
</code></pre>
<ul>
<li><strong>目的</strong>：交换初始序列号（ISN），确认双方的收发能力正常。</li>
</ul>
<hr>
<h3 id="调试-其他"><a href="#调试-其他" class="headerlink" title="调试 &amp; 其他"></a>调试 &amp; 其他</h3><p><strong>37. 内存泄漏怎么定位？</strong></p>
<ul>
<li><strong>工具</strong>：<ul>
<li><strong>Valgrind (memcheck)</strong>：Linux下最经典的工具。<code>valgrind --leak-check=full ./your_program</code>。</li>
<li><strong>AddressSanitizer (ASan)</strong>：GCC&#x2F;Clang编译选项，速度快，开销低。<code>-fsanitize=address -g</code>。</li>
<li><strong>智能指针</strong>：从代码设计上避免泄漏。</li>
</ul>
</li>
<li><strong>步骤</strong>：使用工具运行程序，工具会报告泄漏内存的分配位置（调用栈）。</li>
</ul>
<p><strong>38. 内存泄漏的影响？</strong></p>
<ul>
<li><strong>短期影响</strong>：进程的虚拟内存占用（RSS）持续上升。</li>
<li><strong>长期影响</strong>：<ul>
<li>耗尽可用内存，导致系统变慢，交换（swapping）加剧。</li>
<li>可能引发 <code>std::bad_alloc</code> 异常，导致程序崩溃。</li>
<li>对于长时间运行的服务（如服务器、后台进程），即使是缓慢的泄漏，最终也必然导致程序或系统崩溃。</li>
</ul>
</li>
</ul>
<h2 id="小米面试题"><a href="#小米面试题" class="headerlink" title="小米面试题"></a>小米面试题</h2><hr>
<h3 id="1-std-vector的扩容机制是什么？扩容时代价多大？如何避免频繁扩容？"><a href="#1-std-vector的扩容机制是什么？扩容时代价多大？如何避免频繁扩容？" class="headerlink" title="1. std::vector的扩容机制是什么？扩容时代价多大？如何避免频繁扩容？"></a>1. std::vector的扩容机制是什么？扩容时代价多大？如何避免频繁扩容？</h3><p><strong>扩容机制：</strong><br>当<code>std::vector</code>的<code>size()</code>即将超过当前<code>capacity()</code>时，会发生扩容。其机制是：</p>
<ol>
<li>分配一块新的、更大的内存空间（通常是当前容量的 <strong>2倍</strong> 或 <strong>1.5倍</strong>，取决于标准库实现，MSVC是1.5倍，GCC是2倍）。</li>
<li>将原有内存中的所有元素<strong>移动</strong>或<strong>拷贝</strong>到新的内存空间中。</li>
<li>释放原有的内存空间。</li>
<li>更新内部的指针和容量标记。</li>
</ol>
<p><strong>扩容代价：</strong><br>代价非常大，主要体现在：</p>
<ul>
<li><strong>时间代价：</strong> O(N)。需要将旧元素全部复制&#x2F;移动到新空间。这会使当前进行<code>push_back</code>等操作的摊销时间复杂度变高。</li>
<li><strong>空间代价：</strong> 需要一块连续的、更大的内存。这可能导致内存碎片。</li>
<li><strong>迭代器失效：</strong> 所有指向原vector的迭代器、指针、引用都会立即失效。</li>
</ul>
<p><strong>如何避免频繁扩容：</strong></p>
<ol>
<li><strong>使用<code>reserve()</code>预分配：</strong> 如果事先知道元素的大致数量，可以使用 <code>vec.reserve(n)</code> 预先分配足够的内存，这样在添加前n个元素时就可以完全避免扩容。</li>
<li><strong>使用初始化构造函数：</strong> <code>std::vector&lt;int&gt; vec(1000);</code> 直接创建一个包含1000个默认初始化元素的vector，其容量至少为1000。</li>
</ol>
<hr>
<h3 id="2-C-中malloc和new的区别？delete和delete-能混用吗？"><a href="#2-C-中malloc和new的区别？delete和delete-能混用吗？" class="headerlink" title="2. C++中malloc和new的区别？delete和delete[]能混用吗？"></a>2. C++中malloc和new的区别？delete和delete[]能混用吗？</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>malloc</code> &#x2F; <code>free</code></th>
<th align="left"><code>new</code> &#x2F; <code>delete</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>语言</strong></td>
<td align="left">C库函数</td>
<td align="left">C++运算符</td>
</tr>
<tr>
<td align="left"><strong>内存来源</strong></td>
<td align="left">堆（Heap）</td>
<td align="left">自由存储区（Free Store），<strong>通常也是堆</strong></td>
</tr>
<tr>
<td align="left"><strong>返回值</strong></td>
<td align="left"><code>void*</code>（需要强制转换）</td>
<td align="left">正确类型的指针</td>
</tr>
<tr>
<td align="left"><strong>参数</strong></td>
<td align="left">所需内存的字节数</td>
<td align="left">类型（编译器自动计算大小）</td>
</tr>
<tr>
<td align="left"><strong>初始化</strong></td>
<td align="left"><strong>不</strong>调用构造函数，内存内容是<strong>未初始化</strong>的</td>
<td align="left"><strong>会</strong>调用构造函数，完成对象初始化</td>
</tr>
<tr>
<td align="left"><strong>失败行为</strong></td>
<td align="left">返回<code>NULL</code></td>
<td align="left">抛出<code>std::bad_alloc</code>异常（除非用<code>nothrow</code>）</td>
</tr>
<tr>
<td align="left"><strong>分配大小</strong></td>
<td align="left">返回分配的确切字节数</td>
<td align="left">取决于编译器实现，可能包含管理信息</td>
</tr>
<tr>
<td align="left"><strong>重载</strong></td>
<td align="left">不可重载</td>
<td align="left">可重载（类成员重载和全局重载）</td>
</tr>
<tr>
<td align="left"><strong>析构</strong></td>
<td align="left"><code>free</code><strong>不</strong>调用析构函数</td>
<td align="left"><code>delete</code><strong>会</strong>调用析构函数</td>
</tr>
</tbody></table>
<p><strong><code>delete</code>和<code>delete[]</code>能混用吗？</strong><br><strong>绝对不能混用！</strong></p>
<ul>
<li><code>delete</code>用于释放<code>new</code>分配的<strong>单个对象</strong>。</li>
<li><code>delete[]</code>用于释放<code>new[]</code>分配的<strong>对象数组</strong>。</li>
<li>混用会导致<strong>未定义行为（Undefined Behavior）</strong>，最常见的后果是：<ul>
<li>对于有析构函数的类，<code>delete</code>数组会导致<strong>只调用第一个元素的析构函数</strong>，后续元素的析构函数不会被调用，导致资源泄漏。</li>
<li>破坏内存管理结构，导致程序崩溃。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-如果类中有const成员或引用成员，能否自动生成移动构造函数？为什么？"><a href="#3-如果类中有const成员或引用成员，能否自动生成移动构造函数？为什么？" class="headerlink" title="3. 如果类中有const成员或引用成员，能否自动生成移动构造函数？为什么？"></a>3. 如果类中有const成员或引用成员，能否自动生成移动构造函数？为什么？</h3><p><strong>不能。</strong></p>
<p><strong>原因：</strong><br><code>const</code>成员和引用成员在初始化后，其绑定的值或对象就不可更改。<br>移动语义的本质是“资源偷取”，它需要将源对象的资源“转移”到目标对象，然后将源对象置于一个“有效但未定义”的状态（通常设为<code>nullptr</code>或0）。<br>然而，对于<code>const</code>成员和引用成员，编译器无法生成代码来修改它们（因为它们是只读的），所以无法实现“资源偷取”这一核心操作。<br>因此，编译器不会为含有<code>const</code>成员或引用成员的类自动生成默认的移动构造函数和移动赋值运算符。如果你需要移动操作，必须<strong>手动定义</strong>它们。</p>
<hr>
<h3 id="4-什么是内存对齐？为什么需要内存对齐？如何手动控制结构体的内存对齐？"><a href="#4-什么是内存对齐？为什么需要内存对齐？如何手动控制结构体的内存对齐？" class="headerlink" title="4. 什么是内存对齐？为什么需要内存对齐？如何手动控制结构体的内存对齐？"></a>4. 什么是内存对齐？为什么需要内存对齐？如何手动控制结构体的内存对齐？</h3><p><strong>什么是内存对齐：</strong><br>数据在内存中的起始地址必须是某个值（通常是其自身大小或平台字长）的整数倍。</p>
<p><strong>为什么需要：</strong></p>
<ul>
<li><strong>性能原因：</strong> 现代CPU并非以字节为单位读写内存，而是以“块”（如64字节缓存行）为单位。如果数据未对齐，一个数据可能横跨两个内存块，需要两次内存访问才能读完，效率低下。</li>
<li><strong>硬件原因：</strong> 某些架构（如ARM, SPARC）的CPU<strong>根本无法访问未对齐的内存地址</strong>，会直接抛出硬件异常。</li>
</ul>
<p><strong>如何手动控制：</strong></p>
<ul>
<li><strong>C++11标准方式：</strong> 使用<code>alignas</code>说明符。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) MyStruct &#123; <span class="comment">// 强制该结构体按16字节对齐</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>编译器扩展（常用）：</strong> 使用<code>#pragma pack</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1) <span class="comment">// 保存当前对齐方式，并设置为1字节对齐（即无填充）</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;   <span class="comment">// 地址偏移 0</span></span><br><span class="line">    <span class="type">char</span> b;  <span class="comment">// 地址偏移 4</span></span><br><span class="line">    <span class="comment">// 总共大小是5，没有填充字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop) <span class="comment">// 恢复之前保存的对齐方式</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="5-进程和线程的区别？进程间通信有哪些方式？哪种效率最高？"><a href="#5-进程和线程的区别？进程间通信有哪些方式？哪种效率最高？" class="headerlink" title="5. 进程和线程的区别？进程间通信有哪些方式？哪种效率最高？"></a>5. 进程和线程的区别？进程间通信有哪些方式？哪种效率最高？</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">进程 (Process)</th>
<th align="left">线程 (Thread)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>资源拥有</strong></td>
<td align="left">是<strong>资源分配</strong>的基本单位，拥有独立的地址空间、文件描述符等</td>
<td align="left">是<strong>CPU调度</strong>的基本单位，<strong>共享</strong>进程的资源</td>
</tr>
<tr>
<td align="left"><strong>切换代价</strong></td>
<td align="left">高（需要切换页表、刷新TLB等）</td>
<td align="left">低（只需切换栈和寄存器等少量上下文）</td>
</tr>
<tr>
<td align="left"><strong>独立性</strong></td>
<td align="left">一个进程崩溃<strong>不会影响</strong>其他进程</td>
<td align="left">一个线程崩溃会导致<strong>整个进程</strong>崩溃</td>
</tr>
<tr>
<td align="left"><strong>通信机制</strong></td>
<td align="left">复杂（需要IPC机制）</td>
<td align="left">简单（可直接读写共享的进程内存）</td>
</tr>
</tbody></table>
<p><strong>进程间通信（IPC）方式：</strong></p>
<ol>
<li><strong>管道 (Pipe)</strong> &#x2F; <strong>命名管道 (FIFO)</strong>：单向字节流，适用于父子进程或有亲缘关系的进程。</li>
<li><strong>消息队列 (Message Queue)</strong>：消息的链表，允许非亲缘进程通信。</li>
<li><strong>共享内存 (Shared Memory)</strong>：<strong>效率最高</strong>。将同一块物理内存映射到不同进程的虚拟地址空间，进程可以直接读写该内存，无需内核拷贝。需要配合信号量或互斥锁等同步机制使用。</li>
<li><strong>信号量 (Semaphore)</strong>：主要用于同步，而不是传递数据。</li>
<li><strong>信号 (Signal)</strong>：一种异步通知机制。</li>
<li><strong>套接字 (Socket)</strong>：最通用的IPC，可以跨网络通信。</li>
</ol>
<p><strong>效率最高：</strong> <strong>共享内存</strong>。因为它避免了数据在用户态和内核态之间的拷贝。</p>
<hr>
<h3 id="6-线程同步有哪些机制？std-mutex、std-lock-guard、std-unique-lock的区别？"><a href="#6-线程同步有哪些机制？std-mutex、std-lock-guard、std-unique-lock的区别？" class="headerlink" title="6. 线程同步有哪些机制？std::mutex、std::lock_guard、std::unique_lock的区别？"></a>6. 线程同步有哪些机制？std::mutex、std::lock_guard、std::unique_lock的区别？</h3><p><strong>线程同步机制：</strong><br>互斥锁 (Mutex)、条件变量 (Condition Variable)、信号量 (Semaphore)、读写锁 (Read-Write Lock)、自旋锁 (Spinlock)、屏障 (Barrier)、原子操作 (Atomic Operations) 等。</p>
<p><strong>C++中三者的区别：</strong></p>
<ul>
<li><strong><code>std::mutex</code></strong>：是<strong>基础锁对象</strong>，提供<code>lock()</code>, <code>unlock()</code>, <code>try_lock()</code>等基本操作。需要程序员手动调用<code>unlock()</code>释放锁，否则会导致死锁。</li>
<li><strong><code>std::lock_guard</code></strong>：是<strong>RAII包装器</strong>。在构造时自动锁定<code>mutex</code>，在析构时自动解锁。<strong>它非常轻量，但不能手动控制加解锁时机</strong>，作用域结束时必然解锁。</li>
<li><strong><code>std::unique_lock</code></strong>：也是<strong>RAII包装器</strong>，但比<code>lock_guard</code>更灵活。它允许：<ul>
<li>延迟锁定（<code>defer_lock</code>）。</li>
<li>手动调用<code>lock()</code>和<code>unlock()</code>。</li>
<li>条件变量必须配合<code>unique_lock</code>使用。</li>
<li>所有权可以移动（<code>move</code>）。</li>
<li>性能上比<code>lock_guard</code>有微小开销。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong> 优先使用<code>lock_guard</code>，在需要更灵活控制的场景（如条件变量）使用<code>unique_lock</code>。</p>
<hr>
<h3 id="7-什么是虚假共享（False-Sharing）？如何避免？"><a href="#7-什么是虚假共享（False-Sharing）？如何避免？" class="headerlink" title="7. 什么是虚假共享（False Sharing）？如何避免？"></a>7. 什么是虚假共享（False Sharing）？如何避免？</h3><p><strong>什么是虚假共享：</strong><br>现代CPU为每个核心都有独占的高速缓存（L1&#x2F;L2 Cache），缓存与内存交换数据的基本单位是<strong>缓存行（Cache Line，通常为64字节）</strong>。<br>如果两个无关的变量<code>A</code>和<code>B</code>恰好位于同一个缓存行上， Core1 频繁修改<code>A</code>，Core2 频繁读取<code>B</code>。那么每次Core1修改<code>A</code>时，都会导致Core2的整个缓存行失效，需要重新从内存加载，即使<code>B</code>的值实际上并没有变化。这种因为缓存行共享而导致的<strong>不必要的缓存失效和同步</strong>，就是虚假共享。它会严重损害多线程程序的性能。</p>
<p><strong>如何避免：</strong></p>
<ol>
<li><strong>缓存行对齐：</strong> 让每个频繁被独立线程访问的变量独占一个缓存行。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) MyData &#123; <span class="comment">// 64字节对齐</span></span><br><span class="line">    <span class="type">int</span> counter1;</span><br><span class="line">    <span class="comment">// 这里会有大约60字节的填充（padding）</span></span><br><span class="line">&#125;;</span><br><span class="line">MyData data[<span class="number">2</span>]; <span class="comment">// data[0]和data[1]必然在不同的缓存行</span></span><br></pre></td></tr></table></figure></li>
<li><strong>使用线程本地存储（TLS）：</strong> 如果可能，将数据声明为<code>thread_local</code>，从根本上避免共享。</li>
<li><strong>重新设计数据结构：</strong> 将可能被不同线程频繁修改的成员变量分开存放。</li>
</ol>
<hr>
<h3 id="8-手撕：实现一个线程安全的环形队列（支持多生产者多消费者）"><a href="#8-手撕：实现一个线程安全的环形队列（支持多生产者多消费者）" class="headerlink" title="8. 手撕：实现一个线程安全的环形队列（支持多生产者多消费者）"></a>8. 手撕：实现一个线程安全的环形队列（支持多生产者多消费者）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CircularQueue</span><span class="params">(<span class="type">size_t</span> capacity)</span> </span></span><br><span class="line"><span class="function">        : buffer_(capacity), capacity_(capacity), head_(<span class="number">0</span>), tail_(<span class="number">0</span>), count_(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; item)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        not_full_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> count_ &lt; capacity_; &#125;);</span><br><span class="line">        </span><br><span class="line">        buffer_[tail_] = item;</span><br><span class="line">        tail_ = (tail_ + <span class="number">1</span>) % capacity_;</span><br><span class="line">        ++count_;</span><br><span class="line">        </span><br><span class="line">        not_empty_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        not_empty_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> count_ &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">        </span><br><span class="line">        item = buffer_[head_];</span><br><span class="line">        head_ = (head_ + <span class="number">1</span>) % capacity_;</span><br><span class="line">        --count_;</span><br><span class="line">        </span><br><span class="line">        not_full_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 empty(), full(), size() 等方法...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; buffer_;</span><br><span class="line">    <span class="type">size_t</span> capacity_;</span><br><span class="line">    <span class="type">size_t</span> head_;</span><br><span class="line">    <span class="type">size_t</span> tail_;</span><br><span class="line">    <span class="type">size_t</span> count_; <span class="comment">// 当前元素数量，用于判断空/满，避免歧义</span></span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    std::condition_variable not_empty_;</span><br><span class="line">    std::condition_variable not_full_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>要点：</strong></p>
<ul>
<li>**使用<code>count_</code>**来判断队列空和满，这是最清晰的方式。</li>
<li><strong>使用互斥锁 (<code>mutex_</code>)</strong> 保护共享数据 (<code>head_</code>, <code>tail_</code>, <code>count_</code>, <code>buffer_</code>)。</li>
<li><strong>使用两个条件变量 (<code>not_empty_</code>, <code>not_full_</code>)</strong> 进行线程间通知，避免忙等待。</li>
<li><strong><code>notify_one()</code></strong> 用于唤醒一个等待线程，适用于多生产者多消费者场景。</li>
</ul>
<hr>
<h3 id="9-如何使用Valgrind或ASAN排查内存泄漏和越界问题？你在项目中用过吗？"><a href="#9-如何使用Valgrind或ASAN排查内存泄漏和越界问题？你在项目中用过吗？" class="headerlink" title="9. 如何使用Valgrind或ASAN排查内存泄漏和越界问题？你在项目中用过吗？"></a>9. 如何使用Valgrind或ASAN排查内存泄漏和越界问题？你在项目中用过吗？</h3><p><strong>Valgrind (Memcheck工具):</strong></p>
<ol>
<li><strong>编译：</strong> 使用<code>-g</code>选项编译程序，包含调试信息。</li>
<li><strong>运行：</strong> <code>valgrind --leak-check=full --show-leak-kinds=all ./your_program arg1 arg2</code></li>
<li><strong>查看输出：</strong> Valgrind会详细报告：<ul>
<li><strong>内存泄漏：</strong> 在哪个位置分配的内存没有被释放。</li>
<li><strong>越界读写：</strong> 对非法内存地址的访问。</li>
<li><strong>使用未初始化值：</strong> 使用了未初始化的变量。</li>
<li><strong>重复释放：</strong> 对同一块内存释放了两次。</li>
</ul>
</li>
</ol>
<p><strong>ASAN (AddressSanitizer，编译时插桩):</strong></p>
<ol>
<li><strong>编译和链接：</strong> 在gcc&#x2F;clang中添加<code>-fsanitize=address -g</code>选项。</li>
<li><strong>运行：</strong> 直接运行程序 <code>./your_program</code>。</li>
<li><strong>查看输出：</strong> 程序崩溃或退出时，ASAN会在控制台输出非常清晰的错误报告，包括错误类型（堆溢出、栈溢出、释放后使用等）、调用栈、内存映射情况。</li>
</ol>
<p><strong>使用经验：</strong><br>这是一个展示你工程经验的好机会。可以回答：“是的，我在项目中经常使用。ASAN因为性能开销相对较小（约2倍），通常集成在CI&#x2F;CD的Debug构建中，用于日常开发阶段的检查。而Valgrind更加强大和全面，在遇到一些ASAN难以定位的复杂内存问题时，会使用Valgrind进行更深层次的分析。”</p>
<hr>
<h3 id="10-如何用GDB调试死锁？thread-apply-all-bt-这个命令有什么用？"><a href="#10-如何用GDB调试死锁？thread-apply-all-bt-这个命令有什么用？" class="headerlink" title="10. 如何用GDB调试死锁？thread apply all bt 这个命令有什么用？"></a>10. 如何用GDB调试死锁？<code>thread apply all bt</code> 这个命令有什么用？</h3><p><strong>调试死锁步骤：</strong></p>
<ol>
<li>运行程序，当发生死锁（卡住）时，用<code>Ctrl+C</code>（SIGINT信号）中断程序。</li>
<li>在GDB中，使用 <code>thread apply all bt</code> 命令。<ul>
<li><strong><code>thread apply all</code></strong>： 表示将后续命令应用于<strong>所有线程</strong>。</li>
<li><strong><code>bt</code> (backtrace)</strong>： 打印线程的调用栈。</li>
</ul>
</li>
<li>查看每个线程的调用栈，<strong>重点看每个线程当前正停在哪个函数、哪一行代码，持有了哪个锁</strong>。通常你会发现两个或多个线程的调用栈显示它们正在互相等待对方持有的锁，从而定位死锁位置。</li>
</ol>
<p><strong><code>thread apply all bt</code> 的作用：</strong><br><strong>一次性打印出程序中所有线程的调用栈信息。</strong> 这是调试多线程程序（如死锁、卡顿）最核心、最常用的命令。</p>
<hr>
<h3 id="11-什么是虚函数表？多重继承下的虚函数表结构是怎样的？"><a href="#11-什么是虚函数表？多重继承下的虚函数表结构是怎样的？" class="headerlink" title="11. 什么是虚函数表？多重继承下的虚函数表结构是怎样的？"></a>11. 什么是虚函数表？多重继承下的虚函数表结构是怎样的？</h3><p><strong>虚函数表 (vtable):</strong><br>是一个编译期为每个包含虚函数的类（或该类的子类）自动创建的<strong>静态函数指针数组</strong>。每个数组元素指向一个虚函数的实际实现。</p>
<ul>
<li>每个包含虚函数的类对象在其内存布局的<strong>最开头</strong>（通常如此）会有一个隐藏的 <strong><code>vptr</code>（虚函数表指针）</strong>，指向该类的虚函数表。</li>
<li>调用虚函数时，运行时会通过对象的<code>vptr</code>找到<code>vtable</code>，再根据函数在表中的偏移量找到正确的函数地址进行调用。</li>
</ul>
<p><strong>多重继承下的虚函数表：</strong><br>会更加复杂。派生类会包含<strong>多个<code>vptr</code></strong>，每个<code>vptr</code>指向一个对应基类的虚函数表。</p>
<ul>
<li>第一个基类的虚函数表与单继承时类似。</li>
<li>后续基类的虚函数表会<strong>前置一个偏移量（offset）</strong>，用于<code>this</code>指针调整。因为当使用第二个基类指针指向派生类对象时，<code>this</code>指针需要偏移到对象中该基类子对象的位置。</li>
<li>派生类重写的函数会覆盖所有相关基类虚函数表中的对应项。</li>
<li>派生类新增的虚函数一般会放在第一个基类的虚函数表的末尾。</li>
</ul>
<hr>
<h3 id="12-Epoll的水平触发和边缘触发有什么区别？使用场景是什么？"><a href="#12-Epoll的水平触发和边缘触发有什么区别？使用场景是什么？" class="headerlink" title="12. Epoll的水平触发和边缘触发有什么区别？使用场景是什么？"></a>12. Epoll的水平触发和边缘触发有什么区别？使用场景是什么？</h3><table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">水平触发 (LT - Level-Triggered)</th>
<th align="left">边缘触发 (ET - Edge-Triggered)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工作方式</strong></td>
<td align="left">只要文件描述符<strong>处于就绪状态</strong>（读缓冲区非空&#x2F;写缓冲区未满），就会持续通知。</td>
<td align="left">只在文件描述符<strong>状态发生变化时</strong>（如从不可读变为可读）<strong>通知一次</strong>。</td>
</tr>
<tr>
<td align="left"><strong>编程复杂性</strong></td>
<td align="left"><strong>简单</strong>。即使一次没有处理完所有数据，下次调用<code>epoll_wait</code>还会再次通知。</td>
<td align="left"><strong>复杂</strong>。收到通知后，<strong>必须循环读写</strong>直到返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>错误，确保把所有数据都处理完，否则会因为再无事件通知而丢失数据。</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">理论上可能通知次数更多。</td>
<td align="left">通知次数更少，效率更高。</td>
</tr>
<tr>
<td align="left"><strong>默认行为</strong></td>
<td align="left"><code>epoll</code>的默认模式。</td>
<td align="left">需要设置 <code>EPOLLET</code> 标志。</td>
</tr>
</tbody></table>
<p><strong>使用场景：</strong></p>
<ul>
<li><strong>LT模式：</strong> 编程更简单，不易出错，是默认的选择。适用于大多数场景。</li>
<li><strong>ET模式：</strong> 效率更高，可以减少<code>epoll_wait</code>的系统调用次数。但要求应用程序必须使用<strong>非阻塞I&#x2F;O</strong>，并且一次事件触发后必须彻底处理完所有数据。常用于需要极高性能的网络服务器（如Nginx）。</li>
</ul>
<hr>
<h3 id="13-讲一下TCP拥塞控制机制？TIME-WAIT状态的作用是什么"><a href="#13-讲一下TCP拥塞控制机制？TIME-WAIT状态的作用是什么" class="headerlink" title="13. 讲一下TCP拥塞控制机制？TIME_WAIT状态的作用是什么"></a>13. 讲一下TCP拥塞控制机制？TIME_WAIT状态的作用是什么</h3><p><strong>TCP拥塞控制机制：</strong><br>目的是避免网络因为负载过重而出现“拥塞崩溃”。主要包括四个核心算法：</p>
<ol>
<li><strong>慢启动 (Slow Start)：</strong> 连接开始时，拥塞窗口 (<code>cwnd</code>) 从1个MSS开始，每收到一个ACK，<code>cwnd</code>就翻倍（指数增长）。直到超过慢启动阈值 (<code>ssthresh</code>) 或发生丢包。</li>
<li><strong>拥塞避免 (Congestion Avoidance)：</strong> 当<code>cwnd</code> &gt;&#x3D; <code>ssthresh</code>时，进入拥塞避免阶段，每RTT时间<code>cwnd</code>只加1（线性增长），谨慎探询更多带宽。</li>
<li><strong>快速重传 (Fast Retransmit)：</strong> 收到<strong>3个重复的ACK</strong>时，推断数据包丢失，立即重传丢失的报文，而不必等待超时。</li>
<li><strong>快速恢复 (Fast Recovery)：</strong> 在快速重传后，将<code>ssthresh</code>设置为当前<code>cwnd</code>的一半，并将<code>cwnd</code>设置为新的<code>ssthresh</code>（或略大），然后直接进入<strong>拥塞避免</strong>阶段（而非慢启动）。这是对“ Tahoe”算法的改进（“Reno”算法）。</li>
</ol>
<p><strong>TIME_WAIT状态的作用：</strong><br>TCP连接主动关闭的一方（先发送FIN的一方）会进入<code>TIME_WAIT</code>状态，持续时间为 <strong>2MSL</strong>（Maximum Segment Lifetime，报文最大生存时间）。<br>其<strong>两个核心作用</strong>：</p>
<ol>
<li><strong>可靠地终止连接：</strong> 确保最后一个ACK（对对方FIN的确认）能够被对方收到。如果这个ACK丢失，对方会超时重传FIN，处于<code>TIME_WAIT</code>状态的一方可以重新回应一个ACK。</li>
<li><strong>让旧的重复报文失效：</strong> 等待足够长的时间（2MSL），使得本次连接产生的所有报文都在网络中消失，这样下一个<strong>相同四元组</strong>（源IP、源端口、目的IP、目的端口）的新连接就不会收到属于旧连接的、延迟到达的报文，从而避免数据错乱。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://brinjaul521.github.io">贺腾</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://brinjaul521.github.io/2025/09/17/C-%E9%9D%A2%E8%AF%95%E9%A2%98/">https://brinjaul521.github.io/2025/09/17/C-%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://brinjaul521.github.io" target="_blank">贺腾的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="/img/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/09/17/MySql%E7%AC%94%E8%AE%B0/" title="MySql笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MySql笔记</div></div><div class="info-2"><div class="info-item-1">Mysql索引好的，这是一个非常重要且常见的面试话题。我会从原理到实践，为你彻底讲清楚 MySQL 索引。  一、索引是什么？（本质与原理）你可以把数据库索引想象成一本书的目录。  没有索引（目录）：当你想在书中找到“索引失效”这个内容时，你只能一页一页地从头翻到尾（这叫做全表扫描），效率极低。 有索引（目录）：你可以直接查看目录，快速定位到“索引失效”内容所在的页码，然后直接翻到那一页。这个“目录”就是索引，它通过建立一种高效的数据结构，避免了逐行查找。  技术本质：索引是一种排好序的快速查找数据结构。MySQL 中最常用的索引类型是 B+Tree（B+树）。 B+Tree 的特点（为什么选它）：  矮胖树：层级低，通常只需要 3-4 次 I&#x2F;O 操作就能从上亿条数据中定位到目标，查找效率极高。 有序存储：叶子节点存储数据并按顺序链接，非常适合范围查询（WHERE id &gt; 100）和排序（ORDER BY）。 数据只存储在叶子节点：非叶子节点只存键值，使得每个节点能存放更多的关键字，让树更“矮胖”。  索引的代价：  空间代价：索引也是一张表，需要占用额外的磁...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">贺腾</div><div class="author-info-description">我等的不是海边</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/brinjaul521/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/brinjaul521/" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1061391142@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">记录一下学习路线，顺便找个工作</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9D%BF%E8%81%94%E9%9D%A2%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">睿联面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linux-swap%E5%88%86%E5%8C%BA%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">linux swap分区什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E6%9C%89%E5%87%A0%E7%A7%8D%E6%9D%83%E9%99%90%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">Linux文件有几种权限，分别是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">Linux文件的基本权限类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">三种基本权限类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%94%A8%E6%88%B7%E7%B1%BB%E5%88%AB"><span class="toc-number">1.2.3.</span> <span class="toc-text">三种用户类别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E8%80%85-Owner-user-u-%EF%BC%9A%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E7%9A%84%E5%88%9B%E5%BB%BA%E8%80%85-%E6%8B%A5%E6%9C%89%E8%80%85"><span class="toc-number">1.2.4.</span> <span class="toc-text">所有者 (Owner&#x2F;user - u)：文件或目录的创建者&#x2F;拥有者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">权限表示方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.2.6.</span> <span class="toc-text">符号表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%EF%BC%89"><span class="toc-number">1.2.7.</span> <span class="toc-text">数字表示法（八进制表示）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90"><span class="toc-number">1.2.8.</span> <span class="toc-text">特殊权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">1.2.9.</span> <span class="toc-text">查看文件权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">1.2.10.</span> <span class="toc-text">修改文件权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.11.</span> <span class="toc-text">权限示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">抽象类和接口有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MYSQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">1.4.</span> <span class="toc-text">MYSQL索引失效的几种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%88%96%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 对索引列使用函数或表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8LIKE%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6%E5%BC%80%E5%A4%B4"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 使用LIKE模糊查询以通配符开头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 隐式类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8OR%E6%9D%A1%E4%BB%B6%E4%B8%94%E9%83%A8%E5%88%86%E5%88%97%E6%97%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. 使用OR条件且部分列无索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%8D%E7%AC%A6%E5%90%88%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%EF%BC%88%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">1.4.5.</span> <span class="toc-text">5. 不符合最左前缀原则（复合索引）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8%E4%B8%8D%E7%AD%89%E4%BA%8E-%E6%88%96-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.6.</span> <span class="toc-text">6. 使用不等于(!&#x3D;或&lt;&gt;)操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E4%BD%BF%E7%94%A8IS-NULL%E6%88%96IS-NOT-NULL"><span class="toc-number">1.4.7.</span> <span class="toc-text">7. 对索引列使用IS NULL或IS NOT NULL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%E5%8C%80"><span class="toc-number">1.4.8.</span> <span class="toc-text">8. 数据分布不均匀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%BD%BF%E7%94%A8ORDER-BY%E4%B8%8E%E7%B4%A2%E5%BC%95%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="toc-number">1.4.9.</span> <span class="toc-text">9. 使用ORDER BY与索引不匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E8%A1%A8%E6%95%B0%E6%8D%AE%E9%87%8F%E5%BE%88%E5%B0%8F"><span class="toc-number">1.4.10.</span> <span class="toc-text">10. 表数据量很小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E7%B4%A2%E5%BC%95%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E8%BF%87%E6%97%B6"><span class="toc-number">1.4.11.</span> <span class="toc-text">11. 索引统计信息过时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E4%BD%BF%E7%94%A8%E8%B4%9F%E5%90%91%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.4.12.</span> <span class="toc-text">12. 使用负向查询条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8A%E6%96%AD%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.4.13.</span> <span class="toc-text">诊断索引使用情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.4.14.</span> <span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%B2%98%E5%8C%85%EF%BC%8C%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%8C%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number">1.5.</span> <span class="toc-text">C++网络编程如何处理粘包，超时重传，断点续传</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98-Sticky-Packet-Unpacking"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 粘包&#x2F;拆包问题 (Sticky Packet &#x2F; Unpacking)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E8%AE%BE%E8%AE%A1%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.2.</span> <span class="toc-text">解决方案：设计应用层协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0-Timeout-Retransmission"><span class="toc-number">1.5.3.</span> <span class="toc-text">2. 超时重传 (Timeout Retransmission)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%EF%BC%88ACK%EF%BC%89-%E8%B6%85%E6%97%B6%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">解决方案：确认应答（ACK） + 超时计时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0-Resume-from-Breakpoint"><span class="toc-number">1.5.5.</span> <span class="toc-text">3. 断点续传 (Resume from Breakpoint)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E8%AE%B0%E5%BD%95%E5%B7%B2%E4%BC%A0%E8%BE%93%E8%BF%9B%E5%BA%A6-%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.5.6.</span> <span class="toc-text">解决方案：记录已传输进度 + 校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%85%B3%E8%81%94"><span class="toc-number">1.5.7.</span> <span class="toc-text">总结与关联</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.</span> <span class="toc-text">TCP的流式传输如何理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%AF%94%E5%96%BB%EF%BC%9A%E6%B0%B4%E7%AE%A1%E9%80%81%E7%A7%AF%E6%9C%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">核心比喻：水管送积木</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E5%BE%81%E4%B8%8E%E5%BD%B1%E5%93%8D"><span class="toc-number">1.6.2.</span> <span class="toc-text">流式传输的关键特征与影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%97%A0%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C-No-Message-Boundaries"><span class="toc-number">1.6.3.</span> <span class="toc-text">1. 无消息边界 (No Message Boundaries)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%89%E5%BA%8F%E5%92%8C%E5%8F%AF%E9%9D%A0-Ordered-Reliable"><span class="toc-number">1.6.4.</span> <span class="toc-text">2. 有序和可靠 (Ordered &amp; Reliable)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5-Connection-Oriented"><span class="toc-number">1.6.5.</span> <span class="toc-text">3. 面向连接 (Connection-Oriented)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8EUDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.6.</span> <span class="toc-text">与UDP数据报传输的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8A%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">1.6.7.</span> <span class="toc-text">编程模型上的体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BC%9A%E4%BB%8E%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E3%80%81%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E4%B8%89%E4%B8%AA%E5%B1%82%E9%9D%A2"><span class="toc-number">2.</span> <span class="toc-text">面试官会从基础概念、深入原理和实战应用三个层面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-Process-Thread"><span class="toc-number">2.1.</span> <span class="toc-text">一、进程与线程 (Process &amp; Thread)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 基础概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1%EF%BC%88%E5%BF%85%E9%97%AE%EF%BC%81%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 线程同步与通信（必问！）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. 进程间通信（IPC）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Memory-Management"><span class="toc-number">2.2.</span> <span class="toc-text">二、内存管理 (Memory Management)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. 基础概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-API%E4%B8%8E%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. API与机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Message-Mechanism"><span class="toc-number">2.3.</span> <span class="toc-text">三、消息机制 (Message Mechanism)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BB%BC%E5%90%88%E4%B8%8E%E5%AE%9E%E6%88%98-C-Specific-Practical"><span class="toc-number">2.4.</span> <span class="toc-text">四、综合与实战 (C++ Specific &amp; Practical)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.5.</span> <span class="toc-text">面试建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2C"><span class="toc-number">3.</span> <span class="toc-text">腾讯一面C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA-TCP-%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E8%A6%81%E5%88%86%E5%87%A0%E6%AD%A5%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1. 开发一个 TCP 客户端，要分几步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TCP-%E5%8D%8F%E8%AE%AE%E5%85%B7%E4%BD%93%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2. TCP 协议具体是干嘛的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%B2%E8%AE%B2%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">3. 讲讲三次握手和四次挥手？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%80%E4%B8%AA-UDP-%E5%8C%85%E6%9C%80%E5%A4%9A%E8%83%BD%E8%A3%85%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">4. 一个 UDP 包最多能装多少数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">5. 结构体和模板类有啥区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Linux-%E7%9A%84-proc-%E7%9B%AE%E5%BD%95%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">6. Linux 的 &#x2F;proc 目录是干嘛的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%AF%B4%E5%87%A0%E4%B8%AA%E4%BD%A0%E7%94%A8%E8%BF%87%E7%9A%84%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">7. 说几个你用过的调试工具？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-MySQL-%E5%BC%95%E6%93%8E%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">8. MySQL 引擎是啥？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-DDoS-%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">9. DDoS 是啥？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">10. Redis 有哪些数据结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Redis-%E7%BC%93%E5%AD%98%E6%85%A2%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E6%80%8E%E4%B9%88%E5%81%9A%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">11. Redis 缓存慢了怎么办？怎么做持久化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%81%8A%E8%81%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">3.12.</span> <span class="toc-text">12. 聊聊消息队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%AF%B4%E5%87%A0%E4%B8%AA-Agent-%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-number">3.13.</span> <span class="toc-text">13. 说几个 Agent 框架？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-MCP-%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="toc-number">3.14.</span> <span class="toc-text">14. MCP 是啥？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-MCP-%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">3.15.</span> <span class="toc-text">15. MCP 用的是什么通信协议？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2C"><span class="toc-number">4.</span> <span class="toc-text">字节一面C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Http%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1. Http请求中有哪些请求方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B4%E4%B8%80%E4%B8%8BHttps%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%93%BE%E6%8E%A5%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2. 说一下Https是如何保证链接安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Https%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%E5%AF%B9%E7%A7%B0%E8%BF%98%E6%98%AF%E9%9D%9E%E5%AF%B9%E7%A7%B0%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3. Https的加密方式是怎样的？对称还是非对称？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Http%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">4. Http的状态码都有哪些，代表什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-TCP%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">5. TCP是如何实现可靠传输的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">6. 在浏览器中输入url后会发生哪些事情？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-C-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%B7%AE%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.7.</span> <span class="toc-text">7. C++指针和引用的差别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.8.</span> <span class="toc-text">8. 说一下动态链接和静态链接是什么，以及各自的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.9.</span> <span class="toc-text">9. 说一下深拷贝和浅拷贝的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E8%A7%A3%E8%80%A6%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">4.10.</span> <span class="toc-text">10. 进程通信的解耦机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%90%84%E8%87%AA%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.11.</span> <span class="toc-text">11. linux进程通信的几种方式以及各自的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8C%83%E5%BC%8F"><span class="toc-number">4.12.</span> <span class="toc-text">12. 说一下数据库的范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%90%A7"><span class="toc-number">4.13.</span> <span class="toc-text">13. 说一下多线程死锁的原因吧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E5%91%A2%EF%BC%9F"><span class="toc-number">4.14.</span> <span class="toc-text">14. 如何避免死锁呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2C"><span class="toc-number">5.</span> <span class="toc-text">百度一面C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%9A%84%E5%A4%9A%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">C++的多态是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E7%9A%84%E6%8F%92%E5%85%A5%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8Cmap%E7%9A%84%E6%8F%92%E5%85%A5%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.2.</span> <span class="toc-text">vector的插入复杂度，map的插入复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3std-move-%E5%90%97%EF%BC%9F%E2%80%A6"><span class="toc-number">5.3.</span> <span class="toc-text">了解std::move()吗？…</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3C-%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%90%97%EF%BC%9F%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">了解C++中的模板吗？实际使用过吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-sort-%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9F%E2%80%A6"><span class="toc-number">5.5.</span> <span class="toc-text">std::sort()底层使用什么排序算法？…</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E8%BF%87%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">用过多线程编程吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%B1%82%E5%92%8C%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98%E2%80%A6"><span class="toc-number">5.7.</span> <span class="toc-text">遍历求和效率问题…</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E9%9D%A2%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%9F%A5%E9%81%93%E6%9C%89%E5%87%A0%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E5%90%97%EF%BC%9F"><span class="toc-number">5.8.</span> <span class="toc-text">机器学习方面了解哪些？知道有几种优化器吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E8%82%A1%E6%96%87"><span class="toc-number">6.</span> <span class="toc-text">八股文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E4%B8%80%E4%B8%AA-C-%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%BC%9A%E5%8F%97%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">1️⃣ 一个 C++ 类的大小会受哪些因素影响？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88%E5%9C%A8%E7%B1%BB%E9%87%8C%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E5%B8%83%E7%9A%84%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">2️⃣ 虚表指针在类里是怎么分布的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%94%E6%AF%8F%E4%B8%AA%E7%88%B6%E7%B1%BB%E9%83%BD%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88%E5%A6%82%E4%BD%95%E5%88%86%E5%B8%83%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3️⃣ 多继承且每个父类都有虚函数时，内存布局和虚表指针如何分布？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E8%8B%A5%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8C%E8%B0%83%E7%94%A8%E8%87%AA%E8%BA%AB%E8%A2%AB%E6%B4%BE%E7%94%9F%E7%B1%BB%E9%87%8D%E5%86%99%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9C%80%E7%BB%88%E8%B0%83%E5%88%B0%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">4️⃣ 若基类构造函数里调用自身被派生类重写的虚函数，最终调到哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9B%B8%E6%AF%94%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">5️⃣ 虚函数调用相比普通函数有哪些性能开销？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%B8%8F%E2%83%A3-%E8%AE%B2%E4%B8%80%E4%B8%8B-C-11-%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%82"><span class="toc-number">6.6.</span> <span class="toc-text">6️⃣ 讲一下 C++11 的右值引用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%B8%8F%E2%83%A3-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%BB%E8%A6%81%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.7.</span> <span class="toc-text">7️⃣ 右值引用实现移动语义主要用来做什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%B8%8F%E2%83%A3-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%80%9A%E5%B8%B8%E6%A0%87%E8%AE%B0%E4%B8%BA-noexcept%EF%BC%9F"><span class="toc-number">6.8.</span> <span class="toc-text">8️⃣ 为什么移动构造函数通常标记为 noexcept？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%EF%B8%8F%E2%83%A3-std-forward-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.9.</span> <span class="toc-text">9️⃣ std::forward 的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%9F-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-RAII%E3%80%82"><span class="toc-number">6.10.</span> <span class="toc-text">🔟 解释一下 RAII。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A31%EF%B8%8F%E2%83%A3-RAII-%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%EF%BC%9F"><span class="toc-number">6.11.</span> <span class="toc-text">1️⃣1️⃣ RAII 与异常处理机制如何配合？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A32%EF%B8%8F%E2%83%A3-%E4%BA%86%E8%A7%A3-C-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-number">6.12.</span> <span class="toc-text">1️⃣2️⃣ 了解 C++ 的异常安全吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A33%EF%B8%8F%E2%83%A3-std-shared-ptr-%E7%AE%A1%E7%90%86%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E6%97%B6%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%87%8A%E6%94%BE%EF%BC%9F"><span class="toc-number">6.13.</span> <span class="toc-text">1️⃣3️⃣ std::shared_ptr 管理动态数组时如何正确释放？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A34%EF%B8%8F%E2%83%A3-dynamic-cast-%E4%B8%8E-static-cast-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.14.</span> <span class="toc-text">1️⃣4️⃣ dynamic_cast 与 static_cast 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A35%EF%B8%8F%E2%83%A3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">6.15.</span> <span class="toc-text">1️⃣5️⃣ 设计模式了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A36%EF%B8%8F%E2%83%A3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84-SOLID-%E5%8E%9F%E5%88%99%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F"><span class="toc-number">6.16.</span> <span class="toc-text">1️⃣6️⃣ 设计模式的 SOLID 原则清楚吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A37%EF%B8%8F%E2%83%A3-STL-%E7%9A%84-allocator-%E5%B9%B2%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">6.17.</span> <span class="toc-text">1️⃣7️⃣ STL 的 allocator 干什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A38%EF%B8%8F%E2%83%A3-vector-%E7%9A%84%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">6.18.</span> <span class="toc-text">1️⃣8️⃣ vector 的动态扩容机制是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A39%EF%B8%8F%E2%83%A3-vector-%E6%89%A9%E5%AE%B9%E5%90%8E%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E4%BD%BF%E7%94%A8-move-%E8%BF%98%E6%98%AF-copy%EF%BC%9F"><span class="toc-number">6.19.</span> <span class="toc-text">1️⃣9️⃣ vector 扩容后如何决定使用 move 还是 copy？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A30%EF%B8%8F%E2%83%A3-SFINAE-%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">6.20.</span> <span class="toc-text">2️⃣0️⃣ SFINAE 知道吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A31%EF%B8%8F%E2%83%A3-std-shared-ptr-%E7%9A%84%E6%8E%A7%E5%88%B6%E5%9D%97%E9%80%9A%E5%B8%B8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%EF%BC%9F"><span class="toc-number">6.21.</span> <span class="toc-text">2️⃣1️⃣ std::shared_ptr 的控制块通常有哪些数据成员？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A32%EF%B8%8F%E2%83%A3-%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">6.22.</span> <span class="toc-text">2️⃣2️⃣ 原子引用计数如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A33%EF%B8%8F%E2%83%A3-%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%AD%98%E6%94%BE%E4%BA%8E%E4%BD%95%E5%A4%84%EF%BC%9F"><span class="toc-number">6.23.</span> <span class="toc-text">2️⃣3️⃣ 原子引用计数存放于何处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A34%EF%B8%8F%E2%83%A3-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-number">6.24.</span> <span class="toc-text">2️⃣4️⃣ 描述一个程序的完整编译过程。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A35%EF%B8%8F%E2%83%A3-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">6.25.</span> <span class="toc-text">2️⃣5️⃣ 动态链接的大致过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A36%EF%B8%8F%E2%83%A3-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">6.26.</span> <span class="toc-text">2️⃣6️⃣ 动态链接的重定位过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A37%EF%B8%8F%E2%83%A3-ELF-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">6.27.</span> <span class="toc-text">2️⃣7️⃣ ELF 文件结构是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A38%EF%B8%8F%E2%83%A3-BSS-%E6%AE%B5%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">6.28.</span> <span class="toc-text">2️⃣8️⃣ BSS 段的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A39%EF%B8%8F%E2%83%A3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E6%8A%8A-ELF-%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%88%90%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">6.29.</span> <span class="toc-text">2️⃣9️⃣ 操作系统如何把 ELF 文件加载成进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A30%EF%B8%8F%E2%83%A3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%97%B6%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%B9%B6%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%EF%BC%9F"><span class="toc-number">6.30.</span> <span class="toc-text">3️⃣0️⃣ 系统调用时参数如何传递并进入内核？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A31%EF%B8%8F%E2%83%A3-%E7%94%A8%E6%88%B7%E6%80%81%E4%BC%A0%E9%80%92%E5%A4%A7-buffer-%E6%97%B6%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">6.31.</span> <span class="toc-text">3️⃣1️⃣ 用户态传递大 buffer 时内核如何处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A32%EF%B8%8F%E2%83%A3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">6.32.</span> <span class="toc-text">3️⃣2️⃣ 为什么操作系统使用多级页表管理虚拟内存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A33%EF%B8%8F%E2%83%A3-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%EF%BC%9F"><span class="toc-number">6.33.</span> <span class="toc-text">3️⃣3️⃣ 多级页表如何进行地址映射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A34%EF%B8%8F%E2%83%A3-%E5%8F%91%E7%94%9F%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E5%81%9A%E5%93%AA%E4%BA%9B%E4%BA%8B%EF%BC%9F"><span class="toc-number">6.34.</span> <span class="toc-text">3️⃣4️⃣ 发生缺页中断时操作系统会做哪些事？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A35%EF%B8%8F%E2%83%A3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">6.35.</span> <span class="toc-text">3️⃣5️⃣ 操作系统如何管理堆内存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A36%EF%B8%8F%E2%83%A3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%9F"><span class="toc-number">6.36.</span> <span class="toc-text">3️⃣6️⃣ 操作系统如何实现互斥锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A37%EF%B8%8F%E2%83%A3-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">6.37.</span> <span class="toc-text">3️⃣7️⃣ 如何避免死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A38%EF%B8%8F%E2%83%A3-%E6%AD%BB%E9%94%81%E5%B7%B2%E5%8F%91%E7%94%9F%E6%97%B6%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%EF%BC%9F"><span class="toc-number">6.38.</span> <span class="toc-text">3️⃣8️⃣ 死锁已发生时如何定位？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A39%EF%B8%8F%E2%83%A3-%E4%BA%86%E8%A7%A3-AddressSanitizer-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-number">6.39.</span> <span class="toc-text">3️⃣9️⃣ 了解 AddressSanitizer 的实现原理吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A30%EF%B8%8F%E2%83%A3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.40.</span> <span class="toc-text">4️⃣0️⃣ 计算机网络的五层协议有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A31%EF%B8%8F%E2%83%A3-ping-%E5%91%BD%E4%BB%A4%E5%B7%A5%E4%BD%9C%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-number">6.41.</span> <span class="toc-text">4️⃣1️⃣ ping 命令工作在哪一层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A32%EF%B8%8F%E2%83%A3-IP-%E5%8D%8F%E8%AE%AE%E5%A4%B4%E9%83%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">6.42.</span> <span class="toc-text">4️⃣2️⃣ IP 协议头部有哪些字段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A33%EF%B8%8F%E2%83%A3-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">6.43.</span> <span class="toc-text">4️⃣3️⃣ TCP 三次握手过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A34%EF%B8%8F%E2%83%A3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%A1%E6%89%8B%E4%B8%89%E6%AC%A1%E3%80%81%E6%8C%A5%E6%89%8B%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-number">6.44.</span> <span class="toc-text">4️⃣4️⃣ 为什么握手三次、挥手四次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A35%EF%B8%8F%E2%83%A3-%E6%8F%8F%E8%BF%B0-CMakeLists-txt-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E3%80%82"><span class="toc-number">6.45.</span> <span class="toc-text">4️⃣5️⃣ 描述 CMakeLists.txt 的基本结构。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%83%E5%BD%B1%E9%9A%8F%E8%A1%8CC-%E4%B8%80%E9%9D%A2"><span class="toc-number">7.</span> <span class="toc-text">心影随行C++一面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.1.</span> <span class="toc-text">volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-volatile%EF%BC%9F"><span class="toc-number">7.1.1.</span> <span class="toc-text">核心思想：为什么需要 volatile？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.1.2.</span> <span class="toc-text">volatile 到底做了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%B2%A1%E6%9C%89-volatile-%E5%AF%BC%E8%87%B4%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">7.1.3.</span> <span class="toc-text">经典示例：没有 volatile 导致的错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%81%EF%BC%89"><span class="toc-number">7.1.4.</span> <span class="toc-text">volatile 与多线程编程（非常重要！）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.1.5.</span> <span class="toc-text">volatile 的正确使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%8E-Java-C-%E4%B8%AD-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.</span> <span class="toc-text">C++ 与 Java&#x2F;C# 中 volatile 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">7.2.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%B1%E7%9F%B3%E4%B8%80%E9%9D%A2"><span class="toc-number">8.</span> <span class="toc-text">影石一面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%A0%B8%E5%BF%83"><span class="toc-number">8.1.</span> <span class="toc-text">C++ 核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL"><span class="toc-number">8.2.</span> <span class="toc-text">STL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text">智能指针 &amp; 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B"><span class="toc-number">8.4.</span> <span class="toc-text">操作系统 &amp; 系统编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">8.5.</span> <span class="toc-text">计算机网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95-%E5%85%B6%E4%BB%96"><span class="toc-number">8.6.</span> <span class="toc-text">调试 &amp; 其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%B1%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">小米面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-std-vector%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%89%A9%E5%AE%B9%E6%97%B6%E4%BB%A3%E4%BB%B7%E5%A4%9A%E5%A4%A7%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%91%E7%B9%81%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">1. std::vector的扩容机制是什么？扩容时代价多大？如何避免频繁扩容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-C-%E4%B8%ADmalloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9Fdelete%E5%92%8Cdelete-%E8%83%BD%E6%B7%B7%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">2. C++中malloc和new的区别？delete和delete[]能混用吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E6%9E%9C%E7%B1%BB%E4%B8%AD%E6%9C%89const%E6%88%90%E5%91%98%E6%88%96%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%EF%BC%8C%E8%83%BD%E5%90%A6%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">3. 如果类中有const成员或引用成员，能否自动生成移动构造函数？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">4. 什么是内存对齐？为什么需要内存对齐？如何手动控制结构体的内存对齐？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%93%AA%E7%A7%8D%E6%95%88%E7%8E%87%E6%9C%80%E9%AB%98%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">5. 进程和线程的区别？进程间通信有哪些方式？哪种效率最高？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%BA%E5%88%B6%EF%BC%9Fstd-mutex%E3%80%81std-lock-guard%E3%80%81std-unique-lock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.6.</span> <span class="toc-text">6. 线程同步有哪些机制？std::mutex、std::lock_guard、std::unique_lock的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%81%87%E5%85%B1%E4%BA%AB%EF%BC%88False-Sharing%EF%BC%89%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">9.7.</span> <span class="toc-text">7. 什么是虚假共享（False Sharing）？如何避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%89%8B%E6%92%95%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%EF%BC%88%E6%94%AF%E6%8C%81%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%89"><span class="toc-number">9.8.</span> <span class="toc-text">8. 手撕：实现一个线程安全的环形队列（支持多生产者多消费者）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Valgrind%E6%88%96ASAN%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E8%B6%8A%E7%95%8C%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">9.9.</span> <span class="toc-text">9. 如何使用Valgrind或ASAN排查内存泄漏和越界问题？你在项目中用过吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E7%94%A8GDB%E8%B0%83%E8%AF%95%E6%AD%BB%E9%94%81%EF%BC%9Fthread-apply-all-bt-%E8%BF%99%E4%B8%AA%E5%91%BD%E4%BB%A4%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">9.10.</span> <span class="toc-text">10. 如何用GDB调试死锁？thread apply all bt 这个命令有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%9F%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">9.11.</span> <span class="toc-text">11. 什么是虚函数表？多重继承下的虚函数表结构是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Epoll%E7%9A%84%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E5%92%8C%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.12.</span> <span class="toc-text">12. Epoll的水平触发和边缘触发有什么区别？使用场景是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%AE%B2%E4%B8%80%E4%B8%8BTCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6%EF%BC%9FTIME-WAIT%E7%8A%B6%E6%80%81%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.13.</span> <span class="toc-text">13. 讲一下TCP拥塞控制机制？TIME_WAIT状态的作用是什么</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/17/%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86/" title="网站管理">网站管理</a><time datetime="2025-09-17T07:16:47.000Z" title="发表于 2025-09-17 15:16:47">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/17/Qt%E6%80%9D%E8%B7%AF/" title="Qt思路">Qt思路</a><time datetime="2025-09-17T06:37:12.000Z" title="发表于 2025-09-17 14:37:12">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="网络编程笔记">网络编程笔记</a><time datetime="2025-09-17T06:21:12.000Z" title="发表于 2025-09-17 14:21:12">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/17/MySql%E7%AC%94%E8%AE%B0/" title="MySql笔记">MySql笔记</a><time datetime="2025-09-17T02:41:34.000Z" title="发表于 2025-09-17 10:41:34">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/17/C-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="C++ 面试题">C++ 面试题</a><time datetime="2025-09-17T02:35:14.000Z" title="发表于 2025-09-17 10:35:14">2025-09-17</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 贺腾</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>