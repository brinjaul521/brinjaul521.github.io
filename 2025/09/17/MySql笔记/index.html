<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySql笔记 | 贺腾的博客</title><meta name="author" content="贺腾"><meta name="copyright" content="贺腾"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Mysql索引好的，这是一个非常重要且常见的面试话题。我会从原理到实践，为你彻底讲清楚 MySQL 索引。  一、索引是什么？（本质与原理）你可以把数据库索引想象成一本书的目录。  没有索引（目录）：当你想在书中找到“索引失效”这个内容时，你只能一页一页地从头翻到尾（这叫做全表扫描），效率极低。 有索引（目录）：你可以直接查看目录，快速定位到“索引失效”内容所在的页码，然后直接翻到那一页。这个“目">
<meta property="og:type" content="article">
<meta property="og:title" content="MySql笔记">
<meta property="og:url" content="https://brinjaul521.github.io/2025/09/17/MySql%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="贺腾的博客">
<meta property="og:description" content="Mysql索引好的，这是一个非常重要且常见的面试话题。我会从原理到实践，为你彻底讲清楚 MySQL 索引。  一、索引是什么？（本质与原理）你可以把数据库索引想象成一本书的目录。  没有索引（目录）：当你想在书中找到“索引失效”这个内容时，你只能一页一页地从头翻到尾（这叫做全表扫描），效率极低。 有索引（目录）：你可以直接查看目录，快速定位到“索引失效”内容所在的页码，然后直接翻到那一页。这个“目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://brinjaul521.github.io/img/head.jpg">
<meta property="article:published_time" content="2025-09-17T02:41:34.000Z">
<meta property="article:modified_time" content="2025-09-17T03:03:59.149Z">
<meta property="article:author" content="贺腾">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://brinjaul521.github.io/img/head.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySql笔记",
  "url": "https://brinjaul521.github.io/2025/09/17/MySql%E7%AC%94%E8%AE%B0/",
  "image": "https://brinjaul521.github.io/img/head.jpg",
  "datePublished": "2025-09-17T02:41:34.000Z",
  "dateModified": "2025-09-17T03:03:59.149Z",
  "author": [
    {
      "@type": "Person",
      "name": "贺腾",
      "url": "https://brinjaul521.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://brinjaul521.github.io/2025/09/17/MySql%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySql笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta property="og:type" content="article">
<meta property="og:title" content="{{ title | default config.title }}">
<meta property="og:image" content="{{ url | append cover | default config.url | append '/img/default-cover.jpg' }}">
<meta property="og:description" content="{{ description | default excerpt | default config.description }}">
<meta property="og:url" content="{{ url }}">
<meta name="twitter:card" content="summary_large_image">
<meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/background.png);"><nav id="nav"><span id="blog-info"><a href="/" title="贺腾的博客"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">贺腾的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">MySql笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MySql笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-17T02:41:34.000Z" title="发表于 2025-09-17 10:41:34">2025-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-17T03:03:59.149Z" title="更新于 2025-09-17 11:03:59">2025-09-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>好的，这是一个非常重要且常见的面试话题。我会从原理到实践，为你彻底讲清楚 MySQL 索引。</p>
<hr>
<h3 id="一、索引是什么？（本质与原理）"><a href="#一、索引是什么？（本质与原理）" class="headerlink" title="一、索引是什么？（本质与原理）"></a>一、索引是什么？（本质与原理）</h3><p>你可以把数据库索引想象成<strong>一本书的目录</strong>。</p>
<ul>
<li><strong>没有索引（目录）</strong>：当你想在书中找到“索引失效”这个内容时，你只能一页一页地从头翻到尾（这叫做<strong>全表扫描</strong>），效率极低。</li>
<li><strong>有索引（目录）</strong>：你可以直接查看目录，快速定位到“索引失效”内容所在的<strong>页码</strong>，然后直接翻到那一页。这个“目录”就是索引，它通过建立一种高效的数据结构，避免了逐行查找。</li>
</ul>
<p><strong>技术本质：</strong><br>索引是一种<strong>排好序的快速查找数据结构</strong>。MySQL 中最常用的索引类型是 <strong>B+Tree</strong>（B+树）。</p>
<p><strong>B+Tree 的特点（为什么选它）：</strong></p>
<ol>
<li><strong>矮胖树</strong>：层级低，通常只需要 3-4 次 I&#x2F;O 操作就能从上亿条数据中定位到目标，查找效率极高。</li>
<li><strong>有序存储</strong>：叶子节点存储数据并按顺序链接，非常适合范围查询（<code>WHERE id &gt; 100</code>）和排序（<code>ORDER BY</code>）。</li>
<li><strong>数据只存储在叶子节点</strong>：非叶子节点只存键值，使得每个节点能存放更多的关键字，让树更“矮胖”。</li>
</ol>
<p><strong>索引的代价：</strong></p>
<ul>
<li><strong>空间代价</strong>：索引也是一张表，需要占用额外的磁盘空间。</li>
<li><strong>时间代价</strong>：对表进行 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作时，MySQL 不仅要操作数据，还要更新对应的索引，会降低写操作的速度。</li>
</ul>
<p><strong>因此，索引不是越多越好！</strong></p>
<hr>
<h3 id="二、在-MySQL-中如何使用索引？"><a href="#二、在-MySQL-中如何使用索引？" class="headerlink" title="二、在 MySQL 中如何使用索引？"></a>二、在 MySQL 中如何使用索引？</h3><h4 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h4><p><strong>① 创建表时创建</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),               <span class="comment">-- 主键索引，自动创建</span></span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_email` (`email`),  <span class="comment">-- 唯一索引</span></span><br><span class="line">  KEY `idx_name` (`name`),          <span class="comment">-- 普通索引</span></span><br><span class="line">  KEY `idx_age_name` (`age`, `name`) <span class="comment">-- 复合索引（最常用且最重要）</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p><strong>② 给已有表添加索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加普通索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> INDEX `idx_age` (`age`);</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX `idx_age` <span class="keyword">ON</span> `<span class="keyword">user</span>` (`age`);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加唯一索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX `uk_email` (`email`);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加复合索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> INDEX `idx_age_name` (`age`, `name`);</span><br></pre></td></tr></table></figure>

<h4 id="2-删除索引"><a href="#2-删除索引" class="headerlink" title="2. 删除索引"></a>2. 删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX `idx_age` <span class="keyword">ON</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure>

<h4 id="3-查看索引"><a href="#3-查看索引" class="headerlink" title="3. 查看索引"></a>3. 查看索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="三、有什么需要注意的？（核心注意事项）"><a href="#三、有什么需要注意的？（核心注意事项）" class="headerlink" title="三、有什么需要注意的？（核心注意事项）"></a>三、有什么需要注意的？（核心注意事项）</h3><ol>
<li><p><strong>最左前缀原则 (Leftmost Prefixing)</strong>：<br>这是<strong>复合索引</strong>最重要的原则。假设有复合索引 <code>(A, B, C)</code>，它相当于建立了 <code>(A)</code>、<code>(A, B)</code>、<code>(A, B, C)</code> 三个索引。</p>
<ul>
<li><strong>有效</strong>的查询：<br><code>WHERE A = ?</code><br><code>WHERE A = ? AND B = ?</code><br><code>WHERE A = ? AND B = ? AND C = ?</code><br><code>WHERE A = ? ORDER BY B</code></li>
<li><strong>失效</strong>的查询（不满足最左前缀）：<br><code>WHERE B = ?</code> （跳过了 A）<br><code>WHERE B = ? AND C = ?</code> （跳过了 A）<br><code>WHERE A = ? AND C = ?</code> （跳过了 B，只能用到 A 部分的索引）</li>
</ul>
</li>
<li><p><strong>避免对索引列做操作</strong>：<br>在索引列上使用函数、计算或类型转换会导致索引失效。</p>
<ul>
<li><strong>错误</strong>：<code>WHERE YEAR(create_time) = 2023</code> （索引失效）</li>
<li><strong>正确</strong>：<code>WHERE create_time &gt;= &#39;2023-01-01&#39; AND create_time &lt; &#39;2024-01-01&#39;</code> （索引有效）</li>
</ul>
</li>
<li><p><strong>Like 查询避免前导通配符</strong>：</p>
<ul>
<li><code>WHERE name LIKE &#39;abc%&#39;</code> （索引有效，走范围查询）</li>
<li><code>WHERE name LIKE &#39;%abc&#39;</code> 或 <code>WHERE name LIKE &#39;%abc%&#39;</code> （索引失效，全表扫描）</li>
</ul>
</li>
<li><p><strong>字符串索引与引号</strong>：<br>如果字段是字符串类型，查询条件必须用引号，否则会触发隐式类型转换导致索引失效。</p>
<ul>
<li><strong>错误</strong>（假设 <code>tel</code> 是 <code>varchar</code>）：<code>WHERE tel = 13800138000</code></li>
<li><strong>正确</strong>：<code>WHERE tel = &#39;13800138000&#39;</code></li>
</ul>
</li>
<li><p><strong>OR 连接条件</strong>：<br>使用 <code>OR</code> 时，如果 <code>OR</code> 前后的条件不是都有索引，那么索引会失效。</p>
<ul>
<li><strong>失效</strong>（假设 <code>age</code> 无索引）：<code>WHERE name = &#39;John&#39; OR age = 18</code></li>
<li><strong>优化</strong>：改用 <code>UNION</code> 或将 <code>age</code> 也加上索引。</li>
</ul>
</li>
<li><p><strong>选择区分度高的列建索引</strong>：<br>“区分度”是指索引列不同值的数量占总数的比例。比例越高，区分度越好，索引效率越高。</p>
<ul>
<li><strong>不适合建索引</strong>：性别（只有男&#x2F;女）、状态（0&#x2F;1）等区分度很低的字段。</li>
<li><strong>非常适合建索引</strong>：手机号、身份证号、用户名等几乎唯一的字段。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四、面试中的常考点有哪些？"><a href="#四、面试中的常考点有哪些？" class="headerlink" title="四、面试中的常考点有哪些？"></a>四、面试中的常考点有哪些？</h3><ol>
<li><p><strong>索引的本质和原理？为什么使用 B+Tree 而不是哈希表或二叉树？</strong></p>
<ul>
<li><strong>哈希表</strong>：适合等值查询，但不支持范围查询和排序，无法用于 <code>ORDER BY</code>、<code>&gt;</code>、<code>&lt;</code> 等操作。</li>
<li><strong>二叉树</strong>：在数据有序时可能会退化成链表，查询效率从 O(log n) 退化为 O(n)。B+Tree 永远是矮胖的，效率稳定。</li>
</ul>
</li>
<li><p><strong>聚簇索引和非聚簇索引的区别？</strong></p>
<ul>
<li><strong>聚簇索引（如 InnoDB 主键）</strong>：叶子节点直接存储<strong>整行数据</strong>。表数据本身就是按主键顺序存放的。一张表只有一个聚簇索引。</li>
<li><strong>非聚簇索引（如普通索引）</strong>：叶子节点存储的是该行的<strong>主键值</strong>。根据普通索引找到主键后，需要<strong>回表</strong>（通过主键再去聚簇索引里查一次）才能拿到完整数据。</li>
</ul>
</li>
<li><p><strong>什么是覆盖索引？它的好处是什么？</strong></p>
<ul>
<li><strong>定义</strong>：如果一个索引包含（覆盖）了所有需要查询的字段的值，我们就称之为覆盖索引。</li>
<li><strong>例子</strong>：表 <code>user</code> 有 <code>(id, name, age)</code> 字段和索引 <code>idx_age_name(age, name)</code>。执行 <code>SELECT name FROM user WHERE age = 20;</code>，要查询的 <code>name</code> 已经在索引 <code>idx_age_name</code> 的叶子节点上了，因此不需要回表，速度极快。</li>
<li><strong>好处</strong>：避免回表，极大提升性能。是常用的优化手段。</li>
</ul>
</li>
<li><p><strong>索引下推 (Index Condition Pushdown, ICP) (MySQL 5.6+)</strong></p>
<ul>
<li><strong>作用</strong>：在复合索引 <code>(A, B)</code> 中，对于 <code>WHERE A = ? AND B = ?</code> 的查询，旧版本会先根据 A 从存储引擎拉取所有数据，再到 Server 层用 B 条件过滤。ICP 则<strong>将 B 的过滤条件下推到存储引擎层</strong>完成，减少了不必要的回表和数据传输。</li>
<li><strong>面试官想听</strong>：你知道这个优化技术，说明你对 MySQL 的理解比较深入。</li>
</ul>
</li>
<li><p><strong>如何排查和优化慢查询？</strong></p>
<ul>
<li><strong>步骤</strong>：<ol>
<li>开启慢查询日志，找到执行慢的 SQL。</li>
<li>使用 <code>EXPLAIN</code> 关键字分析该 SQL 的执行计划。</li>
</ol>
</li>
<li><strong>看懂 <code>EXPLAIN</code> 结果</strong>：<ul>
<li><strong>type</strong>：访问类型，从好到坏：<code>const &gt; ref &gt; range &gt; index &gt; ALL</code>。<code>ALL</code> 表示全表扫描，需要优化。</li>
<li><strong>key</strong>：实际使用的索引。</li>
<li><strong>rows</strong>：预估需要扫描的行数，越小越好。</li>
<li><strong>Extra</strong>：重要信息，如 <code>Using filesort</code>（需要额外排序）、<code>Using temporary</code>（用了临时表，需优化）、<code>Using index</code>（使用了覆盖索引，非常好）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：索引是“空间换时间”的经典实践，核心目标是减少磁盘 I&#x2F;O。理解 B+Tree、最左前缀、覆盖索引和 <code>EXPLAIN</code> 命令，是掌握 MySQL 索引优化的关键。</p>
<p>好的，这是一个非常实际的问题。在 MySQL 中，索引的使用并非一个需要你手动触发的“操作”，而是一个<strong>由 MySQL 优化器自动决定的过程</strong>。</p>
<p>你的工作不是“使用”索引，而是<strong>正确地创建索引</strong>和<strong>编写能有效利用索引的 SQL 语句</strong>。优化器会根据你的 SQL、表结构、索引情况以及数据统计信息，自动选择它认为最高效的索引（或选择全表扫描）。</p>
<p>下面我们分两部分来详细解释：</p>
<hr>
<h3 id="第一部分：如何让优化器选择你的索引（如何编写索引友好的-SQL）"><a href="#第一部分：如何让优化器选择你的索引（如何编写索引友好的-SQL）" class="headerlink" title="第一部分：如何让优化器选择你的索引（如何编写索引友好的 SQL）"></a>第一部分：如何让优化器选择你的索引（如何编写索引友好的 SQL）</h3><p>这是“使用”索引的核心。你需要遵循一系列规则来编写查询，让优化器“愿意”并且“能够”使用索引。</p>
<h4 id="1-满足最左前缀原则（针对复合索引）"><a href="#1-满足最左前缀原则（针对复合索引）" class="headerlink" title="1. 满足最左前缀原则（针对复合索引）"></a>1. 满足最左前缀原则（针对复合索引）</h4><p>这是最重要的一条规则。如果你有一个复合索引 <code>(last_name, first_name)</code>，那么以下查询能利用到索引：</p>
<ul>
<li><code>WHERE last_name = &#39;Smith&#39;</code> ✅ （使用索引的第一部分）</li>
<li><code>WHERE last_name = &#39;Smith&#39; AND first_name = &#39;John&#39;</code> ✅ （使用索引的全部）</li>
<li><code>WHERE last_name = &#39;Smith&#39; AND first_name LIKE &#39;J%&#39;</code> ✅ （范围查询，只使用到 <code>first_name</code>）</li>
</ul>
<p>而以下查询则<strong>无法</strong>使用这个复合索引，或者只能部分使用：</p>
<ul>
<li><code>WHERE first_name = &#39;John&#39;</code> ❌ （跳过了最左边的 <code>last_name</code>）</li>
<li><code>WHERE last_name = &#39;Smith&#39; OR first_name = &#39;John&#39;</code> ❌ （<code>OR</code> 通常导致索引失效）</li>
</ul>
<h4 id="2-避免在索引列上进行计算或使用函数"><a href="#2-避免在索引列上进行计算或使用函数" class="headerlink" title="2. 避免在索引列上进行计算或使用函数"></a>2. 避免在索引列上进行计算或使用函数</h4><p>这会让索引失效，因为优化器无法直接使用计算后的值去索引树中查找。</p>
<ul>
<li><p><strong>错误示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(birth_date) <span class="operator">=</span> <span class="number">1990</span>; <span class="comment">-- 对索引列使用函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">*</span> <span class="number">0.8</span> <span class="operator">&gt;</span> <span class="number">100</span>; <span class="comment">-- 对索引列进行计算</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>正确示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> birth_date <span class="operator">&gt;=</span> <span class="string">&#x27;1990-01-01&#x27;</span> <span class="keyword">AND</span> birth_date <span class="operator">&lt;</span> <span class="string">&#x27;1991-01-01&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">100</span> <span class="operator">/</span> <span class="number">0.8</span>; <span class="comment">-- 将计算移到等号另一边</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-谨慎使用-LIKE-查询"><a href="#3-谨慎使用-LIKE-查询" class="headerlink" title="3. 谨慎使用 LIKE 查询"></a>3. 谨慎使用 LIKE 查询</h4><ul>
<li><code>WHERE name LIKE &#39;abc%&#39;</code> ✅ （索引有效，走范围查询）</li>
<li><code>WHERE name LIKE &#39;%abc&#39;</code> ❌ （索引失效，全表扫描）</li>
<li><code>WHERE name LIKE &#39;%abc%&#39;</code> ❌ （索引失效，全表扫描）<ul>
<li><em>对于这种需求，可以考虑使用 MySQL 的全文索引（FULLTEXT）或专业的搜索引擎（如 Elasticsearch）。</em></li>
</ul>
</li>
</ul>
<h4 id="4-注意数据类型和隐式转换"><a href="#4-注意数据类型和隐式转换" class="headerlink" title="4. 注意数据类型和隐式转换"></a>4. 注意数据类型和隐式转换</h4><p>如果索引列是字符串类型（如 <code>VARCHAR</code>），但查询条件使用数字，MySQL 会进行隐式类型转换，导致索引失效。</p>
<ul>
<li><p><strong>错误示例</strong>（假设 <code>phone</code> 是 <code>VARCHAR</code> 类型）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="number">13800138000</span>; <span class="comment">-- 数字被隐式转成字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>正确示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="string">&#x27;13800138000&#x27;</span>; <span class="comment">-- 类型匹配</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-使用覆盖索引-Covering-Index"><a href="#5-使用覆盖索引-Covering-Index" class="headerlink" title="5. 使用覆盖索引 (Covering Index)"></a>5. 使用覆盖索引 (Covering Index)</h4><p>这是一种高级优化技巧。如果一个索引包含了查询所需要的所有字段，MySQL 就只需要读取索引而无需回表查询数据行，速度极快。</p>
<ul>
<li><p><strong>表结构</strong>：<code>users (id, name, age, city)</code></p>
</li>
<li><p><strong>索引</strong>：<code>INDEX idx_name_city (name, city)</code></p>
</li>
<li><p><strong>查询</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 需要回表：SELECT * 需要所有字段，索引不包含 `age`</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 覆盖索引：要查询的 name 和 city 都在索引 idx_name_city 中</span></span><br><span class="line"><span class="keyword">SELECT</span> name, city <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>; </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第二部分：如何验证索引是否被使用"><a href="#第二部分：如何验证索引是否被使用" class="headerlink" title="第二部分：如何验证索引是否被使用"></a>第二部分：如何验证索引是否被使用</h3><p>你不能凭感觉猜测，必须通过工具来验证优化器是否以及如何使用了索引。最强大的工具就是 <strong><code>EXPLAIN</code></strong> 命令。</p>
<h4 id="如何使用-EXPLAIN"><a href="#如何使用-EXPLAIN" class="headerlink" title="如何使用 EXPLAIN"></a>如何使用 EXPLAIN</h4><p>在你的 SQL 语句前加上 <code>EXPLAIN</code> 关键字即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span> <span class="keyword">AND</span> first_name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="如何解读-EXPLAIN-结果（关注以下几个关键列）："><a href="#如何解读-EXPLAIN-结果（关注以下几个关键列）：" class="headerlink" title="如何解读 EXPLAIN 结果（关注以下几个关键列）："></a>如何解读 EXPLAIN 结果（关注以下几个关键列）：</h4><table>
<thead>
<tr>
<th align="left">列名</th>
<th align="left">说明</th>
<th align="left">期望值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>type</strong></td>
<td align="left"><strong>访问类型</strong>，表示如何查找数据。</td>
<td align="left"><code>const</code> &gt; <code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code>。<strong>至少要是 <code>range</code>，最好能达到 <code>ref</code>。<code>ALL</code> 表示全表扫描，需要优化。</strong></td>
</tr>
<tr>
<td align="left"><strong>possible_keys</strong></td>
<td align="left"><strong>可能用到的索引</strong>。</td>
<td align="left">列出了你的查询<strong>可能</strong>会使用的索引。</td>
</tr>
<tr>
<td align="left"><strong>key</strong></td>
<td align="left"><strong>实际使用的索引</strong>。</td>
<td align="left">这是最重要的信息之一。如果为 <code>NULL</code>，说明没有使用索引。这里显示了优化器最终选择的索引名。</td>
</tr>
<tr>
<td align="left"><strong>key_len</strong></td>
<td align="left"><strong>使用的索引长度</strong>。</td>
<td align="left">用于判断复合索引中有多少部分被真正用到了。数值越大，使用的索引部分越多。</td>
</tr>
<tr>
<td align="left"><strong>rows</strong></td>
<td align="left"><strong>预估需要扫描的行数</strong>。</td>
<td align="left">一个非常重要的性能指标。数值越小越好。</td>
</tr>
<tr>
<td align="left"><strong>Extra</strong></td>
<td align="left"><strong>额外信息</strong>。</td>
<td align="left"><code>Using index</code>: 使用了<strong>覆盖索引</strong>，性能极佳。 <br> <code>Using where</code>: 在存储引擎检索行后进行了过滤。 <br> <code>Using filesort</code>: 需要额外的排序操作（性能差）。 <br> <code>Using temporary</code>: 需要创建临时表（性能极差）。</td>
</tr>
</tbody></table>
<p><strong>示例分析：</strong><br>如果你的 <code>EXPLAIN</code> 结果中 <code>key</code> 列是 <code>NULL</code>，<code>type</code> 是 <code>ALL</code>，就说明你的查询没有用到索引，正在执行全表扫描。你需要检查你的 SQL 是否违反了上述规则，或者考虑为查询条件创建新的索引。</p>
<hr>
<h3 id="总结：索引使用流程"><a href="#总结：索引使用流程" class="headerlink" title="总结：索引使用流程"></a>总结：索引使用流程</h3><ol>
<li><strong>设计阶段</strong>：根据业务查询需求，在<strong>区分度高</strong>的列上创建合适的索引（单列或复合索引）。</li>
<li><strong>编码阶段</strong>：编写 SQL 时，时刻注意<strong>最左前缀、避免计算&#x2F;函数、注意 LIKE 用法和类型匹配</strong>，确保语句是“索引友好”的。</li>
<li><strong>验证阶段</strong>：使用 <strong><code>EXPLAIN</code></strong> 命令分析你的关键查询语句，确认索引是否被有效使用。</li>
<li><strong>调优阶段</strong>：根据 <code>EXPLAIN</code> 的结果，要么修改 SQL 语句，要么调整索引设计（如创建更合适的复合索引或利用覆盖索引），不断迭代优化。</li>
</ol>
<p>记住，索引不是银弹。它的目标是减少需要扫描的数据量。你的职责就是通过良好的设计和正确的 SQL，为优化器提供最好的选择。</p>
<h1 id="MySQL-索引笔试题"><a href="#MySQL-索引笔试题" class="headerlink" title="MySQL 索引笔试题"></a>MySQL 索引笔试题</h1><h2 id="题目：员工信息查询优化"><a href="#题目：员工信息查询优化" class="headerlink" title="题目：员工信息查询优化"></a>题目：员工信息查询优化</h2><p>假设有一个员工表 <code>employees</code>，结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    first_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    last_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    department_id <span class="type">INT</span>,</span><br><span class="line">    salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    hire_date <span class="type">DATE</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>表中有 1000 万条员工记录。</p>
<p>请优化以下查询，使其在毫秒级别返回结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询1: 查找特定部门的员工并按薪资排序</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name, salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">5</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span> </span><br><span class="line">LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询2: 查找特定姓氏的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name, email </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询3: 查找薪资范围在特定区间的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name, department_id, salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> <span class="number">50000</span> <span class="keyword">AND</span> <span class="number">80000</span> </span><br><span class="line"><span class="keyword">AND</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;2020-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ol>
<li>应该创建哪些索引来优化这些查询？</li>
<li>请写出创建这些索引的 SQL 语句。</li>
<li>解释为什么这些索引能提高查询性能。</li>
<li>在什么情况下，即使有索引，查询性能可能仍然不佳？</li>
</ol>
<hr>
<h2 id="解答与解释"><a href="#解答与解释" class="headerlink" title="解答与解释"></a>解答与解释</h2><h3 id="1-应该创建的索引及创建语句"><a href="#1-应该创建的索引及创建语句" class="headerlink" title="1. 应该创建的索引及创建语句"></a>1. 应该创建的索引及创建语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 针对查询1: 部门ID和薪资的复合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_department_salary <span class="keyword">ON</span> employees(department_id, salary <span class="keyword">DESC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 针对查询2: 姓氏的单列索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_last_name <span class="keyword">ON</span> employees(last_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 针对查询3: 薪资和入职日期的复合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_salary_hire_date <span class="keyword">ON</span> employees(salary, hire_date);</span><br></pre></td></tr></table></figure>

<h3 id="2-为什么这些索引能提高查询性能"><a href="#2-为什么这些索引能提高查询性能" class="headerlink" title="2. 为什么这些索引能提高查询性能"></a>2. 为什么这些索引能提高查询性能</h3><p><strong>查询1优化原理：</strong></p>
<ul>
<li>索引 <code>(department_id, salary DESC)</code> 首先按部门ID排序，然后在每个部门内按薪资降序排列</li>
<li>查询时可以直接定位到部门5，并读取前10条记录（薪资最高的），无需全表扫描和额外排序</li>
<li>这是一个”覆盖索引”，包含了查询所需的所有字段，无需回表</li>
</ul>
<p><strong>查询2优化原理：</strong></p>
<ul>
<li>索引 <code>(last_name)</code> 将所有相同姓氏的员工记录物理上存储在一起</li>
<li>查询时可以直接定位到所有姓氏为’Smith’的记录，无需全表扫描</li>
<li>如果创建为覆盖索引 <code>(last_name, first_name, email)</code>，性能会更佳</li>
</ul>
<p><strong>查询3优化原理：</strong></p>
<ul>
<li>索引 <code>(salary, hire_date)</code> 首先按薪资排序，然后在相同薪资下按入职日期排序</li>
<li>查询时可以直接定位到薪资在50000-80000范围内的记录，并进一步过滤入职日期</li>
<li>范围查询 <code>BETWEEN</code> 和 <code>&gt;</code> 都能有效利用索引</li>
</ul>
<h3 id="3-索引可能失效的情况"><a href="#3-索引可能失效的情况" class="headerlink" title="3. 索引可能失效的情况"></a>3. 索引可能失效的情况</h3><p>即使创建了合适的索引，以下情况仍可能导致性能问题：</p>
<ol>
<li><p><strong>数据分布不均匀</strong>：</p>
<ul>
<li>如果某个部门有大量员工（如90%的员工都在部门5），MySQL可能认为全表扫描比使用索引更高效</li>
</ul>
</li>
<li><p><strong>函数或表达式操作</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引失效</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">LOWER</span>(last_name) <span class="operator">=</span> <span class="string">&#x27;smith&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">+</span> <span class="number">1000</span> <span class="operator">&gt;</span> <span class="number">60000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>模糊查询以通配符开头</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引失效</span></span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%mith&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>OR条件使用不当</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果hire_date没有索引，整个查询可能无法使用索引</span></span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> <span class="number">50000</span> <span class="keyword">AND</span> <span class="number">80000</span> <span class="keyword">OR</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;2020-01-01&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>索引列类型不匹配</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果department_id是字符串类型但查询使用数字</span></span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">5</span> <span class="comment">-- 应使用 WHERE department_id = &#x27;5&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>统计信息过时</strong>：</p>
<ul>
<li>当表数据发生重大变化后，索引统计信息可能不准确，导致优化器选择错误的执行计划</li>
</ul>
</li>
<li><p><strong>内存不足</strong>：</p>
<ul>
<li>如果InnoDB缓冲池太小，无法缓存索引，会导致频繁磁盘I&#x2F;O，降低查询速度</li>
</ul>
</li>
</ol>
<h3 id="4-高级优化技巧"><a href="#4-高级优化技巧" class="headerlink" title="4. 高级优化技巧"></a>4. 高级优化技巧</h3><p>除了创建基本索引外，还可以考虑：</p>
<ol>
<li><p><strong>使用覆盖索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为查询2创建覆盖索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_last_name_covering <span class="keyword">ON</span> employees(last_name, first_name, email);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>索引条件下推(ICP)</strong>：</p>
<ul>
<li>MySQL 5.6+ 自动支持，确保使用的是支持ICP的存储引擎（如InnoDB）</li>
</ul>
</li>
<li><p><strong>定期分析表</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> employees;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>监控索引使用情况</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查哪些索引未被使用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_unused_indexes;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="面试考点总结"><a href="#面试考点总结" class="headerlink" title="面试考点总结"></a>面试考点总结</h2><p>这道题考察了以下知识点：</p>
<ol>
<li><strong>索引设计能力</strong>：能否根据查询模式设计合适的索引</li>
<li><strong>复合索引理解</strong>：理解最左前缀原则和列顺序的重要性</li>
<li><strong>覆盖索引概念</strong>：理解如何避免回表操作</li>
<li><strong>索引失效场景</strong>：了解各种导致索引失效的情况</li>
<li><strong>执行计划分析</strong>：隐含了对EXPLAIN命令的理解</li>
<li><strong>实际优化经验</strong>：体现出是否有真实的数据库优化经验</li>
</ol>
<p>通过这样的题目，面试官可以全面评估候选人对MySQL索引原理和实际应用的理解程度。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>好的，这是一个非常核心的数据库概念。我会为你彻底讲清楚 MySQL 的事务。</p>
<hr>
<h3 id="一、事务是什么？"><a href="#一、事务是什么？" class="headerlink" title="一、事务是什么？"></a>一、事务是什么？</h3><p><strong>事务（Transaction）</strong> 是数据库操作的最小逻辑工作单元，它包含一个或多个 SQL 语句。事务的核心特性是，它内部的所有操作<strong>要么全部成功，要么全部失败</strong>，不存在中间状态。</p>
<p>一个经典的例子就是<strong>银行转账</strong>：<br>从A账户向B账户转账100元，这个操作包含两个步骤：</p>
<ol>
<li><code>UPDATE</code>：A账户余额 -100</li>
<li><code>UPDATE</code>：B账户余额 +100</li>
</ol>
<p>这两个步骤必须作为一个不可分割的整体。如果第一步成功而第二步失败，那么100元就凭空消失了，这绝对是无法接受的。事务就是为了保证这类操作的原子性而存在的。</p>
<hr>
<h3 id="二、事务用来解决什么问题？（ACID特性）"><a href="#二、事务用来解决什么问题？（ACID特性）" class="headerlink" title="二、事务用来解决什么问题？（ACID特性）"></a>二、事务用来解决什么问题？（ACID特性）</h3><p>事务通过其著名的 <strong>ACID</strong> 特性来解决数据一致性和可靠性问题：</p>
<ol>
<li><p><strong>原子性（Atomicity）</strong></p>
<ul>
<li><strong>定义</strong>：事务是一个不可分割的工作单位，事务中的所有操作要么都发生，要么都不发生。</li>
<li><strong>如何保证</strong>：通过 MySQL 的 <strong>Undo Log（回滚日志）</strong> 实现。如果事务失败或执行了 <code>ROLLBACK</code>，MySQL 会利用 Undo Log 将数据恢复到事务开始前的状态。</li>
</ul>
</li>
<li><p><strong>一致性（Consistency）</strong></p>
<ul>
<li><strong>定义</strong>：事务必须使数据库从一个一致性状态变换到另一个一致性状态。转账前后，两个账户的总金额应该保持不变。</li>
<li><strong>如何保证</strong>：一致性是原子性、隔离性、持久性的最终目的，需要应用层和数据库层共同来保证。</li>
</ul>
</li>
<li><p><strong>隔离性（Isolation）</strong></p>
<ul>
<li><strong>定义</strong>：一个事务的执行不能被其他事务干扰。并发执行的各个事务之间不能互相干扰。</li>
<li><strong>如何保证</strong>：通过 MySQL 的<strong>锁机制</strong>和 <strong>MVCC（多版本并发控制）</strong> 实现。这也是事务中最复杂的一部分，衍生出了不同的“隔离级别”。</li>
</ul>
</li>
<li><p><strong>持久性（Durability）</strong></p>
<ul>
<li><strong>定义</strong>：一旦事务被提交（<code>COMMIT</code>），它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li>
<li><strong>如何保证</strong>：通过 MySQL 的 <strong>Redo Log（重做日志）</strong> 实现。事务提交时，会先将数据变更写入 Redo Log。即使系统崩溃，重启后也能根据 Redo Log 重新恢复数据。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、事务机制有哪些？（重点：隔离级别与并发问题）"><a href="#三、事务机制有哪些？（重点：隔离级别与并发问题）" class="headerlink" title="三、事务机制有哪些？（重点：隔离级别与并发问题）"></a>三、事务机制有哪些？（重点：隔离级别与并发问题）</h3><p>为了保证隔离性，MySQL 提供了不同的事务隔离级别。级别越低，并发性能越高，但可能出现的并发问题越多。</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>READ UNCOMMITTED（读未提交）</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">性能最高，但允许读取其他事务未提交的数据，几乎没有任何隔离性。</td>
</tr>
<tr>
<td align="left"><strong>READ COMMITTED（读已提交）</strong></td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">只能读取到其他事务已提交的数据。解决了脏读。<strong>Oracle&#x2F;PostgreSQL 默认级别</strong>。</td>
</tr>
<tr>
<td align="left"><strong>REPEATABLE READ（可重复读）</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">同一事务中多次读取同一数据的结果是一致的。解决了脏读和不可重复读。<strong>MySQL InnoDB 默认级别</strong>。</td>
</tr>
<tr>
<td align="left"><strong>SERIALIZABLE（串行化）</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">性能最低，完全串行执行，无任何并发问题。解决了所有问题。</td>
</tr>
</tbody></table>
<p><strong>对应的并发问题解释：</strong></p>
<ul>
<li><strong>脏读（Dirty Read）</strong>：事务A读到了事务B<strong>未提交</strong>的数据。如果事务B后来回滚了，那么A读到的就是无效的“脏数据”。</li>
<li><strong>不可重复读（Non-repeatable Read）</strong>：在同一个事务A中，多次读取同一数据，但由于事务B在期间<strong>修改并提交</strong>了该数据，导致事务A两次读取的结果不一致。</li>
<li><strong>幻读（Phantom Read）</strong>：在同一个事务A中，多次按相同条件查询，但由于事务B在期间<strong>新增或删除</strong>了符合条件的数据并提交，导致事务A两次查询到的<strong>记录行数</strong>不一致。（注意与不可重复读的区别：幻读侧重于数据行数的变化，不可重复读侧重于数据内容的变化）。</li>
</ul>
<p><strong>InnoDB 在 REPEATABLE READ 级别下通过 Next-Key Lock 锁算法已经很大程度上避免了幻读。</strong></p>
<hr>
<h3 id="四、怎么用事务？（语法与示例）"><a href="#四、怎么用事务？（语法与示例）" class="headerlink" title="四、怎么用事务？（语法与示例）"></a>四、怎么用事务？（语法与示例）</h3><h4 id="1-查看和设置事务隔离级别"><a href="#1-查看和设置事务隔离级别" class="headerlink" title="1. 查看和设置事务隔离级别"></a>1. 查看和设置事务隔离级别</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前会话隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction_isolation</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看全局隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.transaction_isolation;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置当前会话的隔离级别为 READ COMMITTED</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置全局隔离级别（需要权限）</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br></pre></td></tr></table></figure>

<h4 id="2-显式使用事务（标准写法）"><a href="#2-显式使用事务（标准写法）" class="headerlink" title="2. 显式使用事务（标准写法）"></a>2. 显式使用事务（标准写法）</h4><p>使用 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 开始一个事务，然后用 <code>COMMIT</code> 提交或 <code>ROLLBACK</code> 回滚。</p>
<p><strong>银行转账示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 开启事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 执行一系列SQL操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100.00</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- A账户减100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100.00</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">2</span>; <span class="comment">-- B账户加100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 根据业务逻辑判断成功与否</span></span><br><span class="line"><span class="comment">-- 假设这里有一些程序逻辑检查是否成功...</span></span><br><span class="line"><span class="comment">-- 如果一切正常，提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果发生错误（例如余额不足、数据库异常等），回滚事务</span></span><br><span class="line"><span class="comment">-- ROLLBACK;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-隐式事务-AutoCommit"><a href="#3-隐式事务-AutoCommit" class="headerlink" title="3. 隐式事务 (AutoCommit)"></a>3. 隐式事务 (AutoCommit)</h4><p>MySQL 默认开启了 <code>AUTOCOMMIT</code> 模式，这意味着<strong>每一条单独的 SQL 语句都是一个独立的事务</strong>，执行成功后会自动提交。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 AUTOCOMMIT 状态</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>; <span class="comment">-- 通常为 1（开启）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭自动提交（不推荐，容易忘记手动提交）</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 之后的所有操作都需要显式地 COMMIT 才会生效</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">1000</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>; <span class="comment">-- 必须手动提交</span></span><br></pre></td></tr></table></figure>

<p><strong>最佳实践：始终使用显式事务（<code>START TRANSACTION ... COMMIT/ROLLBACK</code>）来包裹多个相关的 SQL 操作，并保持 <code>AUTOCOMMIT=1</code>（默认）。</strong></p>
<hr>
<h3 id="五、在编程中如何使用（以-Python-为例）"><a href="#五、在编程中如何使用（以-Python-为例）" class="headerlink" title="五、在编程中如何使用（以 Python 为例）"></a>五、在编程中如何使用（以 Python 为例）</h3><p>在实际应用开发中，我们通常使用 try…catch… 结构来确保事务的正确提交和回滚。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;user&#x27;</span>, password=<span class="string">&#x27;pass&#x27;</span>, database=<span class="string">&#x27;test_db&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">        <span class="comment"># 开启事务</span></span><br><span class="line">        conn.begin()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行SQL操作</span></span><br><span class="line">        sql_1 = <span class="string">&quot;UPDATE accounts SET balance = balance - %s WHERE user_id = %s&quot;</span></span><br><span class="line">        cursor.execute(sql_1, (<span class="number">100.00</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        sql_2 = <span class="string">&quot;UPDATE accounts SET balance = balance + %s WHERE user_id = %s&quot;</span></span><br><span class="line">        cursor.execute(sql_2, (<span class="number">100.00</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ... 这里可以添加业务逻辑检查 ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 所有操作成功，提交事务</span></span><br><span class="line">        conn.commit()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Transfer successful!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 发生任何错误，回滚事务</span></span><br><span class="line">    conn.rollback()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Transfer failed: <span class="subst">&#123;e&#125;</span>. Rolling back.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 关闭连接</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">方面</th>
<th align="left">要点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>是什么</strong></td>
<td align="left">一个不可分割的逻辑工作单元（一组SQL）。</td>
</tr>
<tr>
<td align="left"><strong>为什么</strong></td>
<td align="left">保证数据的<strong>ACID</strong>特性，尤其在并发环境下维持数据一致性。</td>
</tr>
<tr>
<td align="left"><strong>核心机制</strong></td>
<td align="left"><strong>Undo Log</strong>（保证原子性）、<strong>Redo Log</strong>（保证持久性）、<strong>锁和MVCC</strong>（保证隔离性）。</td>
</tr>
<tr>
<td align="left"><strong>怎么用</strong></td>
<td align="left"><code>START TRANSACTION;</code> -&gt; <code>[SQL...]</code> -&gt; <code>COMMIT;</code> &#x2F; <code>ROLLBACK;</code></td>
</tr>
<tr>
<td align="left"><strong>编程关键</strong></td>
<td align="left">使用 <strong>try(commit)…catch(rollback)…</strong> 结构确保异常时能回滚。</td>
</tr>
</tbody></table>
<p>理解并正确使用事务，是编写可靠、健壮数据库应用程序的基石。</p>
<h1 id="数据库中表中数据改变时，索引，临时表，复制表会发生什么变化"><a href="#数据库中表中数据改变时，索引，临时表，复制表会发生什么变化" class="headerlink" title="数据库中表中数据改变时，索引，临时表，复制表会发生什么变化"></a>数据库中表中数据改变时，索引，临时表，复制表会发生什么变化</h1><p>非常好且深入的问题！这触及了数据库内部运作的核心机制。当表中数据发生变化（INSERT, UPDATE, DELETE）时，数据库的各个组件会协同工作以保证数据的一致性、完整性和性能。</p>
<p>下面我们分别详细解释索引、临时表和复制表会发生的变化。</p>
<hr>
<h3 id="1-索引的变化"><a href="#1-索引的变化" class="headerlink" title="1. 索引的变化"></a>1. 索引的变化</h3><p>索引的核心作用是<strong>快速定位数据</strong>。当底层数据发生变化时，所有相关的索引<strong>必须同步更新</strong>以反映最新的数据状态，否则索引将失效并指向错误的数据。</p>
<h4 id="具体行为："><a href="#具体行为：" class="headerlink" title="具体行为："></a>具体行为：</h4><ul>
<li><p><strong>INSERT (插入)</strong>：</p>
<ul>
<li>向表中插入一条新记录。</li>
<li>数据库会<strong>为这条新记录的所有被索引的列，在对应的索引结构（如B+Tree）中插入新的键值对</strong>。</li>
<li>例如，如果你在 <code>users</code> 表的 <code>email</code> 列上有唯一索引，插入新用户时，数据库会尝试将新的 <code>email</code> 值添加到索引中。如果值已存在，则会违反唯一性约束，插入操作被回滚。</li>
</ul>
</li>
<li><p><strong>UPDATE (更新)</strong>：</p>
<ul>
<li>如果更新操作<strong>涉及到了被索引的列</strong>，数据库会将其视为一次 <strong><code>DELETE</code> + <code>INSERT</code></strong> 的组合。<ol>
<li><strong>删除旧值</strong>：在索引中找到并<strong>移除</strong>旧的键值（指向旧数据的指针）。</li>
<li><strong>插入新值</strong>：将<strong>新的键值</strong>插入到索引中。</li>
</ol>
</li>
<li>例如，更新一个员工的部门ID (<code>department_id</code>)，而 <code>department_id</code> 列上有索引。那么旧 <code>department_id</code> 对应的索引条目会被删除，新 <code>department_id</code> 的索引条目会被创建。</li>
<li>如果更新操作<strong>没有修改任何被索引的列</strong>，则索引<strong>无需任何改变</strong>。</li>
</ul>
</li>
<li><p><strong>DELETE (删除)</strong>：</p>
<ul>
<li>从表中删除一条记录。</li>
<li>数据库会<strong>在所有相关的索引中查找并删除</strong>指向这条记录的键值对，释放索引空间。</li>
<li>在某些数据库（如MySQL的InnoDB）中，删除操作可能不会立即释放索引空间，而是将其标记为“可重用”，以便未来的插入操作使用。</li>
</ul>
</li>
</ul>
<h4 id="核心影响："><a href="#核心影响：" class="headerlink" title="核心影响："></a>核心影响：</h4><ul>
<li><strong>性能开销</strong>：索引虽然极大地加快了读操作（SELECT）的速度，但<strong>会明显减慢写操作（INSERT, UPDATE, DELETE）的速度</strong>。因为每次写操作都意味着要更新一个或多个索引。这就是为什么<strong>不能盲目创建索引</strong>的原因，需要在读性能和写性能之间取得平衡。</li>
<li><strong>事务性</strong>：索引的更新与数据的更新在<strong>同一个事务</strong>中进行。这意味着如果事务回滚，对索引的修改也会被回滚，保证了数据与索引的绝对一致性。</li>
</ul>
<hr>
<h3 id="2-临时表的变化"><a href="#2-临时表的变化" class="headerlink" title="2. 临时表的变化"></a>2. 临时表的变化</h3><p>临时表（Temporary Table）的生命周期仅限于<strong>当前会话</strong>或<strong>当前事务</strong>。它们通常用于存储中间计算结果。</p>
<h4 id="具体行为：-1"><a href="#具体行为：-1" class="headerlink" title="具体行为："></a>具体行为：</h4><ul>
<li><strong>作用域</strong>：临时表的变化（数据变更）<strong>完全隔离</strong>，仅对创建它的当前会话可见。其他会话无法看到或访问这个临时表及其数据，即使它们同名。</li>
<li><strong>数据变更</strong>：<ul>
<li>对临时表的 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 操作<strong>只影响当前会话中的临时数据</strong>。</li>
<li>这些操作<strong>通常不会产生重做日志（Redo Log）</strong>，因为临时数据不需要持久化（数据库崩溃后无需恢复）。这使其速度比普通表更快。</li>
<li>但是，它们可能会产生<strong>撤销日志（Undo Log）</strong> 以支持事务回滚（如果临时表定义在事务中）。</li>
</ul>
</li>
<li><strong>生命周期</strong>：<ul>
<li><strong>事务级临时表</strong>（如Oracle的 <code>ON COMMIT DELETE ROWS</code>）：数据在事务提交（COMMIT）或回滚（ROLLBACK）后<strong>自动清空</strong>。</li>
<li><strong>会话级临时表</strong>（如MySQL、SQL Server的默认行为）：数据在整个会话期间存在，直到<strong>会话结束</strong>或执行 <code>DROP TABLE</code> 时自动清除。</li>
</ul>
</li>
<li><strong>索引</strong>：临时表也可以创建索引。对这些索引的更新规则与普通表索引完全相同，但所有这些操作都发生在临时空间里，与会外隔离。</li>
</ul>
<p><strong>总结：临时表的变化是私有的、临时的，且通常不产生持久化日志，因此速度快，常用于复杂查询的中间步骤或存储过程。</strong></p>
<hr>
<h3 id="3-复制表的变化（主从复制场景）"><a href="#3-复制表的变化（主从复制场景）" class="headerlink" title="3. 复制表的变化（主从复制场景）"></a>3. 复制表的变化（主从复制场景）</h3><p>这里的“复制表”通常指的是在<strong>主从复制（Replication）</strong> 架构中，主库上的表发生变化后，如何同步到从库上的对应表。</p>
<h4 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h4><ol>
<li><p><strong>主库变更</strong>：</p>
<ul>
<li>在主库上执行 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>。</li>
<li>主库在<strong>提交事务之前</strong>，会将这些数据变更操作（例如：<code>UPDATE users SET name=&#39;foo&#39; WHERE id=1;</code>）<strong>记录到二进制日志（Binary Log, Binlog）中</strong>。</li>
</ul>
</li>
<li><p><strong>传输日志</strong>：</p>
<ul>
<li>主库的 <strong>Binlog Dump 线程</strong> 会将Binlog中的内容发送给从库的 <strong>I&#x2F;O Thread</strong>。</li>
</ul>
</li>
<li><p><strong>从库中继</strong>：</p>
<ul>
<li>从库的 <strong>I&#x2F;O Thread</strong> 接收到Binlog事件后，将其写入到本地的<strong>中继日志（Relay Log）</strong> 中。</li>
</ul>
</li>
<li><p><strong>从库重放</strong>：</p>
<ul>
<li>从库的 <strong>SQL Thread</strong> 读取Relay Log中的事件，并<strong>在从库上完全重演（Replay）一遍相同的SQL语句</strong>（默认基于语句的复制）或应用相同的数据变更（基于行的复制）。</li>
<li><strong>正是在这个重放过程中，从库上的表数据发生了变化</strong>。这个重放操作也会触发从库上相关索引的更新，过程与主库一致。</li>
</ul>
</li>
</ol>
<h4 id="核心影响与特点："><a href="#核心影响与特点：" class="headerlink" title="核心影响与特点："></a>核心影响与特点：</h4><ul>
<li><strong>延迟</strong>：由于传输和重放需要时间，从库的数据变化会<strong>晚于主库</strong>，这被称为<strong>复制延迟（Replication Lag）</strong>。</li>
<li><strong>一致性</strong>：最终，从库上的数据会与主库保持一致（最终一致性）。</li>
<li><strong>级联更新</strong>：如果从库自身也有它的从库（级联复制），那么当SQL线程重放完成变更后，从库会将自己收到的变更<strong>继续记录到自己的Binlog中</strong>，从而传递给下一级的从库。</li>
</ul>
<hr>
<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">数据变更时发生的行为</th>
<th align="left">核心特点与影响</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>索引</strong></td>
<td align="left"><strong>同步更新</strong>。为新的数据项创建索引条目，为旧的数据项删除索引条目。</td>
<td align="left"><strong>保证查询性能</strong>。<strong>增加写操作开销</strong>。更新是<strong>事务性</strong>的。</td>
</tr>
<tr>
<td align="left"><strong>临时表</strong></td>
<td align="left"><strong>仅在当前会话&#x2F;事务中变化</strong>。数据操作<strong>私有且隔离</strong>，通常<strong>不产生重做日志</strong>。</td>
<td align="left"><strong>生命周期短</strong>，用于<strong>中间计算</strong>。<strong>性能高</strong>，因为无需持久化。</td>
</tr>
<tr>
<td align="left"><strong>复制表</strong></td>
<td align="left">主库变化<strong>记录到Binlog</strong>，从库的<strong>SQL线程读取并重放</strong>这些变化，从而应用变更。</td>
<td align="left"><strong>实现数据冗余和高可用</strong>。存在<strong>复制延迟</strong>。是<strong>异步</strong>（通常是）的过程。</td>
</tr>
</tbody></table>
<p>理解这些机制对于数据库设计、性能调优和故障排查至关重要。例如，一个写入缓慢的系统，可能是由于存在过多索引；而主从数据不一致，可能是由于复制延迟或复制线程异常导致的。</p>
<h1 id="数据库外键约束详解"><a href="#数据库外键约束详解" class="headerlink" title="数据库外键约束详解"></a>数据库外键约束详解</h1><h2 id="外键行为：主表数据改变时从表数据的变化"><a href="#外键行为：主表数据改变时从表数据的变化" class="headerlink" title="外键行为：主表数据改变时从表数据的变化"></a>外键行为：主表数据改变时从表数据的变化</h2><p>当设置了外键约束后，如果<strong>外键所在表（主表&#x2F;父表）</strong> 的信息发生改变，<strong>本表（从表&#x2F;子表）</strong> 的外键数据<strong>不会自动改变</strong>，除非明确设置了级联操作。</p>
<p>具体行为取决于外键约束的定义方式：</p>
<h3 id="1-默认行为（无级联操作）"><a href="#1-默认行为（无级联操作）" class="headerlink" title="1. 默认行为（无级联操作）"></a>1. 默认行为（无级联操作）</h3><p>如果只是简单定义外键而没有指定级联规则：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (customer_id) <span class="keyword">REFERENCES</span> customers(customer_id)</span><br><span class="line">    <span class="comment">-- 没有指定 ON DELETE 或 ON UPDATE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在这种情况下：</p>
<ul>
<li>如果尝试删除主表（customers）中已被从表（orders）引用的记录，数据库会<strong>阻止删除操作</strong>并报错</li>
<li>如果尝试更新主表的主键值，数据库会<strong>阻止更新操作</strong>并报错</li>
</ul>
<h3 id="2-级联操作行为"><a href="#2-级联操作行为" class="headerlink" title="2. 级联操作行为"></a>2. 级联操作行为</h3><p>可以通过定义级联规则来控制数据变化的行为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (customer_id) </span><br><span class="line">        <span class="keyword">REFERENCES</span> customers(customer_id)</span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE      <span class="comment">-- 主表删除时同步删除从表记录</span></span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE      <span class="comment">-- 主表更新时同步更新从表外键值</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>常用的级联选项包括：</p>
<table>
<thead>
<tr>
<th>级联选项</th>
<th>行为描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ON DELETE RESTRICT</code> (默认)</td>
<td>阻止删除主表中被引用的记录</td>
</tr>
<tr>
<td><code>ON DELETE CASCADE</code></td>
<td>主表记录删除时，自动删除从表中相关联的记录</td>
</tr>
<tr>
<td><code>ON DELETE SET NULL</code></td>
<td>主表记录删除时，将从表中的外键值设为NULL</td>
</tr>
<tr>
<td><code>ON DELETE SET DEFAULT</code></td>
<td>主表记录删除时，将从表中的外键值设为默认值</td>
</tr>
<tr>
<td><code>ON UPDATE</code> 选项</td>
<td>类似DELETE选项，用于主键更新时的情况</td>
</tr>
</tbody></table>
<h2 id="什么情况下需要设置外键"><a href="#什么情况下需要设置外键" class="headerlink" title="什么情况下需要设置外键"></a>什么情况下需要设置外键</h2><h3 id="适合使用外键的场景："><a href="#适合使用外键的场景：" class="headerlink" title="适合使用外键的场景："></a>适合使用外键的场景：</h3><ol>
<li><p><strong>数据完整性要求高的系统</strong></p>
<ul>
<li>财务系统、银行系统</li>
<li>医疗信息系统</li>
<li>政府数据管理系统</li>
</ul>
</li>
<li><p><strong>业务规则复杂的关系</strong></p>
<ul>
<li>电子商务平台（订单-商品关系）</li>
<li>内容管理系统（文章-分类关系）</li>
<li>社交网络（用户-好友关系）</li>
</ul>
</li>
<li><p><strong>开发团队较小或初级开发者较多</strong></p>
<ul>
<li>外键可以在数据库层面强制实施数据一致性，减少应用层错误</li>
</ul>
</li>
<li><p><strong>数据迁移和ETL过程</strong></p>
<ul>
<li>确保导入的数据满足引用完整性</li>
</ul>
</li>
<li><p><strong>原型开发和中小型项目</strong></p>
<ul>
<li>快速建立数据模型，减少业务逻辑代码</li>
</ul>
</li>
</ol>
<h3 id="不适合使用外键的场景："><a href="#不适合使用外键的场景：" class="headerlink" title="不适合使用外键的场景："></a>不适合使用外键的场景：</h3><ol>
<li><p><strong>高性能要求的OLTP系统</strong></p>
<ul>
<li>外键检查会带来性能开销</li>
</ul>
</li>
<li><p><strong>大规模分布式系统</strong></p>
<ul>
<li>跨数据库或跨服务器的外键难以维护</li>
</ul>
</li>
<li><p><strong>频繁大批量数据导入的场景</strong></p>
<ul>
<li>外键检查会显著降低数据加载速度</li>
</ul>
</li>
<li><p><strong>需要分库分表的系统</strong></p>
<ul>
<li>外键在分片环境中难以实现</li>
</ul>
</li>
<li><p><strong>遗留系统或与第三方系统集成</strong></p>
<ul>
<li>可能无法控制所有相关表的结构</li>
</ul>
</li>
</ol>
<h2 id="外键的优缺点"><a href="#外键的优缺点" class="headerlink" title="外键的优缺点"></a>外键的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li><p><strong>数据完整性</strong></p>
<ul>
<li>强制保证数据的一致性，防止”孤儿记录”</li>
<li>自动维护引用完整性</li>
</ul>
</li>
<li><p><strong>减少应用层代码</strong></p>
<ul>
<li>数据库自动处理关联关系，减少业务逻辑代码量</li>
<li>降低开发复杂度</li>
</ul>
</li>
<li><p><strong>自我文档化</strong></p>
<ul>
<li>外键明确表示了表之间的关系</li>
<li>使数据库结构更易于理解</li>
</ul>
</li>
<li><p><strong>防止误操作</strong></p>
<ul>
<li>防止意外删除或修改重要数据</li>
</ul>
</li>
<li><p><strong>查询优化</strong></p>
<ul>
<li>某些数据库优化器可以利用外键信息生成更好的执行计划</li>
</ul>
</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li><p><strong>性能开销</strong></p>
<ul>
<li>插入、更新、删除操作需要检查外键约束</li>
<li>在高并发环境下可能成为瓶颈</li>
</ul>
</li>
<li><p><strong>死锁风险</strong></p>
<ul>
<li>复杂的外键关系可能增加死锁的可能性</li>
</ul>
</li>
<li><p><strong>维护复杂性</strong></p>
<ul>
<li>数据库 schema 变更更加复杂</li>
<li>数据迁移和恢复更加困难</li>
</ul>
</li>
<li><p><strong>灵活性降低</strong></p>
<ul>
<li>难以实现某些特殊业务逻辑</li>
<li>限制了数据处理的方式</li>
</ul>
</li>
<li><p><strong>分布式系统限制</strong></p>
<ul>
<li>在分库分表场景中难以使用</li>
<li>跨数据库服务器的外键支持有限</li>
</ul>
</li>
</ol>
<h2 id="实际应用建议"><a href="#实际应用建议" class="headerlink" title="实际应用建议"></a>实际应用建议</h2><h3 id="推荐使用外键的情况："><a href="#推荐使用外键的情况：" class="headerlink" title="推荐使用外键的情况："></a>推荐使用外键的情况：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 电商平台示例：确保订单属于有效客户</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    customer_id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    order_date <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (customer_id) </span><br><span class="line">        <span class="keyword">REFERENCES</span> customers(customer_id)</span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT</span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 博客系统示例：确保文章属于存在的分类</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> articles (</span><br><span class="line">    article_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    category_id <span class="type">INT</span>,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (category_id) </span><br><span class="line">        <span class="keyword">REFERENCES</span> categories(category_id)</span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="替代外键的方案（当不使用外键时）："><a href="#替代外键的方案（当不使用外键时）：" class="headerlink" title="替代外键的方案（当不使用外键时）："></a>替代外键的方案（当不使用外键时）：</h3><ol>
<li><strong>应用层验证</strong><ul>
<li>在业务逻辑代码中实现完整性检查</li>
</ul>
</li>
<li><strong>定期数据校验</strong><ul>
<li>使用定时任务检查数据一致性</li>
</ul>
</li>
<li><strong>触发器</strong><ul>
<li>使用数据库触发器模拟外键行为</li>
</ul>
</li>
<li><strong>逻辑删除</strong><ul>
<li>使用标记删除而非物理删除</li>
</ul>
</li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>外键是维护数据库引用完整性的强大工具，但需要根据具体应用场景权衡使用。对于数据一致性要求高、性能压力不大的系统，外键是很好的选择。对于高性能、分布式或需要灵活性的系统，可能需要考虑其他方案来保证数据完整性。</p>
<p>关键决策因素包括：</p>
<ul>
<li>数据一致性的重要程度</li>
<li>系统性能要求</li>
<li>数据库规模和数据量</li>
<li>系统架构（是否分布式）</li>
<li>开发团队的技术水平</li>
<li>维护和变更的频率</li>
</ul>
<h1 id="存储过程与事务的区别"><a href="#存储过程与事务的区别" class="headerlink" title="存储过程与事务的区别"></a>存储过程与事务的区别</h1><h2 id="存储过程（Stored-Procedure）"><a href="#存储过程（Stored-Procedure）" class="headerlink" title="存储过程（Stored Procedure）"></a>存储过程（Stored Procedure）</h2><h3 id="什么是存储过程？"><a href="#什么是存储过程？" class="headerlink" title="什么是存储过程？"></a>什么是存储过程？</h3><p>存储过程是一组预编译的SQL语句集合，存储在数据库中，可以通过名称调用执行。它类似于编程语言中的函数或方法，可以接受参数、执行复杂的逻辑操作，并返回结果。</p>
<h3 id="存储过程的特点："><a href="#存储过程的特点：" class="headerlink" title="存储过程的特点："></a>存储过程的特点：</h3><ol>
<li><strong>预编译</strong>：存储过程在创建时进行编译，之后每次执行都不需要重新编译，提高了执行效率。</li>
<li><strong>减少网络流量</strong>：客户端只需传递存储过程名称和参数，而不是发送大量SQL语句。</li>
<li><strong>模块化</strong>：可以将复杂的业务逻辑封装在存储过程中，提高代码的可维护性和重用性。</li>
<li><strong>安全性</strong>：可以通过授权用户执行存储过程而不直接访问底层表，增强数据安全性。</li>
<li><strong>事务支持</strong>：存储过程可以包含事务控制语句，确保数据的一致性。</li>
</ol>
<h3 id="存储过程示例："><a href="#存储过程示例：" class="headerlink" title="存储过程示例："></a>存储过程示例：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> GetUserByEmail(<span class="keyword">IN</span> user_email <span class="type">VARCHAR</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span> user_email;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h2 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>事务是数据库操作的一个逻辑单元，它包含一个或多个SQL语句，这些语句要么全部成功执行，要么全部失败回滚。事务确保了数据库从一个一致状态转换到另一个一致状态。</p>
<h3 id="事务的特性（ACID）："><a href="#事务的特性（ACID）：" class="headerlink" title="事务的特性（ACID）："></a>事务的特性（ACID）：</h3><ol>
<li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不完成。</li>
<li><strong>一致性（Consistency）</strong>：事务必须使数据库从一个一致状态转换到另一个一致状态。</li>
<li><strong>隔离性（Isolation）</strong>：并发事务的执行不会相互干扰。</li>
<li><strong>持久性（Durability）</strong>：一旦事务提交，其结果就是永久性的。</li>
</ol>
<h3 id="事务示例："><a href="#事务示例：" class="headerlink" title="事务示例："></a>事务示例：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果任何一条语句失败，回滚所有操作</span></span><br><span class="line"><span class="comment">-- 如果所有语句成功，提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 或者 ROLLBACK; 回滚事务</span></span><br></pre></td></tr></table></figure>

<h2 id="存储过程与事务的区别-1"><a href="#存储过程与事务的区别-1" class="headerlink" title="存储过程与事务的区别"></a>存储过程与事务的区别</h2><table>
<thead>
<tr>
<th>特性</th>
<th>存储过程</th>
<th>事务</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>预编译的SQL语句集合</td>
<td>数据库操作的逻辑单元</td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td>封装业务逻辑，提高代码重用性</td>
<td>确保数据的一致性和完整性</td>
</tr>
<tr>
<td><strong>执行方式</strong></td>
<td>通过名称调用</td>
<td>通过BEGIN&#x2F;COMMIT&#x2F;ROLLBACK控制</td>
</tr>
<tr>
<td><strong>包含关系</strong></td>
<td>可以包含事务</td>
<td>事务可以包含在存储过程中</td>
</tr>
<tr>
<td><strong>编译</strong></td>
<td>预编译，执行效率高</td>
<td>不涉及编译概念</td>
</tr>
<tr>
<td><strong>网络流量</strong></td>
<td>减少网络流量（只需传递过程名和参数）</td>
<td>不影响网络流量</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>提供额外的安全层（可以授权执行存储过程而不直接访问表）</td>
<td>提供数据一致性保障</td>
</tr>
</tbody></table>
<h2 id="存储过程中使用事务的示例"><a href="#存储过程中使用事务的示例" class="headerlink" title="存储过程中使用事务的示例"></a>存储过程中使用事务的示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> TransferFunds(</span><br><span class="line">    <span class="keyword">IN</span> from_account <span class="type">INT</span>, </span><br><span class="line">    <span class="keyword">IN</span> to_account <span class="type">INT</span>, </span><br><span class="line">    <span class="keyword">IN</span> amount <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">OUT</span> <span class="keyword">result</span> <span class="type">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLEXCEPTION</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span>;</span><br><span class="line">        <span class="keyword">SET</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="number">-1</span>; <span class="comment">-- 表示错误</span></span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 检查发送方账户余额是否足够</span></span><br><span class="line">    IF (<span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> account_id <span class="operator">=</span> from_account) <span class="operator">&lt;</span> amount <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">SET</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">-- 余额不足</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        <span class="comment">-- 扣除发送方金额</span></span><br><span class="line">        <span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> amount <span class="keyword">WHERE</span> account_id <span class="operator">=</span> from_account;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">-- 增加接收方金额</span></span><br><span class="line">        <span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> amount <span class="keyword">WHERE</span> account_id <span class="operator">=</span> to_account;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">SET</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 成功</span></span><br><span class="line">        <span class="keyword">COMMIT</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>存储过程</strong>是数据库对象，用于封装和重用SQL代码。</li>
<li><strong>事务</strong>是数据库操作的概念，用于确保数据的一致性。</li>
<li>存储过程<strong>可以包含</strong>事务，但事务不能包含存储过程。</li>
<li>在实际开发中，经常在存储过程中使用事务来确保复杂的业务逻辑的原子性。</li>
</ul>
<p>在您的用户注册示例中，存储过程使用了事务来确保用户名校验、邮箱校验和用户插入操作要么全部成功，要么全部失败回滚，这正是存储过程和事务结合使用的典型场景。</p>
<h1 id="触发器、存储过程与事务的关系"><a href="#触发器、存储过程与事务的关系" class="headerlink" title="触发器、存储过程与事务的关系"></a>触发器、存储过程与事务的关系</h1><h2 id="触发器（Trigger）是什么？"><a href="#触发器（Trigger）是什么？" class="headerlink" title="触发器（Trigger）是什么？"></a>触发器（Trigger）是什么？</h2><p><strong>触发器</strong>是一种特殊的存储过程，它在数据库中的特定事件（如INSERT、UPDATE、DELETE）发生时<strong>自动执行</strong>。触发器与表直接关联，当对表进行数据操作时会自动触发执行。</p>
<h3 id="触发器的特点："><a href="#触发器的特点：" class="headerlink" title="触发器的特点："></a>触发器的特点：</h3><ol>
<li><strong>自动执行</strong>：无需手动调用，由数据库事件自动触发</li>
<li><strong>与表关联</strong>：绑定到特定表上的特定操作</li>
<li><strong>事件驱动</strong>：响应INSERT、UPDATE、DELETE等操作</li>
<li><strong>无参数</strong>：不能接受参数，也不能直接返回结果</li>
<li><strong>隐式事务</strong>：通常在触发它的语句的事务中执行</li>
</ol>
<h3 id="触发器示例："><a href="#触发器示例：" class="headerlink" title="触发器示例："></a>触发器示例：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个在用户表插入后自动执行的触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> after_user_insert</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> users</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 在新用户注册时自动在日志表中添加记录</span></span><br><span class="line">    <span class="keyword">INSERT INTO</span> user_audit_log (user_id, action, action_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (NEW.id, <span class="string">&#x27;USER_CREATED&#x27;</span>, NOW());</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h2 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h2><h3 id="1-层级关系"><a href="#1-层级关系" class="headerlink" title="1. 层级关系"></a>1. 层级关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">事务 (Transaction)</span><br><span class="line">    │</span><br><span class="line">    ├── 存储过程 (Stored Procedure)</span><br><span class="line">    │   │</span><br><span class="line">    │   └── 可能包含触发器 (Trigger)</span><br><span class="line">    │</span><br><span class="line">    └── 单独SQL语句</span><br><span class="line">        │</span><br><span class="line">        └── 可能触发触发器 (Trigger)</span><br></pre></td></tr></table></figure>

<h3 id="2-功能对比表"><a href="#2-功能对比表" class="headerlink" title="2. 功能对比表"></a>2. 功能对比表</h3><table>
<thead>
<tr>
<th>特性</th>
<th>触发器 (Trigger)</th>
<th>存储过程 (Stored Procedure)</th>
<th>事务 (Transaction)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>执行方式</strong></td>
<td>自动触发</td>
<td>手动调用</td>
<td>显式控制</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>数据完整性、审计日志、自动计算</td>
<td>业务逻辑封装、复杂操作</td>
<td>数据一致性保证</td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>无参数</td>
<td>可以有输入&#x2F;输出参数</td>
<td>无参数</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无返回值</td>
<td>可以有返回值</td>
<td>无返回值</td>
</tr>
<tr>
<td><strong>控制语句</strong></td>
<td>有限的控制语句</td>
<td>完整的流程控制</td>
<td>BEGIN&#x2F;COMMIT&#x2F;ROLLBACK</td>
</tr>
<tr>
<td><strong>事务控制</strong></td>
<td>不能包含事务控制语句</td>
<td>可以包含事务控制语句</td>
<td>本身就是事务控制</td>
</tr>
</tbody></table>
<h3 id="3-协同工作示例"><a href="#3-协同工作示例" class="headerlink" title="3. 协同工作示例"></a>3. 协同工作示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建一个触发器（自动审计日志）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> before_user_update</span><br><span class="line">BEFORE <span class="keyword">UPDATE</span> <span class="keyword">ON</span> users</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 在用户信息更新前记录旧值</span></span><br><span class="line">    <span class="keyword">INSERT INTO</span> user_change_log </span><br><span class="line">    (user_id, changed_field, old_value, new_value, change_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (OLD.id, <span class="string">&#x27;email&#x27;</span>, OLD.email, NEW.email, NOW());</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 创建一个存储过程（业务逻辑）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> UpdateUserEmail(</span><br><span class="line">    <span class="keyword">IN</span> user_id <span class="type">INT</span>, </span><br><span class="line">    <span class="keyword">IN</span> new_email <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">OUT</span> <span class="keyword">result</span> <span class="type">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLEXCEPTION</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span>;</span><br><span class="line">        <span class="keyword">SET</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 3. 开始事务（确保数据一致性）</span></span><br><span class="line">    <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 这个UPDATE操作会自动触发上面的触发器</span></span><br><span class="line">    <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> email <span class="operator">=</span> new_email <span class="keyword">WHERE</span> id <span class="operator">=</span> user_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 其他业务逻辑...</span></span><br><span class="line">    <span class="keyword">UPDATE</span> user_stats <span class="keyword">SET</span> last_email_update <span class="operator">=</span> NOW() <span class="keyword">WHERE</span> user_id <span class="operator">=</span> user_id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">SET</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><h3 id="1-数据完整性维护（触发器）"><a href="#1-数据完整性维护（触发器）" class="headerlink" title="1. 数据完整性维护（触发器）"></a>1. 数据完整性维护（触发器）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 确保订单金额不为负</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> check_order_amount</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    IF NEW.amount <span class="operator">&lt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;45000&#x27;</span> </span><br><span class="line">        <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;Order amount cannot be negative&#x27;</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-审计日志（触发器）"><a href="#2-审计日志（触发器）" class="headerlink" title="2. 审计日志（触发器）"></a>2. 审计日志（触发器）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自动记录所有删除操作</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> audit_user_deletes</span><br><span class="line">AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> users</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT INTO</span> deletion_audit </span><br><span class="line">    (table_name, record_id, deleted_by, deletion_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;users&#x27;</span>, OLD.id, <span class="built_in">CURRENT_USER</span>(), NOW());</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-复杂业务逻辑（存储过程-事务）"><a href="#3-复杂业务逻辑（存储过程-事务）" class="headerlink" title="3. 复杂业务逻辑（存储过程+事务）"></a>3. 复杂业务逻辑（存储过程+事务）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ProcessOrder(</span><br><span class="line">    <span class="keyword">IN</span> order_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">IN</span> payment_amount <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLEXCEPTION</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">ROLLBACK</span>;</span><br><span class="line">        <span class="comment">-- 记录错误日志等</span></span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 更新订单状态</span></span><br><span class="line">    <span class="keyword">UPDATE</span> orders <span class="keyword">SET</span> status <span class="operator">=</span> <span class="string">&#x27;PAID&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> order_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 记录支付信息</span></span><br><span class="line">    <span class="keyword">INSERT INTO</span> payments (order_id, amount, payment_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (order_id, payment_amount, NOW());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 更新库存（这会触发库存相关的触发器）</span></span><br><span class="line">    <span class="keyword">UPDATE</span> products p</span><br><span class="line">    <span class="keyword">JOIN</span> order_items oi <span class="keyword">ON</span> p.id <span class="operator">=</span> oi.product_id</span><br><span class="line">    <span class="keyword">SET</span> p.stock <span class="operator">=</span> p.stock <span class="operator">-</span> oi.quantity</span><br><span class="line">    <span class="keyword">WHERE</span> oi.order_id <span class="operator">=</span> order_id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ol>
<li><p><strong>触发器的适用场景</strong>：</p>
<ul>
<li>数据完整性约束</li>
<li>自动审计日志</li>
<li>简单的派生数据计算</li>
<li>跨表同步</li>
</ul>
</li>
<li><p><strong>存储过程的适用场景</strong>：</p>
<ul>
<li>复杂的业务逻辑</li>
<li>需要参数化和重用的操作</li>
<li>需要显式事务控制的操作</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>触发器会增加数据库负担，不宜过多使用</li>
<li>触发器的逻辑应该尽量简单</li>
<li>避免在触发器中执行耗时操作</li>
<li>注意触发器的执行顺序和递归触发问题</li>
</ul>
</li>
</ol>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>触发器</strong>是自动执行的，用于响应表数据变化</li>
<li><strong>存储过程</strong>是手动调用的，用于封装复杂逻辑</li>
<li><strong>事务</strong>是保证数据一致性的机制</li>
<li>三者可以协同工作：存储过程中可以包含事务，而数据库操作可能触发触发器</li>
<li>合理使用这三种技术可以构建出健壮、高效的数据库应用</li>
</ul>
<p>在您的用户注册示例中，可以考虑使用触发器来自动记录用户注册日志，而使用存储过程来处理复杂的注册逻辑和事务控制。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://brinjaul521.github.io">贺腾</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://brinjaul521.github.io/2025/09/17/MySql%E7%AC%94%E8%AE%B0/">https://brinjaul521.github.io/2025/09/17/MySql%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://brinjaul521.github.io" target="_blank">贺腾的博客</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="网络编程笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">网络编程笔记</div></div><div class="info-2"><div class="info-item-1">网络编程笔记网络编程核心概念与流程详解 Socket 是什么？Socket（套接字） 是网络通信的 端点，类似于现实中的“电话”。它是操作系统提供的一种 抽象接口，允许程序通过 IP 地址 + 端口号（Port） 与其他设备进行通信。    作用：Socket 是网络数据传输的通道，负责 发送数据 和 接收数据。 类比： 电话：Socket 相当于一部手机，IP 地址相当于电话号码，端口号相当于分机号。 邮局：IP 地址是城市地址，端口号是具体收件人的门牌号。     为什么要创建 Socket？ 唯一标识通信端点：    每个 Socket 绑定一个 IP + 端口，确保数据能准确发送到目标程序。 例如：Web 服务器通常绑定 80 端口，客户端通过 IP:80 访问它。   管理通信协议：    Socket 支持不同的协议（如 TCP 可靠传输、UDP 快速但不可靠）。   操作系统资源管理：    Socket 是操作系统管理的资源，创建 Socket 相当于向系统申请通信能力。     Socket 的工作流程（以 TCP 为例）1. 服务端流程步骤 1：创建 Sock...</div></div></div></a><a class="pagination-related" href="/2025/09/17/C-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="C++ 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++ 面试题</div></div><div class="info-2"><div class="info-item-1">睿联面试linux swap分区什么作用​	在Linux中，swap分区（或swap文件）的作用是当系统的物理内存（RAM）不足时，将内存中不常用的数据暂时存储到硬盘上的swap空间中，从而释放物理内存供其他更紧急的任务使用。这个过程称为“交换出”（swapping out）。当需要再次访问这些数据时，再将其从swap分区读回内存，即“交换入”（swapping in）。swap空间可以被视为物理内存的扩展，但需要注意的是，硬盘的读写速度远低于内存，因此过度依赖swap会导致系统性能下降。	  扩展虚拟内存：当物理内存（RAM）不足时，系统可以将不常用的内存页面移动到Swap空间中，从而释放RAM供更紧急的任务使用 内存管理：即使系统有足够的物理内存，内核有时也会将长时间未活动的内存页面移动到Swap中 休眠支持：当系统进入休眠状态时，会将RAM中的内容保存到Swap空间中，以便恢复时使用 避免内存不足：防止系统因内存耗尽而意外终止关键进程  Linux文件有几种权限，分别是什么Linux文件的基本权限类型Linux系统中，每个文件和目录都有三种基本的权限类型，每种权限类型对应三...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">贺腾</div><div class="author-info-description">我等的不是海边</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/brinjaul521/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/brinjaul521/" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1061391142@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">记录一下学习路线，顺便找个工作</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql"><span class="toc-number">1.</span> <span class="toc-text">Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E6%9C%AC%E8%B4%A8%E4%B8%8E%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">一、索引是什么？（本质与原理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9C%A8-MySQL-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">二、在 MySQL 中如何使用索引？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1. 创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2. 删除索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">3. 查看索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9C%89%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%EF%BC%9F%EF%BC%88%E6%A0%B8%E5%BF%83%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">三、有什么需要注意的？（核心注意事项）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%80%83%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">四、面试中的常考点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BC%98%E5%8C%96%E5%99%A8%E9%80%89%E6%8B%A9%E4%BD%A0%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%88%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E7%B4%A2%E5%BC%95%E5%8F%8B%E5%A5%BD%E7%9A%84-SQL%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">第一部分：如何让优化器选择你的索引（如何编写索引友好的 SQL）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%BB%A1%E8%B6%B3%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%EF%BC%88%E9%92%88%E5%AF%B9%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1. 满足最左前缀原则（针对复合索引）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%81%BF%E5%85%8D%E5%9C%A8%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%8A%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%88%96%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">2. 避免在索引列上进行计算或使用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8-LIKE-%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">3. 谨慎使用 LIKE 查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B3%A8%E6%84%8F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">4. 注意数据类型和隐式转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-Covering-Index"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">5. 使用覆盖索引 (Covering Index)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E7%B4%A2%E5%BC%95%E6%98%AF%E5%90%A6%E8%A2%AB%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.6.</span> <span class="toc-text">第二部分：如何验证索引是否被使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-EXPLAIN"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">如何使用 EXPLAIN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB-EXPLAIN-%E7%BB%93%E6%9E%9C%EF%BC%88%E5%85%B3%E6%B3%A8%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%88%97%EF%BC%89%EF%BC%9A"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">如何解读 EXPLAIN 结果（关注以下几个关键列）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.7.</span> <span class="toc-text">总结：索引使用流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL-%E7%B4%A2%E5%BC%95%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">MySQL 索引笔试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">题目：员工信息查询优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E4%B8%8E%E8%A7%A3%E9%87%8A"><span class="toc-number">2.2.</span> <span class="toc-text">解答与解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BA%94%E8%AF%A5%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. 应该创建的索引及创建语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BA%9B%E7%B4%A2%E5%BC%95%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. 为什么这些索引能提高查询性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E5%8F%AF%E8%83%BD%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.2.3.</span> <span class="toc-text">3. 索引可能失效的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%AB%98%E7%BA%A7%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="toc-number">2.2.4.</span> <span class="toc-text">4. 高级优化技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.</span> <span class="toc-text">面试考点总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.0.1.</span> <span class="toc-text">一、事务是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8B%E5%8A%A1%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%88ACID%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-number">3.0.2.</span> <span class="toc-text">二、事务用来解决什么问题？（ACID特性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%9A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">3.0.3.</span> <span class="toc-text">三、事务机制有哪些？（重点：隔离级别与并发问题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%8E%E4%B9%88%E7%94%A8%E4%BA%8B%E5%8A%A1%EF%BC%9F%EF%BC%88%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">3.0.4.</span> <span class="toc-text">四、怎么用事务？（语法与示例）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%AE%BE%E7%BD%AE%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">1. 查看和设置事务隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%98%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%EF%BC%88%E6%A0%87%E5%87%86%E5%86%99%E6%B3%95%EF%BC%89"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">2. 显式使用事务（标准写法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1-AutoCommit"><span class="toc-number">3.0.4.3.</span> <span class="toc-text">3. 隐式事务 (AutoCommit)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9C%A8%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BB%A5-Python-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">3.0.5.</span> <span class="toc-text">五、在编程中如何使用（以 Python 为例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.0.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%A1%A8%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98%E6%97%B6%EF%BC%8C%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%B8%B4%E6%97%B6%E8%A1%A8%EF%BC%8C%E5%A4%8D%E5%88%B6%E8%A1%A8%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">数据库中表中数据改变时，索引，临时表，复制表会发生什么变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">4.0.1.</span> <span class="toc-text">1. 索引的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%A1%8C%E4%B8%BA%EF%BC%9A"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">具体行为：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%BD%B1%E5%93%8D%EF%BC%9A"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">核心影响：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">4.0.2.</span> <span class="toc-text">2. 临时表的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%A1%8C%E4%B8%BA%EF%BC%9A-1"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">具体行为：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%8D%E5%88%B6%E8%A1%A8%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="toc-number">4.0.3.</span> <span class="toc-text">3. 复制表的变化（主从复制场景）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">4.0.3.1.</span> <span class="toc-text">具体流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%BD%B1%E5%93%8D%E4%B8%8E%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">4.0.3.2.</span> <span class="toc-text">核心影响与特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="toc-number">4.0.4.</span> <span class="toc-text">总结对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">数据库外键约束详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E8%A1%8C%E4%B8%BA%EF%BC%9A%E4%B8%BB%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98%E6%97%B6%E4%BB%8E%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">外键行为：主表数据改变时从表数据的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%EF%BC%88%E6%97%A0%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">1. 默认行为（无级联操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C%E8%A1%8C%E4%B8%BA"><span class="toc-number">5.1.2.</span> <span class="toc-text">2. 级联操作行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE%E5%A4%96%E9%94%AE"><span class="toc-number">5.2.</span> <span class="toc-text">什么情况下需要设置外键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">适合使用外键的场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">不适合使用外键的场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.3.</span> <span class="toc-text">外键的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">5.3.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">5.4.</span> <span class="toc-text">实际应用建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-number">5.4.1.</span> <span class="toc-text">推荐使用外键的情况：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E5%A4%96%E9%94%AE%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88%E5%BD%93%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE%E6%97%B6%EF%BC%89%EF%BC%9A"><span class="toc-number">5.4.2.</span> <span class="toc-text">替代外键的方案（当不使用外键时）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">5.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">存储过程与事务的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%88Stored-Procedure%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">存储过程（Stored Procedure）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">6.1.1.</span> <span class="toc-text">什么是存储过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">6.1.2.</span> <span class="toc-text">存储过程的特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">6.1.3.</span> <span class="toc-text">存储过程示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%EF%BC%88Transaction%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">事务（Transaction）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">6.2.1.</span> <span class="toc-text">什么是事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89%EF%BC%9A"><span class="toc-number">6.2.2.</span> <span class="toc-text">事务的特性（ACID）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">6.2.3.</span> <span class="toc-text">事务示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB-1"><span class="toc-number">6.3.</span> <span class="toc-text">存储过程与事务的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.4.</span> <span class="toc-text">存储过程中使用事务的示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">6.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.</span> <span class="toc-text">触发器、存储过程与事务的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%88Trigger%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">触发器（Trigger）是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">7.1.1.</span> <span class="toc-text">触发器的特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">7.1.2.</span> <span class="toc-text">触发器示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.2.</span> <span class="toc-text">三者之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB"><span class="toc-number">7.2.1.</span> <span class="toc-text">1. 层级关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%9F%E8%83%BD%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">7.2.2.</span> <span class="toc-text">2. 功能对比表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.2.3.</span> <span class="toc-text">3. 协同工作示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.3.</span> <span class="toc-text">实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BB%B4%E6%8A%A4%EF%BC%88%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%89"><span class="toc-number">7.3.1.</span> <span class="toc-text">1. 数据完整性维护（触发器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97%EF%BC%88%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%89"><span class="toc-number">7.3.2.</span> <span class="toc-text">2. 审计日志（触发器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%EF%BC%88%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E4%BA%8B%E5%8A%A1%EF%BC%89"><span class="toc-number">7.3.3.</span> <span class="toc-text">3. 复杂业务逻辑（存储过程+事务）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">7.4.</span> <span class="toc-text">使用建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">7.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/" title="设计模式的原则"><img src="/2025/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/design.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式的原则"/></a><div class="content"><a class="title" href="/2025/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/" title="设计模式的原则">设计模式的原则</a><time datetime="2025-09-19T11:05:22.000Z" title="发表于 2025-09-19 19:05:22">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="简单工厂模式"><img src="/2025/09/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/asl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单工厂模式"/></a><div class="content"><a class="title" href="/2025/09/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="简单工厂模式">简单工厂模式</a><time datetime="2025-09-19T06:17:45.000Z" title="发表于 2025-09-19 14:17:45">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="策略模式"><img src="/2025/09/18/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/strategy.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="策略模式"/></a><div class="content"><a class="title" href="/2025/09/18/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="策略模式">策略模式</a><time datetime="2025-09-18T13:01:22.000Z" title="发表于 2025-09-18 21:01:22">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/%E5%81%8F%E6%88%91%E6%9D%A5%E6%97%B6%E4%B8%8D%E9%80%A2%E6%98%A5%EF%BC%8C%E5%81%8F%E6%88%91%E8%B5%B0%E6%97%B6%E6%98%A5%E5%8F%88%E6%9D%A5/" title="偏我来时不逢春，偏我走时春又来"><img src="/2025/09/18/%E5%81%8F%E6%88%91%E6%9D%A5%E6%97%B6%E4%B8%8D%E9%80%A2%E6%98%A5%EF%BC%8C%E5%81%8F%E6%88%91%E8%B5%B0%E6%97%B6%E6%98%A5%E5%8F%88%E6%9D%A5/street.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="偏我来时不逢春，偏我走时春又来"/></a><div class="content"><a class="title" href="/2025/09/18/%E5%81%8F%E6%88%91%E6%9D%A5%E6%97%B6%E4%B8%8D%E9%80%A2%E6%98%A5%EF%BC%8C%E5%81%8F%E6%88%91%E8%B5%B0%E6%97%B6%E6%98%A5%E5%8F%88%E6%9D%A5/" title="偏我来时不逢春，偏我走时春又来">偏我来时不逢春，偏我走时春又来</a><time datetime="2025-09-18T11:56:47.000Z" title="发表于 2025-09-18 19:56:47">2025-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/18/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/" title="生产者消费者模型">生产者消费者模型</a><time datetime="2025-09-18T11:46:33.000Z" title="发表于 2025-09-18 19:46:33">2025-09-18</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 贺腾</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/bg-player.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>