<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络编程笔记 | 贺腾的博客</title><meta name="author" content="贺腾"><meta name="copyright" content="贺腾"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网络编程笔记网络编程核心概念与流程详解 Socket 是什么？Socket（套接字） 是网络通信的 端点，类似于现实中的“电话”。它是操作系统提供的一种 抽象接口，允许程序通过 IP 地址 + 端口号（Port） 与其他设备进行通信。    作用：Socket 是网络数据传输的通道，负责 发送数据 和 接收数据。 类比： 电话：Socket 相当于一部手机，IP 地址相当于电话号码，端口号相当于分">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程笔记">
<meta property="og:url" content="https://brinjaul521.github.io/2025/09/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="贺腾的博客">
<meta property="og:description" content="网络编程笔记网络编程核心概念与流程详解 Socket 是什么？Socket（套接字） 是网络通信的 端点，类似于现实中的“电话”。它是操作系统提供的一种 抽象接口，允许程序通过 IP 地址 + 端口号（Port） 与其他设备进行通信。    作用：Socket 是网络数据传输的通道，负责 发送数据 和 接收数据。 类比： 电话：Socket 相当于一部手机，IP 地址相当于电话号码，端口号相当于分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://brinjaul521.github.io/img/head.jpg">
<meta property="article:published_time" content="2025-09-17T06:21:12.000Z">
<meta property="article:modified_time" content="2025-09-17T06:28:04.818Z">
<meta property="article:author" content="贺腾">
<meta property="article:tag" content="C++ 网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://brinjaul521.github.io/img/head.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "网络编程笔记",
  "url": "https://brinjaul521.github.io/2025/09/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
  "image": "https://brinjaul521.github.io/img/head.jpg",
  "datePublished": "2025-09-17T06:21:12.000Z",
  "dateModified": "2025-09-17T06:28:04.818Z",
  "author": [
    {
      "@type": "Person",
      "name": "贺腾",
      "url": "https://brinjaul521.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://brinjaul521.github.io/2025/09/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络编程笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">贺腾的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">网络编程笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">网络编程笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-17T06:21:12.000Z" title="发表于 2025-09-17 14:21:12">2025-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-17T06:28:04.818Z" title="更新于 2025-09-17 14:28:04">2025-09-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="网络编程笔记"><a href="#网络编程笔记" class="headerlink" title="网络编程笔记"></a>网络编程笔记</h1><h2 id="网络编程核心概念与流程详解"><a href="#网络编程核心概念与流程详解" class="headerlink" title="网络编程核心概念与流程详解"></a><strong>网络编程核心概念与流程详解</strong></h2><hr>
<h3 id="Socket-是什么？"><a href="#Socket-是什么？" class="headerlink" title="Socket 是什么？"></a><strong>Socket 是什么？</strong></h3><p><strong>Socket（套接字）</strong> 是网络通信的 <strong>端点</strong>，类似于现实中的“电话”。它是操作系统提供的一种 <strong>抽象接口</strong>，允许程序通过 <strong>IP 地址 + 端口号（Port）</strong> 与其他设备进行通信。  </p>
<ul>
<li><strong>作用</strong>：Socket 是网络数据传输的通道，负责 <strong>发送数据</strong> 和 <strong>接收数据</strong>。</li>
<li><strong>类比</strong>：<ul>
<li><strong>电话</strong>：Socket 相当于一部手机，IP 地址相当于电话号码，端口号相当于分机号。</li>
<li><strong>邮局</strong>：IP 地址是城市地址，端口号是具体收件人的门牌号。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="为什么要创建-Socket？"><a href="#为什么要创建-Socket？" class="headerlink" title="为什么要创建 Socket？"></a><strong>为什么要创建 Socket？</strong></h3><ol>
<li><p><strong>唯一标识通信端点</strong>：  </p>
<ul>
<li>每个 Socket 绑定一个 <strong>IP + 端口</strong>，确保数据能准确发送到目标程序。</li>
<li>例如：Web 服务器通常绑定 <code>80</code> 端口，客户端通过 <code>IP:80</code> 访问它。</li>
</ul>
</li>
<li><p><strong>管理通信协议</strong>：  </p>
<ul>
<li>Socket 支持不同的协议（如 <strong>TCP</strong> 可靠传输、<strong>UDP</strong> 快速但不可靠）。</li>
</ul>
</li>
<li><p><strong>操作系统资源管理</strong>：  </p>
<ul>
<li>Socket 是操作系统管理的资源，创建 Socket 相当于向系统申请通信能力。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Socket-的工作流程（以-TCP-为例）"><a href="#Socket-的工作流程（以-TCP-为例）" class="headerlink" title="Socket 的工作流程（以 TCP 为例）"></a><strong>Socket 的工作流程（以 TCP 为例）</strong></h3><h4 id="1-服务端流程"><a href="#1-服务端流程" class="headerlink" title="1. 服务端流程"></a><strong>1. 服务端流程</strong></h4><h5 id="步骤-1：创建-Socket"><a href="#步骤-1：创建-Socket" class="headerlink" title="步骤 1：创建 Socket"></a><strong>步骤 1：创建 Socket</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数说明</strong>：<ul>
<li><code>AF_INET</code>：使用 IPv4 协议。</li>
<li><code>SOCK_STREAM</code>：使用 TCP 协议（可靠、面向连接）。</li>
</ul>
</li>
<li><strong>作用</strong>：创建一个用于监听的 Socket，类似安装一部座机电话。</li>
</ul>
<hr>
<h5 id="步骤-2：绑定-IP-和端口（Bind）"><a href="#步骤-2：绑定-IP-和端口（Bind）" class="headerlink" title="步骤 2：绑定 IP 和端口（Bind）"></a><strong>步骤 2：绑定 IP 和端口（Bind）</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">address.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 绑定本机所有 IP</span></span><br><span class="line">address.sin_port = htons(<span class="number">8080</span>);        <span class="comment">// 绑定 8080 端口</span></span><br><span class="line"></span><br><span class="line">bind(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：将 Socket 绑定到本机的 IP 和端口，相当于给座机电话分配号码。</li>
<li><strong>关键点</strong>：<ul>
<li><code>INADDR_ANY</code>：服务端可以监听所有网卡（如局域网和公网 IP）。</li>
<li><code>htons(8080)</code>：将端口号转换为网络字节序（避免大小端问题）。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="步骤-3：监听连接（Listen）"><a href="#步骤-3：监听连接（Listen）" class="headerlink" title="步骤 3：监听连接（Listen）"></a><strong>步骤 3：监听连接（Listen）</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(server_fd, <span class="number">5</span>);  <span class="comment">// 最大等待连接数为 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：开始监听客户端的连接请求，类似打开电话的接听功能。</li>
<li><strong>参数</strong>：<code>5</code> 表示等待队列的最大长度，超过后新连接会被拒绝。</li>
</ul>
<hr>
<h5 id="步骤-4：接受连接（Accept）"><a href="#步骤-4：接受连接（Accept）" class="headerlink" title="步骤 4：接受连接（Accept）"></a><strong>步骤 4：接受连接（Accept）</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> client_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">client_fd = accept(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;addr_len);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：接受客户端的连接请求，并为该客户端创建一个 <strong>新的 Socket</strong>。</li>
<li><strong>为什么需要新 Socket？</strong><ul>
<li>服务端需要同时处理多个客户端，每个客户端独立通信。</li>
<li>主 Socket（<code>server_fd</code>）仅用于监听，新 Socket（<code>client_fd</code>）负责与客户端通信。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="步骤-5：收发数据（Read-Write）"><a href="#步骤-5：收发数据（Read-Write）" class="headerlink" title="步骤 5：收发数据（Read&#x2F;Write）"></a><strong>步骤 5：收发数据（Read&#x2F;Write）</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">read(client_fd, buffer, <span class="keyword">sizeof</span>(buffer));  <span class="comment">// 读取客户端数据</span></span><br><span class="line">write(client_fd, <span class="string">&quot;Hello Client&quot;</span>, <span class="number">12</span>);     <span class="comment">// 向客户端发送数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：通过新 Socket 与客户端进行数据交换。</li>
</ul>
<hr>
<h4 id="2-客户端流程"><a href="#2-客户端流程" class="headerlink" title="2. 客户端流程"></a><strong>2. 客户端流程</strong></h4><h5 id="步骤-1：创建-Socket-1"><a href="#步骤-1：创建-Socket-1" class="headerlink" title="步骤 1：创建 Socket"></a><strong>步骤 1：创建 Socket</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> client_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>与服务端类似，创建用于通信的 Socket。</li>
</ul>
<hr>
<h5 id="步骤-2：连接服务端（Connect）"><a href="#步骤-2：连接服务端（Connect）" class="headerlink" title="步骤 2：连接服务端（Connect）"></a><strong>步骤 2：连接服务端（Connect）</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);  <span class="comment">// 服务端 IP</span></span><br><span class="line"></span><br><span class="line">connect(client_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：向服务端发起连接请求，类似拨打服务端的电话号码。</li>
<li><strong>关键点</strong>：客户端需要知道服务端的 <strong>IP 和端口</strong>。</li>
</ul>
<hr>
<h5 id="步骤-3：收发数据（Write-Read）"><a href="#步骤-3：收发数据（Write-Read）" class="headerlink" title="步骤 3：收发数据（Write&#x2F;Read）"></a><strong>步骤 3：收发数据（Write&#x2F;Read）</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write(client_fd, <span class="string">&quot;Hello Server&quot;</span>, <span class="number">12</span>);  <span class="comment">// 发送数据</span></span><br><span class="line">read(client_fd, buffer, <span class="keyword">sizeof</span>(buffer)); <span class="comment">// 接收数据</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Socket-的底层工作原理"><a href="#Socket-的底层工作原理" class="headerlink" title="Socket 的底层工作原理"></a><strong>Socket 的底层工作原理</strong></h3><h4 id="1-TCP-三次握手"><a href="#1-TCP-三次握手" class="headerlink" title="1. TCP 三次握手"></a><strong>1. TCP 三次握手</strong></h4><p>当客户端调用 <code>connect()</code> 时，触发 TCP 三次握手：</p>
<ol>
<li>客户端发送 <code>SYN</code> 包（同步请求）。</li>
<li>服务端回复 <code>SYN-ACK</code> 包（确认请求）。</li>
<li>客户端回复 <code>ACK</code> 包（最终确认），连接建立。</li>
</ol>
<hr>
<h4 id="2-为什么服务端需要多-Socket？"><a href="#2-为什么服务端需要多-Socket？" class="headerlink" title="2. 为什么服务端需要多 Socket？"></a><strong>2. 为什么服务端需要多 Socket？</strong></h4><ul>
<li><strong>主 Socket（监听 Socket）</strong>：<br>负责监听新连接，不参与数据传输。</li>
<li><strong>新 Socket（客户端 Socket）</strong>：<br>每个客户端连接后，服务端为其分配独立的 Socket，实现并发处理。</li>
</ul>
<hr>
<h4 id="3-数据传输流程"><a href="#3-数据传输流程" class="headerlink" title="3. 数据传输流程"></a><strong>3. 数据传输流程</strong></h4><ol>
<li>数据从应用程序写入 Socket 缓冲区。</li>
<li>操作系统将数据封装为 TCP 报文，通过网卡发送。</li>
<li>接收方的 Socket 缓冲区接收数据，应用程序读取。</li>
</ol>
<hr>
<h3 id="完整通信流程示例"><a href="#完整通信流程示例" class="headerlink" title="完整通信流程示例"></a><strong>完整通信流程示例</strong></h3><h4 id="服务端代码（伪代码）"><a href="#服务端代码（伪代码）" class="headerlink" title="服务端代码（伪代码）"></a><strong>服务端代码（伪代码）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 Socket</span></span><br><span class="line"><span class="type">int</span> server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定 IP 和端口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span> =</span> &#123;...&#125;;</span><br><span class="line">bind(server_fd, &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 监听连接</span></span><br><span class="line">listen(server_fd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 接受连接</span></span><br><span class="line"><span class="type">int</span> client_fd = accept(server_fd, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 收发数据</span></span><br><span class="line">read(client_fd, ...);</span><br><span class="line">write(client_fd, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 关闭 Socket</span></span><br><span class="line">close(client_fd);</span><br><span class="line">close(server_fd);</span><br></pre></td></tr></table></figure>

<h4 id="客户端代码（伪代码）"><a href="#客户端代码（伪代码）" class="headerlink" title="客户端代码（伪代码）"></a><strong>客户端代码（伪代码）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 Socket</span></span><br><span class="line"><span class="type">int</span> client_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 连接服务端</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span> =</span> &#123;...&#125;;</span><br><span class="line">connect(client_fd, &amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 收发数据</span></span><br><span class="line">write(client_fd, ...);</span><br><span class="line">read(client_fd, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 关闭 Socket</span></span><br><span class="line">close(client_fd);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关键概念总结"><a href="#关键概念总结" class="headerlink" title="关键概念总结"></a><strong>关键概念总结</strong></h3><table>
<thead>
<tr>
<th>概念</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Socket</strong></td>
<td>网络通信的端点，绑定 IP 和端口，负责数据传输。</td>
</tr>
<tr>
<td><strong>Bind</strong></td>
<td>将 Socket 绑定到本机的 IP 和端口，类似分配电话号码。</td>
</tr>
<tr>
<td><strong>Listen</strong></td>
<td>开启监听模式，等待客户端连接请求。</td>
</tr>
<tr>
<td><strong>Accept</strong></td>
<td>接受客户端连接，创建新 Socket 用于通信。</td>
</tr>
<tr>
<td><strong>Connect</strong></td>
<td>客户端主动连接服务端的 IP 和端口。</td>
</tr>
<tr>
<td><strong>Read&#x2F;Write</strong></td>
<td>通过 Socket 发送和接收数据。</td>
</tr>
</tbody></table>
<hr>
<h3 id="类比理解"><a href="#类比理解" class="headerlink" title="类比理解"></a><strong>类比理解</strong></h3><ul>
<li><p><strong>服务端</strong>：像一个客服中心。</p>
<ol>
<li>安装座机电话（<code>socket()</code>）。</li>
<li>设置电话号码（<code>bind()</code>）。</li>
<li>开启接听模式（<code>listen()</code>）。</li>
<li>接到客户来电后，分配专属客服（<code>accept()</code>）。</li>
<li>客服与客户通话（<code>read()/write()</code>）。</li>
</ol>
</li>
<li><p><strong>客户端</strong>：像打电话的客户。</p>
<ol>
<li>用手机拨号（<code>socket()</code> + <code>connect()</code>）。</li>
<li>与客服交流（<code>write()/read()</code>）。</li>
</ol>
</li>
</ul>
<hr>
<p>通过 Socket，程序可以像打电话一样实现跨网络的通信。理解这些步骤后，可以进一步学习多线程、非阻塞 IO 或异步编程，以处理高并发场景。</p>
<hr>
<h3 id="服务端与客户端的交互流程"><a href="#服务端与客户端的交互流程" class="headerlink" title="服务端与客户端的交互流程"></a><strong>服务端与客户端的交互流程</strong></h3><ol>
<li><p><strong>服务端创建监听 Socket</strong>：</p>
<ul>
<li>作用：专门用于 <strong>监听</strong> 客户端的连接请求。</li>
<li>类比：客服中心的总机号码，只负责接听来电，不处理具体业务。</li>
</ul>
</li>
<li><p><strong>客户端发起连接</strong>：</p>
<ul>
<li>客户端通过 <code>connect()</code> 向服务端的监听 Socket（IP + Port）发起连接请求。</li>
<li>类比：客户拨打客服总机号码。</li>
</ul>
</li>
<li><p><strong>服务端接受连接并创建会话 Socket</strong>：</p>
<ul>
<li>服务端通过 <code>accept()</code> 接受连接后，<strong>创建新的会话 Socket</strong>（如 <code>client_fd</code>）与客户端通信。</li>
<li>类比：总机将电话转接给专属客服，后续由客服处理客户需求。</li>
<li><strong>关键点</strong>：<ul>
<li>监听 Socket（<code>server_fd</code>）始终存在，持续监听新连接。</li>
<li>每个客户端连接都会生成独立的会话 Socket，实现 <strong>并发处理</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>通过会话 Socket 通信</strong>：</p>
<ul>
<li>服务端和客户端通过各自的 Socket（服务端的 <code>client_fd</code> 和客户端的 <code>client_fd</code>）进行 <code>read()</code>&#x2F;<code>write()</code>。</li>
<li>类比：客服和客户通过分机通话。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="关键细节补充"><a href="#关键细节补充" class="headerlink" title="关键细节补充"></a><strong>关键细节补充</strong></h3><h4 id="1-为什么需要两个-Socket？"><a href="#1-为什么需要两个-Socket？" class="headerlink" title="1. 为什么需要两个 Socket？"></a>1. <strong>为什么需要两个 Socket？</strong></h4><ul>
<li><strong>监听 Socket</strong>：<br>仅负责接收新连接请求（类似总机），<strong>不参与数据传输</strong>。若用它直接通信，服务端将无法同时处理其他客户端。</li>
<li><strong>会话 Socket</strong>：<br>每个客户端连接后，服务端为其分配独立的 Socket，确保 <strong>并发处理</strong>（如同时服务 1000 个客户端）。</li>
</ul>
<h4 id="2-TCP-连接的建立时机"><a href="#2-TCP-连接的建立时机" class="headerlink" title="2. TCP 连接的建立时机"></a>2. <strong>TCP 连接的建立时机</strong></h4><ul>
<li>客户端调用 <code>connect()</code> 时触发 <strong>TCP 三次握手</strong>。</li>
<li>服务端调用 <code>accept()</code> 时，<strong>从已建立的连接队列中取出一个连接</strong>（握手已完成）。<ul>
<li>操作系统内核会维护一个队列，存放已完成握手的连接，<code>accept()</code> 只是从中取出。</li>
</ul>
</li>
</ul>
<h4 id="3-会话-Socket-的端口问题"><a href="#3-会话-Socket-的端口问题" class="headerlink" title="3. 会话 Socket 的端口问题"></a>3. <strong>会话 Socket 的端口问题</strong></h4><ul>
<li>客户端 Socket 的端口由操作系统自动分配（如 <code>12345</code>）。</li>
<li>服务端的会话 Socket <strong>复用监听 Socket 的端口</strong>（如 <code>8080</code>），但通过四元组（服务端 IP + Port + 客户端 IP + Port）区分不同连接。</li>
</ul>
<hr>
<h3 id="完整流程示意图"><a href="#完整流程示意图" class="headerlink" title="完整流程示意图"></a><strong>完整流程示意图</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务端                           客户端</span><br><span class="line">1. socket() 创建监听 Socket</span><br><span class="line">2. bind() 绑定 IP:Port</span><br><span class="line">3. listen() 开始监听</span><br><span class="line">                                4. socket() 创建客户端 Socket</span><br><span class="line">                                5. connect() 发起连接（触发三次握手）</span><br><span class="line">6. accept() 接受连接，创建会话 Socket</span><br><span class="line">7. read()/write() 通信          8. read()/write() 通信</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>你的理解完全正确，且清晰地把握了服务端和客户端的分工逻辑。实际开发中，服务端会通过 <strong>多线程</strong>、<strong>I&#x2F;O 多路复用</strong>（如 <code>select</code>&#x2F;<code>epoll</code>）或 <strong>异步编程</strong> 来高效管理多个会话 Socket，这正是高性能服务器的核心设计之一。</p>
<h2 id="终端节点（Endpoint）的详细解释"><a href="#终端节点（Endpoint）的详细解释" class="headerlink" title="终端节点（Endpoint）的详细解释"></a><strong>终端节点（Endpoint）的详细解释</strong></h2><p>在网络编程中，<strong>终端节点（Endpoint）</strong> 是通信链路中的一个逻辑端点，用于唯一标识网络中参与通信的某一方（客户端或服务端）。它通过 <strong>IP 地址 + 端口号（Port）</strong> 的组合来精确定位一个进程（或服务），是网络通信中数据收发的基础单元。</p>
<hr>
<h3 id="终端节点的核心定义"><a href="#终端节点的核心定义" class="headerlink" title="终端节点的核心定义"></a><strong>终端节点的核心定义</strong></h3><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a><strong>组成要素</strong></h4><p>终端节点由以下两部分构成：</p>
<ul>
<li><strong>IP 地址</strong>：标识网络中的一台设备（如 <code>192.168.1.100</code> 或 <code>fe80::1</code>）。</li>
<li><strong>端口号</strong>：标识设备上的一个具体进程或服务（如 <code>80</code> 表示 HTTP 服务）。</li>
</ul>
<h4 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a><strong>核心作用</strong></h4><ul>
<li><strong>唯一性</strong>：通过 <code>IP:Port</code> 的组合，确保数据准确发送到目标进程。</li>
<li><strong>协议无关性</strong>：终端节点的定义适用于 <strong>TCP、UDP、HTTP</strong> 等多种协议。</li>
<li><strong>端到端通信的基础</strong>：两个终端节点（客户端和服务端）通过其 <code>IP:Port</code> 建立连接或传输数据。</li>
</ul>
<hr>
<h3 id="终端节点在不同协议中的表现形式"><a href="#终端节点在不同协议中的表现形式" class="headerlink" title="终端节点在不同协议中的表现形式"></a><strong>终端节点在不同协议中的表现形式</strong></h3><h4 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP&#x2F;UDP"></a><strong>TCP&#x2F;UDP</strong></h4><ul>
<li>终端节点：<code>IP地址 + 端口号</code>。</li>
<li>示例：<ul>
<li>服务端：<code>192.168.1.100:8080</code></li>
<li>客户端：<code>192.168.1.200:54321</code></li>
</ul>
</li>
</ul>
<h4 id="UNIX-域套接字（本地通信）"><a href="#UNIX-域套接字（本地通信）" class="headerlink" title="UNIX 域套接字（本地通信）"></a><strong>UNIX 域套接字（本地通信）</strong></h4><ul>
<li>终端节点：文件系统路径（如 <code>/tmp/my_socket</code>）。</li>
<li>用于同一台机器上的进程间通信（IPC）。</li>
</ul>
<h4 id="HTTP-WebSocket"><a href="#HTTP-WebSocket" class="headerlink" title="HTTP&#x2F;WebSocket"></a><strong>HTTP&#x2F;WebSocket</strong></h4><ul>
<li>终端节点：URL（如 <code>http://example.com:80/api</code>）。</li>
<li>底层仍通过 <code>IP:Port</code> 实现，但抽象为更易读的域名和路径。</li>
</ul>
<hr>
<h3 id="终端节点的工作机制"><a href="#终端节点的工作机制" class="headerlink" title="终端节点的工作机制"></a><strong>终端节点的工作机制</strong></h3><h4 id="客户端如何构造终端节点？"><a href="#客户端如何构造终端节点？" class="headerlink" title="客户端如何构造终端节点？"></a><strong>客户端如何构造终端节点？</strong></h4><p>假设客户端需要连接服务端 <code>192.168.1.100:8080</code>，步骤如下：</p>
<ol>
<li><p><strong>定义服务端终端节点</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 示例（使用 Boost.Asio）</span></span><br><span class="line">boost::asio::ip::tcp:: <span class="function">endpoint <span class="title">endpoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    boost::asio::ip::address:: from_string(<span class="string">&quot;192.168.1.100&quot;</span>),  <span class="comment">// IP</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="number">8080</span>                                                     <span class="comment">// Port</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过终端节点发起连接</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::ip::tcp:: <span class="function">socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">socket.<span class="built_in">connect</span>(endpoint);  <span class="comment">// 连接到服务端的终端节点</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="服务端如何绑定终端节点？"><a href="#服务端如何绑定终端节点？" class="headerlink" title="服务端如何绑定终端节点？"></a><strong>服务端如何绑定终端节点？</strong></h4><p>服务端需绑定一个终端节点以监听请求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定 0.0.0.0:8080（监听所有网卡的 8080 端口）</span></span><br><span class="line">boost::asio::ip::tcp:: <span class="function">acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">bind</span>(endpoint);</span><br><span class="line">acceptor.<span class="built_in">listen</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="终端节点的关键特性"><a href="#终端节点的关键特性" class="headerlink" title="终端节点的关键特性"></a><strong>终端节点的关键特性</strong></h3><h4 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a><strong>唯一性</strong></h4><ul>
<li>同一时刻，一个终端节点只能被一个进程占用（避免端口冲突）。</li>
<li>示例：若服务端已绑定 <code>0.0.0.0:8080</code>，其他进程无法再绑定该端口。</li>
</ul>
<h4 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a><strong>动态性</strong></h4><ul>
<li>客户端端口通常由操作系统自动分配（称为“临时端口”）。<ul>
<li>服务端端口：固定（如 <code>80</code>）。</li>
<li>客户端端口：随机（如 <code>54321</code>）。</li>
</ul>
</li>
</ul>
<h4 id="协议关联性"><a href="#协议关联性" class="headerlink" title="协议关联性"></a><strong>协议关联性</strong></h4><ul>
<li>终端节点与协议绑定。例如：<ul>
<li><code>TCP 192.168.1.100:8080</code> 和 <code>UDP 192.168.1.100:8080</code> 是两个不同的终端节点。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="终端节点的实际应用"><a href="#终端节点的实际应用" class="headerlink" title="终端节点的实际应用"></a><strong>终端节点的实际应用</strong></h3><h4 id="客户端代码示例（Python）"><a href="#客户端代码示例（Python）" class="headerlink" title="客户端代码示例（Python）"></a><strong>客户端代码示例（Python）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造服务端终端节点</span></span><br><span class="line">server_ip = <span class="string">&quot;192.168.1.100&quot;</span></span><br><span class="line">server_port = <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Socket 并连接</span></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client_socket.connect((server_ip, server_port))  <span class="comment"># 连接到终端节点</span></span><br><span class="line">client_socket.send(b <span class="string">&quot;Hello Server&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="服务端代码示例（Python）"><a href="#服务端代码示例（Python）" class="headerlink" title="服务端代码示例（Python）"></a><strong>服务端代码示例（Python）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定终端节点</span></span><br><span class="line">server_ip = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">server_port = <span class="number">8080</span></span><br><span class="line"></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server_socket.bind((server_ip, server_port))  <span class="comment"># 绑定终端节点</span></span><br><span class="line">server_socket.listen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受客户端连接</span></span><br><span class="line">client_socket, client_addr = server_socket.accept()</span><br><span class="line">data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(f <span class="string">&quot;Received: &#123;data&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h3><h4 id="为什么需要端口号？"><a href="#为什么需要端口号？" class="headerlink" title="为什么需要端口号？"></a><strong>为什么需要端口号？</strong></h4><ul>
<li>IP 地址只能定位到设备，端口号进一步定位到设备上的具体进程。</li>
<li>类比：IP 地址是公司地址，端口号是部门分机号。</li>
</ul>
<h4 id="终端节点与-Socket-的关系"><a href="#终端节点与-Socket-的关系" class="headerlink" title="终端节点与 Socket 的关系"></a><strong>终端节点与 Socket 的关系</strong></h4><ul>
<li><strong>Socket</strong> 是操作系统提供的通信接口（类似“电话”）。</li>
<li><strong>终端节点</strong> 是 Socket 的地址（类似“电话号码”）。</li>
</ul>
<h4 id="如何避免端口冲突？"><a href="#如何避免端口冲突？" class="headerlink" title="如何避免端口冲突？"></a><strong>如何避免端口冲突？</strong></h4><ul>
<li>确保同一终端节点（IP + Port）不被多个进程同时占用。</li>
<li>服务端通常绑定固定端口，客户端使用临时端口。</li>
</ul>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>终端节点是网络通信的坐标</strong>：通过 <code>IP:Port</code> 精确定位通信双方。</li>
<li><strong>客户端通过终端节点连接服务端</strong>：构造目标终端节点并调用 <code>connect()</code>。</li>
<li><strong>服务端通过终端节点监听请求</strong>：绑定终端节点并调用 <code>listen()</code>&#x2F;<code>accept()</code>。</li>
</ul>
<p>理解终端节点是掌握网络编程的基础，后续学习多线程、异步 IO 或协议设计时，均需围绕终端节点展开。</p>
<h2 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h2><p>以下是使用 <strong>C++ 和 Boost.Asio 库</strong> 实现的完整网络编程示例，涵盖 <strong>服务端</strong> 和 <strong>客户端</strong> 的流程。代码详细注释了每一步的操作，并解释了关键概念。</p>
<hr>
<h3 id="服务端代码（同步阻塞模型）"><a href="#服务端代码（同步阻塞模型）" class="headerlink" title="服务端代码（同步阻塞模型）"></a><strong>服务端代码（同步阻塞模型）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost:: asio;</span><br><span class="line"><span class="keyword">using</span> ip:: tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 I/O 上下文（管理异步操作的基础设施）</span></span><br><span class="line">        io_context io_context;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建监听 Acceptor（绑定到本机所有 IP 的 8080 端口）</span></span><br><span class="line">        tcp:: <span class="function">acceptor <span class="title">acceptor</span><span class="params">(io_context, tcp:: endpoint(tcp:: v4(), <span class="number">8080</span>))</span></span>;</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;Server started. Listening on 0.0.0.0:8080...&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 等待客户端连接（同步阻塞）</span></span><br><span class="line">        tcp:: <span class="function">socket <span class="title">client_socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">        acceptor.<span class="built_in">accept</span>(client_socket); <span class="comment">// 阻塞直到有客户端连接</span></span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;Client connected: &quot;</span></span><br><span class="line">                  &lt;&lt; client_socket.<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>().<span class="built_in">to_string</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; client_socket.<span class="built_in">remote_endpoint</span>().<span class="built_in">port</span>() &lt;&lt; std:: endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 与客户端通信</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 接收数据</span></span><br><span class="line">            boost::system:: error_code error;</span><br><span class="line">            <span class="type">char</span> buffer [<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="type">size_t</span> len = client_socket.<span class="built_in">read_some</span>(boost::asio:: <span class="built_in">buffer</span>(buffer), error);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (error == boost::asio::error:: eof) &#123;</span><br><span class="line">                std:: cout &lt;&lt; <span class="string">&quot;Client disconnected.&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 连接正常关闭</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> boost::system:: <span class="built_in">system_error</span>(error); <span class="comment">// 其他错误</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std:: cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; buffer &lt;&lt; std:: endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送响应</span></span><br><span class="line">            std:: string response = <span class="string">&quot;Server received: &quot;</span> + std:: <span class="built_in">string</span>(buffer);</span><br><span class="line">            boost::asio:: <span class="built_in">write</span>(client_socket, boost::asio:: <span class="built_in">buffer</span>(response));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std:: exception&amp; e) &#123;</span><br><span class="line">        std:: cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std:: endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="客户端代码（同步阻塞模型）"><a href="#客户端代码（同步阻塞模型）" class="headerlink" title="客户端代码（同步阻塞模型）"></a><strong>客户端代码（同步阻塞模型）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost:: asio;</span><br><span class="line"><span class="keyword">using</span> ip:: tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 I/O 上下文</span></span><br><span class="line">        io_context io_context;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建 Socket 并连接到服务端</span></span><br><span class="line">        tcp:: <span class="function">socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">        socket.<span class="built_in">connect</span>(tcp:: <span class="built_in">endpoint</span>(ip::address:: <span class="built_in">from_string</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span>));</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;Connected to server.&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 与服务端通信</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            std:: string message;</span><br><span class="line">            std:: cout &lt;&lt; <span class="string">&quot;Enter message (q to quit): &quot;</span>;</span><br><span class="line">            std:: <span class="built_in">getline</span>(std:: cin, message);</span><br><span class="line">            <span class="keyword">if</span> (message == <span class="string">&quot;q&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            boost::asio:: <span class="built_in">write</span>(socket, boost::asio:: <span class="built_in">buffer</span>(message));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收响应</span></span><br><span class="line">            <span class="type">char</span> buffer [<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="type">size_t</span> len = socket.<span class="built_in">read_some</span>(boost::asio:: <span class="built_in">buffer</span>(buffer));</span><br><span class="line">            std:: cout &lt;&lt; <span class="string">&quot;Server response: &quot;</span> &lt;&lt; buffer &lt;&lt; std:: endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std:: exception&amp; e) &#123;</span><br><span class="line">        std:: cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std:: endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a><strong>代码详解</strong></h3><h4 id="服务端关键步骤"><a href="#服务端关键步骤" class="headerlink" title="服务端关键步骤"></a><strong>服务端关键步骤</strong></h4><ol>
<li><p><strong>创建 <code>io_context</code></strong>：</p>
<ul>
<li>Boost.Asio 的核心类，负责调度异步操作（本例中为同步操作）。</li>
</ul>
</li>
<li><p><strong>创建 <code>tcp::acceptor</code></strong>：</p>
<ul>
<li>绑定到 <code>tcp::v4()</code>（所有 IPv4 接口）和端口 <code>8080</code>，开始监听连接请求。</li>
</ul>
</li>
<li><p><strong>接受客户端连接</strong>：</p>
<ul>
<li><code>acceptor.accept(client_socket)</code> 阻塞等待客户端连接。</li>
<li>连接成功后，<code>client_socket</code> 用于与客户端通信。</li>
</ul>
</li>
<li><p><strong>读写数据</strong>：</p>
<ul>
<li><code>read_some</code> 读取客户端数据（阻塞直到数据到达）。</li>
<li><code>write</code> 发送响应数据。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="客户端关键步骤"><a href="#客户端关键步骤" class="headerlink" title="客户端关键步骤"></a><strong>客户端关键步骤</strong></h4><ol>
<li><strong>创建 <code>io_context</code></strong>：与服务端一致。</li>
<li><strong>连接服务端</strong>：<ul>
<li><code>socket.connect()</code> 连接到服务端的终端节点（<code>127.0.0.1:8080</code>）。</li>
</ul>
</li>
<li><strong>读写数据</strong>：<ul>
<li>用户输入消息后发送给服务端。</li>
<li><code>read_some</code> 接收服务端响应。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a><strong>编译与运行</strong></h3><h4 id="1-安装-Boost-库"><a href="#1-安装-Boost-库" class="headerlink" title="1. 安装 Boost 库"></a><strong>1. 安装 Boost 库</strong></h4><ul>
<li><strong>Ubuntu</strong>: <code>sudo apt-get install libboost-all-dev</code></li>
<li><strong>Windows</strong>: 下载 <a target="_blank" rel="noopener" href="https://www.boost.org/">Boost 源码</a>，编译并配置开发环境。</li>
</ul>
<h4 id="2-编译命令（Linux）"><a href="#2-编译命令（Linux）" class="headerlink" title="2. 编译命令（Linux）"></a><strong>2. 编译命令（Linux）</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line">g++ server.cpp -o server -lboost_system -pthread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line">g++ client.cpp -o client -lboost_system -pthread</span><br></pre></td></tr></table></figure>

<h4 id="3-运行"><a href="#3-运行" class="headerlink" title="3. 运行"></a><strong>3. 运行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务端</span></span><br><span class="line">./server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动客户端（另开终端）</span></span><br><span class="line">./client</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="流程示意图"><a href="#流程示意图" class="headerlink" title="流程示意图"></a><strong>流程示意图</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">服务端                             客户端</span><br><span class="line">1. 创建 Acceptor，绑定 8080 端口</span><br><span class="line">2. 阻塞等待连接（accept()）</span><br><span class="line">                                   1. 创建 Socket</span><br><span class="line">                                   2. 连接服务端（connect()）</span><br><span class="line">3. 接受连接，创建 client_socket</span><br><span class="line">                                   3. 发送数据（write()）</span><br><span class="line">4. 读取数据（read_some()）</span><br><span class="line">5. 发送响应（write()）</span><br><span class="line">                                   4. 接收响应（read_some()）</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关键概念回顾"><a href="#关键概念回顾" class="headerlink" title="关键概念回顾"></a><strong>关键概念回顾</strong></h3><table>
<thead>
<tr>
<th>类&#x2F;函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>boost::asio:: io_context</code></td>
<td>管理异步操作的核心基础设施（本例中用于同步操作）。</td>
</tr>
<tr>
<td><code>tcp::acceptor</code></td>
<td>服务端用于监听和接受新连接的组件。</td>
</tr>
<tr>
<td><code>tcp::socket</code></td>
<td>表示一个网络连接，用于读写数据。</td>
</tr>
<tr>
<td><code>tcp::endpoint</code></td>
<td>终端节点，由 IP 地址和端口号构成（如 <code>127.0.0.1:8080</code>）。</td>
</tr>
<tr>
<td><code>read_some</code>&#x2F;<code>write</code></td>
<td>同步读写数据的函数（阻塞直到操作完成）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="扩展：如何处理多个客户端？"><a href="#扩展：如何处理多个客户端？" class="headerlink" title="扩展：如何处理多个客户端？"></a><strong>扩展：如何处理多个客户端？</strong></h3><p>上述服务端只能同时处理一个客户端。要支持并发，可以通过以下方式改进：</p>
<ol>
<li><strong>多线程</strong>：每个客户端连接后创建一个线程处理。</li>
<li><strong>异步模型</strong>：使用 <code>async_accept</code> 和 <code>async_read</code>&#x2F;<code>async_write</code> 实现非阻塞 IO。</li>
</ol>
<p><strong>多线程服务端示例片段</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 accept 后创建线程处理客户端</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function">tcp::socket <span class="title">client_socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    acceptor.<span class="built_in">accept</span>(client_socket);</span><br><span class="line">    std::<span class="built_in">thread</span>([client_socket = std::<span class="built_in">move</span>(client_socket)]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="comment">// 在此线程中处理 client_socket 的读写</span></span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>通过这个示例，你可以清晰地看到 Boost.Asio 如何实现网络通信的核心流程。实际开发中，可根据需求选择同步或异步模型，并结合线程池等技术构建高性能服务器。</p>
<h2 id="Socket-生命周期管理"><a href="#Socket-生命周期管理" class="headerlink" title="Socket 生命周期管理"></a><strong>Socket 生命周期管理</strong></h2><p>你的问题触及到网络编程中 <strong>Socket 生命周期管理</strong> 的核心机制。理解以下分层逻辑后，这个设计会变得非常清晰：</p>
<hr>
<h3 id="Socket-的阶段性角色"><a href="#Socket-的阶段性角色" class="headerlink" title="Socket 的阶段性角色"></a><strong>Socket 的阶段性角色</strong></h3><p>Socket 的工作流程是分阶段的，不同阶段需要不同的信息：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>所需信息</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td><strong>创建阶段</strong></td>
<td>协议（TCP&#x2F;UDP）、I&#x2F;O 上下文</td>
<td>初始化操作系统资源，确定传输协议（TCP 面向连接&#x2F;UDP 无连接）</td>
</tr>
<tr>
<td><strong>绑定阶段</strong></td>
<td>本地 IP + Port（服务端需要）</td>
<td>服务端固定监听地址，客户端通常由系统自动分配</td>
</tr>
<tr>
<td><strong>连接阶段</strong></td>
<td>对端 IP + Port（客户端需要）</td>
<td>客户端主动指定服务端地址</td>
</tr>
<tr>
<td><strong>通信阶段</strong></td>
<td>已建立连接的两个端点</td>
<td>数据传输</td>
</tr>
</tbody></table>
<hr>
<h3 id="为什么创建-Socket-时不需端点信息？"><a href="#为什么创建-Socket-时不需端点信息？" class="headerlink" title="为什么创建 Socket 时不需端点信息？"></a><strong>为什么创建 Socket 时不需端点信息？</strong></h3><h4 id="1-Socket-的抽象性"><a href="#1-Socket-的抽象性" class="headerlink" title="(1) Socket 的抽象性"></a><strong>(1) Socket 的抽象性</strong></h4><ul>
<li><strong>Socket 是通信的“句柄”</strong>，类似文件描述符（File Descriptor）。</li>
<li>创建 Socket 时，操作系统只为通信预留资源，并未绑定具体地址。</li>
<li>类比：买一部手机（创建 Socket），但尚未插入 SIM 卡（未绑定 IP&#x2F;Port）。</li>
</ul>
<h4 id="2-端点信息的动态性"><a href="#2-端点信息的动态性" class="headerlink" title="(2) 端点信息的动态性"></a><strong>(2) 端点信息的动态性</strong></h4><ul>
<li><strong>服务端</strong>：需要先绑定自己的 IP + Port（通过 <code>bind()</code>），再监听连接。</li>
<li><strong>客户端</strong>：通常不手动绑定 IP + Port（由系统自动分配临时端口），但需通过 <code>connect()</code> 指定服务端的 IP + Port。</li>
<li><strong>核心逻辑</strong>：端点信息是在 <strong>不同阶段动态附加到 Socket</strong> 的，而非创建时固定。</li>
</ul>
<hr>
<h3 id="完整流程示例"><a href="#完整流程示例" class="headerlink" title="完整流程示例"></a><strong>完整流程示例</strong></h3><h4 id="服务端代码（附加端点信息的阶段）"><a href="#服务端代码（附加端点信息的阶段）" class="headerlink" title="服务端代码（附加端点信息的阶段）"></a><strong>服务端代码（附加端点信息的阶段）</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 Socket（无端点信息）</span></span><br><span class="line">asio::ip::tcp:: <span class="function">socket <span class="title">socket</span><span class="params">(io_context, asio::ip::tcp:: v4())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定本地端点（服务端必须）</span></span><br><span class="line">asio::ip::tcp:: <span class="function">endpoint <span class="title">local_endpoint</span><span class="params">(asio::ip::address_v4:: any(), <span class="number">8080</span>)</span></span>;</span><br><span class="line">socket.<span class="built_in">bind</span>(local_endpoint); <span class="comment">// 绑定 0.0.0.0:8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 监听连接</span></span><br><span class="line">socket.<span class="built_in">listen</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 接受客户端连接（此时获取对端端点信息）</span></span><br><span class="line">asio::ip::tcp:: endpoint remote_endpoint;</span><br><span class="line">asio::ip::tcp:: socket client_socket = socket.<span class="built_in">accept</span>(remote_endpoint);</span><br><span class="line"><span class="comment">// remote_endpoint 包含客户端的 IP + Port</span></span><br></pre></td></tr></table></figure>

<h4 id="客户端代码（附加端点信息的阶段）"><a href="#客户端代码（附加端点信息的阶段）" class="headerlink" title="客户端代码（附加端点信息的阶段）"></a><strong>客户端代码（附加端点信息的阶段）</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 Socket（无端点信息）</span></span><br><span class="line">asio::ip::tcp:: <span class="function">socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 连接服务端（指定对端端点）</span></span><br><span class="line">asio::ip::tcp:: <span class="function">endpoint <span class="title">server_endpoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    asio::ip::address:: from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">socket.<span class="built_in">connect</span>(server_endpoint); <span class="comment">// 连接到服务端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 本地端点由系统自动分配（可通过 local_endpoint() 获取）</span></span><br><span class="line">asio::ip::tcp:: endpoint local_endpoint = socket.<span class="built_in">local_endpoint</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关键机制解释"><a href="#关键机制解释" class="headerlink" title="关键机制解释"></a>关键机制解释</h3><h4 id="1-客户端端口的自动分配"><a href="#1-客户端端口的自动分配" class="headerlink" title="(1) 客户端端口的自动分配"></a><strong>(1) 客户端端口的自动分配</strong></h4><ul>
<li>客户端通常不需要手动绑定端口，系统会分配一个临时端口（Ephemeral Port，范围通常为 32768~60999）。</li>
<li>通过 <code>socket.local_endpoint()</code> 可获取自动分配的本地端点。</li>
</ul>
<h4 id="2-服务端端口的固定性"><a href="#2-服务端端口的固定性" class="headerlink" title="(2) 服务端端口的固定性"></a><strong>(2) 服务端端口的固定性</strong></h4><ul>
<li>服务端必须绑定固定端口（如 <code>80</code>），以便客户端明确连接目标。</li>
<li>若服务端不绑定端口，客户端将无法找到它。</li>
</ul>
<h4 id="3-端点信息的延迟绑定"><a href="#3-端点信息的延迟绑定" class="headerlink" title="(3) 端点信息的延迟绑定"></a><strong>(3) 端点信息的延迟绑定</strong></h4><ul>
<li><strong>设计优势</strong>：允许 Socket 在不同场景下复用（如先绑定再监听，或先创建再连接）。</li>
<li><strong>资源优化</strong>：避免在未确定用途时占用网络资源。</li>
</ul>
<hr>
<h3 id="完整通信流程中的端点信息流"><a href="#完整通信流程中的端点信息流" class="headerlink" title="完整通信流程中的端点信息流"></a>完整通信流程中的端点信息流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端 Socket 生命周期：</span><br><span class="line">创建 → 连接（指定服务端端点） → 通信（自动分配本地端点 + 已知对端端点）</span><br><span class="line"></span><br><span class="line">服务端 Socket 生命周期：</span><br><span class="line">创建 → 绑定（指定本地端点） → 监听 → 接受连接（获取客户端端点） → 通信</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>Socket 创建</strong>：仅初始化通信能力和协议，不涉及具体地址。</li>
<li><strong>端点信息动态附加</strong>：通过 <code>bind()</code>（服务端）和 <code>connect()</code>（客户端）在后续阶段指定。</li>
<li><strong>设计哲学</strong>：将资源分配与地址绑定解耦，提高灵活性和资源利用率。</li>
</ul>
<p>这种分层设计允许开发者更灵活地控制 Socket 的行为，例如：</p>
<ul>
<li>同一个 Socket 可先绑定到不同地址测试兼容性。</li>
<li>客户端 Socket 可在不同时间连接到不同服务端。</li>
</ul>
<h2 id="boost-asio-ip-tcp-acceptor-的详细解析"><a href="#boost-asio-ip-tcp-acceptor-的详细解析" class="headerlink" title="boost::asio::ip::tcp:: acceptor 的详细解析"></a><strong><code>boost::asio::ip::tcp:: acceptor</code></strong> 的详细解析</h2><p><code>acceptor</code> 是 Boost.Asio 中服务端监听和接受客户端连接的核心组件。</p>
<hr>
<h3 id="一、tcp-acceptor-的作用"><a href="#一、tcp-acceptor-的作用" class="headerlink" title="一、tcp::acceptor 的作用"></a><strong>一、<code>tcp::acceptor</code> 的作用</strong></h3><p><code>tcp::acceptor</code> 是服务端专用的类，用于 <strong>监听指定端口</strong> 并 <strong>接受客户端的连接请求</strong>。它的工作流程如下：</p>
<ol>
<li><strong>绑定到本地端口</strong>（通过 <code>bind()</code>）。</li>
<li><strong>开始监听</strong>（通过 <code>listen()</code>）。</li>
<li><strong>接受连接</strong>（通过 <code>accept()</code>），并为每个客户端创建一个新的 <code>tcp::socket</code> 用于通信。</li>
</ol>
<hr>
<h3 id="二、核心方法详解"><a href="#二、核心方法详解" class="headerlink" title="二、核心方法详解"></a><strong>二、核心方法详解</strong></h3><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a><strong>1. 构造函数</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：创建未绑定的 acceptor</span></span><br><span class="line"><span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：直接绑定到指定端点（推荐）</span></span><br><span class="line"><span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(tcp::v4(), <span class="number">8080</span>)</span></span>; <span class="comment">// 监听所有 IPv4 地址的 8080 端口</span></span><br><span class="line"><span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, endpoint)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-bind-绑定到本地端点"><a href="#2-bind-绑定到本地端点" class="headerlink" title="2. bind() - 绑定到本地端点"></a><strong>2. <code>bind()</code> - 绑定到本地端点</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boost::system:: error_code ec;</span><br><span class="line">tcp:: <span class="function">endpoint <span class="title">endpoint</span><span class="params">(tcp:: v4(), <span class="number">8080</span>)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">bind</span>(endpoint, ec); <span class="comment">// 绑定到 0.0.0.0:8080</span></span><br><span class="line"><span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    std:: cerr &lt;&lt; <span class="string">&quot;Bind failed: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std:: endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-listen-开始监听"><a href="#3-listen-开始监听" class="headerlink" title="3. listen() - 开始监听"></a><strong>3. <code>listen()</code> - 开始监听</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acceptor.<span class="built_in">listen</span>(boost::asio::socket_base:: max_listen_connections, ec);</span><br><span class="line"><span class="comment">// 参数 1：最大等待连接队列长度（通常设为 SOMAXCONN）</span></span><br><span class="line"><span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    std:: cerr &lt;&lt; <span class="string">&quot;Listen failed: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std:: endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-accept-接受连接"><a href="#4-accept-接受连接" class="headerlink" title="4. accept() - 接受连接"></a><strong>4. <code>accept()</code> - 接受连接</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tcp:: <span class="function">socket <span class="title">client_socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">accept</span>(client_socket, ec); <span class="comment">// 阻塞直到有客户端连接</span></span><br><span class="line"><span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">    std:: cout &lt;&lt; <span class="string">&quot;Client connected from: &quot;</span> </span><br><span class="line">              &lt;&lt; client_socket.<span class="built_in">remote_endpoint</span>() &lt;&lt; std:: endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-async-accept-异步接受连接"><a href="#5-async-accept-异步接受连接" class="headerlink" title="5. async_accept() - 异步接受连接"></a><strong>5. <code>async_accept()</code> - 异步接受连接</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步接受连接（非阻塞）</span></span><br><span class="line">acceptor.<span class="built_in">async_accept</span>(client_socket, [](<span class="type">const</span> boost::system:: error_code&amp; ec) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;Async client connected.&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="6-其他方法"><a href="#6-其他方法" class="headerlink" title="6. 其他方法"></a><strong>6. 其他方法</strong></h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>local_endpoint()</code></td>
<td>获取绑定的本地端点（IP + Port）</td>
</tr>
<tr>
<td><code>cancel()</code></td>
<td>取消所有异步操作</td>
</tr>
<tr>
<td><code>set_option()</code></td>
<td>设置选项（如 <code>reuse_address</code>）</td>
</tr>
</tbody></table>
<hr>
<h3 id="三、完整代码示例（同步模型）"><a href="#三、完整代码示例（同步模型）" class="headerlink" title="三、完整代码示例（同步模型）"></a><strong>三、完整代码示例（同步模型）</strong></h3><h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a><strong>服务端代码</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost:: asio;</span><br><span class="line"><span class="keyword">using</span> ip:: tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        io_context io_context;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建 acceptor 并绑定到 0.0.0.0:8080</span></span><br><span class="line">        tcp:: <span class="function">acceptor <span class="title">acceptor</span><span class="params">(io_context, tcp:: endpoint(tcp:: v4(), <span class="number">8080</span>))</span></span>;</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;Server listening on 0.0.0.0:8080...&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 设置地址重用（避免端口占用）</span></span><br><span class="line">        acceptor.<span class="built_in">set_option</span>(tcp::acceptor:: <span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. 等待客户端连接</span></span><br><span class="line">            tcp:: <span class="function">socket <span class="title">client_socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">            acceptor.<span class="built_in">accept</span>(client_socket);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 获取客户端地址</span></span><br><span class="line">            std:: cout &lt;&lt; <span class="string">&quot;Client connected: &quot;</span></span><br><span class="line">                      &lt;&lt; client_socket.<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>().<span class="built_in">to_string</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; client_socket.<span class="built_in">remote_endpoint</span>().<span class="built_in">port</span>() &lt;&lt; std:: endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 发送欢迎消息</span></span><br><span class="line">            std:: string message = <span class="string">&quot;Welcome to the server!&quot;</span>;</span><br><span class="line">            boost::asio:: <span class="built_in">write</span>(client_socket, boost::asio:: <span class="built_in">buffer</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std:: exception&amp; e) &#123;</span><br><span class="line">        std:: cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std:: endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、关键概念详解"><a href="#四、关键概念详解" class="headerlink" title="四、关键概念详解"></a><strong>四、关键概念详解</strong></h3><h4 id="1-地址重用-reuse-address"><a href="#1-地址重用-reuse-address" class="headerlink" title="1. 地址重用 (reuse_address)"></a><strong>1. 地址重用 (<code>reuse_address</code>)</strong></h4><ul>
<li><p><strong>问题</strong>：服务端关闭后，端口可能处于 <code>TIME_WAIT</code> 状态，导致无法立即重启。</p>
</li>
<li><p><strong>解决</strong>：通过 <code>set_option(reuse_address(true))</code> 允许立即重用端口。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acceptor.<span class="built_in">set_option</span>(tcp::acceptor:: <span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-同步-vs-异步接受连接"><a href="#2-同步-vs-异步接受连接" class="headerlink" title="2. 同步 vs 异步接受连接"></a><strong>2. 同步 vs 异步接受连接</strong></h4><ul>
<li><strong>同步 (<code>accept()</code>)</strong>：阻塞当前线程，直到有客户端连接。</li>
<li><strong>异步 (<code>async_accept()</code>)</strong>：非阻塞，需配合 <code>io_context::run()</code> 使用，适合高性能服务器。</li>
</ul>
<h4 id="3-处理多个客户端"><a href="#3-处理多个客户端" class="headerlink" title="3. 处理多个客户端"></a><strong>3. 处理多个客户端</strong></h4><ul>
<li><p><strong>多线程</strong>：每接受一个连接，创建一个新线程处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">acceptor.<span class="built_in">accept</span>(client_socket);</span><br><span class="line">std:: <span class="built_in">thread</span>([&amp;client_socket] &#123;</span><br><span class="line">    <span class="comment">// 处理客户端通信</span></span><br><span class="line">&#125;).<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异步模型</strong>：使用 <code>async_accept</code> 链式调用，适合高并发。</p>
</li>
</ul>
<hr>
<h3 id="五、异步接受连接示例"><a href="#五、异步接受连接示例" class="headerlink" title="五、异步接受连接示例"></a><strong>五、异步接受连接示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost:: asio;</span><br><span class="line"><span class="keyword">using</span> ip:: tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Server</span>(io_context&amp; io_context) </span><br><span class="line">        : <span class="built_in">acceptor_</span>(io_context, tcp:: <span class="built_in">endpoint</span>(tcp:: <span class="built_in">v4</span>(), <span class="number">8080</span>)) &#123;</span><br><span class="line">        <span class="built_in">start_accept</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 异步等待连接</span></span><br><span class="line">        acceptor_.<span class="built_in">async_accept</span>(client_socket_,</span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">const</span> boost::system:: error_code&amp; ec) &#123;</span><br><span class="line">                <span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">                    std:: cout &lt;&lt; <span class="string">&quot;Async client connected.&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">                    <span class="comment">// 处理客户端通信...</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">start_accept</span>(); <span class="comment">// 继续接受下一个连接</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tcp:: acceptor acceptor_;</span><br><span class="line">    tcp:: socket client_socket_&#123;acceptor_.<span class="built_in">get_executor</span>()&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        io_context io_context;</span><br><span class="line">        <span class="function">Server <span class="title">server</span><span class="params">(io_context)</span></span>;</span><br><span class="line">        io_context.<span class="built_in">run</span>(); <span class="comment">// 启动事件循环</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (std:: exception&amp; e) &#123;</span><br><span class="line">        std:: cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std:: endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a><strong>六、总结</strong></h3><ul>
<li><strong><code>tcp::acceptor</code> 的核心作用</strong>：服务端监听端口并接受客户端连接。</li>
<li><strong>关键操作</strong>：<code>bind()</code>, <code>listen()</code>, <code>accept()</code>。</li>
<li><strong>设计选择</strong>：<ul>
<li>同步模型简单，适合低频连接。</li>
<li>异步模型高效，适合高并发场景。</li>
</ul>
</li>
<li><strong>实际应用</strong>：结合多线程或异步模型构建高性能服务器。</li>
</ul>
<p>在 Boost.Asio 中，<strong><code>acceptor</code> 不是普通的 Socket</strong>，但它与 Socket 有密切的关联。具体来说：</p>
<hr>
<h3 id="acceptor-的本质"><a href="#acceptor-的本质" class="headerlink" title="acceptor 的本质"></a><strong><code>acceptor</code> 的本质</strong></h3><ul>
<li><p><strong><code>acceptor</code> 是 <code>basic_socket_acceptor</code> 的实例</strong>，而普通 Socket（如 <code>tcp::socket</code>）是 <code>basic_stream_socket</code> 的实例。</p>
</li>
<li><p>两者都继承自 <code>basic_socket</code>，但用途不同：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>直接基类</th>
</tr>
</thead>
<tbody><tr>
<td><code>tcp::acceptor</code></td>
<td>监听和接受连接</td>
<td><code>basic_socket_acceptor</code></td>
</tr>
<tr>
<td><code>tcp::socket</code></td>
<td>数据传输（读写）</td>
<td><code>basic_stream_socket</code></td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="设计逻辑"><a href="#设计逻辑" class="headerlink" title="** 设计逻辑**"></a>** 设计逻辑**</h3><ul>
<li><strong>监听 Socket（<code>acceptor</code>）</strong>：<br>专门用于服务端监听端口并接受连接请求，<strong>不参与数据传输</strong>。<ul>
<li>示例：客服中心的总机电话（只接听来电，转接分机）。</li>
</ul>
</li>
<li><strong>数据 Socket（<code>tcp::socket</code>）</strong>：<br>用于与客户端建立连接后收发数据。<ul>
<li>示例：分机电话（与客户通话）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a><strong>代码验证</strong></h3><p>通过继承关系可以验证二者的差异：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查类型关系</span></span><br><span class="line"><span class="built_in">static_assert</span>(std:: is_base_of_v &lt; boost::asio:: basic_socket &lt; boost::asio::ip:: tcp &gt;, boost::asio::ip::tcp:: acceptor &gt;);</span><br><span class="line"><span class="built_in">static_assert</span>(std:: is_base_of_v &lt; boost::asio:: basic_socket &lt; boost::asio::ip:: tcp &gt;, boost::asio::ip::tcp:: socket &gt;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>tcp::acceptor</code> 和 <code>tcp::socket</code> 均派生自 <code>basic_socket</code>，但属于不同的子类。</li>
</ul>
<hr>
<h3 id="功能区别"><a href="#功能区别" class="headerlink" title="功能区别"></a><strong>功能区别</strong></h3><table>
<thead>
<tr>
<th>功能</th>
<th><code>tcp::acceptor</code></th>
<th><code>tcp::socket</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>监听端口</strong></td>
<td>✅ 通过 <code>bind()</code> + <code>listen()</code></td>
<td>❌ 不支持</td>
</tr>
<tr>
<td><strong>接受连接</strong></td>
<td>✅ 通过 <code>accept()</code></td>
<td>❌ 不支持</td>
</tr>
<tr>
<td><strong>发送&#x2F;接收数据</strong></td>
<td>❌ 不支持</td>
<td>✅ 通过 <code>read()</code>&#x2F;<code>write()</code></td>
</tr>
<tr>
<td><strong>连接对端</strong></td>
<td>❌ 不支持</td>
<td>✅ 通过 <code>connect()</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="** 代码示例**"></a>** 代码示例**</h3><h4 id="服务端使用-acceptor-和-socket："><a href="#服务端使用-acceptor-和-socket：" class="headerlink" title="服务端使用 acceptor 和 socket："></a>服务端使用 <code>acceptor</code> 和 <code>socket</code>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost:: asio;</span><br><span class="line"><span class="keyword">using</span> ip:: tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建 acceptor（监听 Socket）</span></span><br><span class="line">    tcp:: <span class="function">acceptor <span class="title">acceptor</span><span class="params">(io_context, tcp:: endpoint(tcp:: v4(), <span class="number">8080</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 接受连接，生成数据 Socket</span></span><br><span class="line">    tcp:: <span class="function">socket <span class="title">client_socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    acceptor.<span class="built_in">accept</span>(client_socket); <span class="comment">// 生成用于通信的 Socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通过 client_socket 读写数据</span></span><br><span class="line">    boost::asio:: <span class="built_in">write</span>(client_socket, boost::asio:: <span class="built_in">buffer</span>(<span class="string">&quot;Hello Client&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong><code>acceptor</code> 是监听专用的 Socket</strong>：<br>继承自 <code>basic_socket</code>，但功能仅限于监听和接受连接。</li>
<li><strong>普通 <code>socket</code> 是数据通信的 Socket</strong>：<br>继承自 <code>basic_stream_socket</code>，用于连接后的数据传输。</li>
<li><strong>二者分工明确</strong>：<br><code>acceptor</code> 负责“接电话”，<code>socket</code> 负责“通话”。</li>
</ul>
<h2 id="线程池：从入门到精通"><a href="#线程池：从入门到精通" class="headerlink" title="线程池：从入门到精通"></a>线程池：从入门到精通</h2><h3 id="线程池基础"><a href="#线程池基础" class="headerlink" title="线程池基础"></a>线程池基础</h3><p><strong>1. 什么是线程池？</strong><br>线程池是一种多线程处理技术，预先创建一组线程并管理其生命周期，用于高效执行多个任务。通过复用线程，减少创建和销毁线程的开销，提升系统性能。</p>
<p><strong>2. 为什么需要线程池？</strong></p>
<ul>
<li><strong>减少开销</strong>：频繁创建&#x2F;销毁线程消耗资源。</li>
<li><strong>控制并发</strong>：避免无限制创建线程导致系统崩溃。</li>
<li><strong>提高响应</strong>：任务到达时，立即有可用线程处理。</li>
<li><strong>统一管理</strong>：集中管理线程状态、优先级和资源。</li>
</ul>
<p><strong>3. 线程池核心组件</strong></p>
<ul>
<li><strong>任务队列</strong>：存储待处理的任务（线程安全）。</li>
<li><strong>工作线程</strong>：执行任务的线程集合。</li>
<li><strong>线程管理器</strong>：动态调整线程数量，监控状态。</li>
</ul>
<hr>
<h3 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h3><p><strong>1. 任务提交</strong><br>用户将任务提交到线程池的任务队列中。</p>
<p><strong>2. 任务调度</strong></p>
<ul>
<li>若核心线程未满，创建新线程执行任务。</li>
<li>若核心线程已满，任务进入队列等待。</li>
<li>若队列满且线程数未达最大值，创建临时线程。</li>
<li>若队列满且线程数已达最大值，触发拒绝策略。</li>
</ul>
<p><strong>3. 线程执行</strong><br>工作线程从队列中取出任务并执行。</p>
<p><strong>4. 线程回收</strong></p>
<ul>
<li>核心线程常驻，除非池关闭。</li>
<li>非核心线程空闲超时后被终止。</li>
</ul>
<hr>
<h3 id="线程池关键参数"><a href="#线程池关键参数" class="headerlink" title="线程池关键参数"></a>线程池关键参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心线程数</strong></td>
<td>线程池保持的最小活动线程数</td>
</tr>
<tr>
<td><strong>最大线程数</strong></td>
<td>线程池允许的最大线程数</td>
</tr>
<tr>
<td><strong>任务队列容量</strong></td>
<td>队列可存放的最大任务数</td>
</tr>
<tr>
<td><strong>空闲线程存活时间</strong></td>
<td>非核心线程空闲多久后被回收</td>
</tr>
<tr>
<td><strong>拒绝策略</strong></td>
<td>队列和线程全满时如何处理新任务</td>
</tr>
</tbody></table>
<p><strong>拒绝策略类型：</strong></p>
<ul>
<li><strong>AbortPolicy</strong>：抛出异常（默认）。</li>
<li><strong>DiscardPolicy</strong>：静默丢弃新任务。</li>
<li><strong>DiscardOldestPolicy</strong>：丢弃队列中最旧的任务，尝试重新提交。</li>
<li><strong>CallerRunsPolicy</strong>：由提交任务的线程直接执行。</li>
</ul>
<hr>
<h3 id="实现一个简单线程池（C-示例）"><a href="#实现一个简单线程池（C-示例）" class="headerlink" title="实现一个简单线程池（C++示例）"></a>实现一个简单线程池（C++示例）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span> num_threads) : <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">            workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    std:: function &lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std:: unique_lock &lt;std::mutex&gt; <span class="built_in">lock</span>(queue_mutex);</span><br><span class="line">                        condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || ! tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">                        task = std:: <span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">                        tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std:: unique_lock &lt;std::mutex&gt; <span class="built_in">lock</span>(queue_mutex);</span><br><span class="line">            tasks.<span class="built_in">emplace</span>(std:: forward &lt;F&gt;(f));</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std:: unique_lock &lt;std::mutex&gt; <span class="built_in">lock</span>(queue_mutex);</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span> (std:: thread &amp;worker : workers) &#123;</span><br><span class="line">            worker.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std:: vector &lt;std::thread&gt; workers;</span><br><span class="line">    std:: queue &lt;std::function&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line">    std:: mutex queue_mutex;</span><br><span class="line">    std:: condition_variable condition;</span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// 创建 4 个线程的线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交 10 个任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        pool.<span class="built_in">enqueue</span>([i] &#123;</span><br><span class="line">            std:: cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; executed by thread &quot;</span> </span><br><span class="line">                      &lt;&lt; std::this_thread:: <span class="built_in">get_id</span>() &lt;&lt; std:: endl;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析：</strong></p>
<ul>
<li><strong>构造函数</strong>：创建指定数量的工作线程，每个线程循环等待任务。</li>
<li><strong>enqueue</strong>：将任务添加到队列，并通知一个等待线程。</li>
<li><strong>析构函数</strong>：设置停止标志，唤醒所有线程并等待其结束。</li>
</ul>
<hr>
<h3 id="线程池高级主题"><a href="#线程池高级主题" class="headerlink" title="线程池高级主题"></a>线程池高级主题</h3><p><strong>1. 动态调整线程池参数</strong></p>
<ul>
<li>根据系统负载自动调整核心线程数和最大线程数。</li>
<li>示例：CPU密集型任务可设线程数 ≈ CPU核心数，IO密集型可设更多线程。</li>
</ul>
<p><strong>2. 优先级任务队列</strong></p>
<ul>
<li>使用优先队列（如<code>std::priority_queue</code>）实现任务优先级。</li>
<li>高优先级任务先被执行。</li>
</ul>
<p><strong>3. 任务依赖管理</strong></p>
<ul>
<li>使用<code>std::future</code>和<code>std::promise</code>处理任务间依赖。</li>
<li>示例：任务B依赖任务A的结果，A完成后触发B。</li>
</ul>
<p><strong>4. 分布式线程池</strong></p>
<ul>
<li>跨机器调度任务，需结合网络通信（如gRPC、消息队列）。</li>
<li>示例：将计算密集型任务分发到多台服务器执行。</li>
</ul>
<hr>
<h3 id="线程池性能优化"><a href="#线程池性能优化" class="headerlink" title="线程池性能优化"></a>线程池性能优化</h3><p><strong>1. 避免过度同步</strong></p>
<ul>
<li>使用无锁队列（如<code>boost::lockfree:: queue</code>）减少锁竞争。</li>
<li>分区锁：将任务队列分片，每个片使用独立锁。</li>
</ul>
<p><strong>2. 合理配置参数</strong></p>
<ul>
<li><strong>CPU 密集型</strong>：线程数 ≈ CPU 核心数。</li>
<li><strong>IO 密集型</strong>：线程数可适当增加（如 2 倍核心数）。</li>
<li>队列容量根据内存和任务特性调整。</li>
</ul>
<p><strong>3. 监控与调优</strong></p>
<ul>
<li>监控任务执行时间、队列长度、线程活跃数。</li>
<li>使用工具（如 Prometheus+Grafana）可视化指标。</li>
</ul>
<hr>
<h3 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h3><table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>任务堆积</strong></td>
<td>生产速度 &gt; 消费速度</td>
<td>增大线程数或队列容量，优化任务逻辑</td>
</tr>
<tr>
<td><strong>线程泄漏</strong></td>
<td>线程未正确终止</td>
<td>确保析构函数正确释放所有线程</td>
</tr>
<tr>
<td><strong>死锁</strong></td>
<td>锁顺序不当或任务相互等待</td>
<td>统一锁顺序，使用超时锁</td>
</tr>
<tr>
<td><strong>资源竞争</strong></td>
<td>多线程访问共享资源未同步</td>
<td>使用互斥锁或原子操作</td>
</tr>
</tbody></table>
<hr>
<h3 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a>实际应用案例</h3><p><strong>案例 1：Web 服务器请求处理</strong></p>
<ul>
<li><strong>场景</strong>：处理大量 HTTP 请求。</li>
<li><strong>实现</strong>：使用线程池处理每个请求的读取、解析和响应。</li>
<li><strong>优化</strong>：根据请求类型（静态资源 vs 动态计算）动态调整线程优先级。</li>
</ul>
<p><strong>案例 2：批量数据处理</strong></p>
<ul>
<li><strong>场景</strong>：处理日志文件，统计用户行为。</li>
<li><strong>实现</strong>：将文件分块，由线程池并行处理每块数据。</li>
<li><strong>优化</strong>：使用工作窃取（Work Stealing）平衡负载。</li>
</ul>
<hr>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li><strong>避免长时间阻塞任务</strong>：防止线程长时间占用，影响其他任务。</li>
<li><strong>优雅关闭</strong>：等待所有任务完成后再终止线程池。</li>
<li><strong>异常处理</strong>：捕获任务中的异常，避免线程崩溃。</li>
<li><strong>资源限制</strong>：根据系统资源（CPU、内存）合理配置线程池。</li>
</ol>
<hr>
<p>通过以上内容，您可以从基础到高级全面掌握线程池的设计、实现与优化。实际应用中，结合具体场景调整策略，充分发挥线程池的性能优势。</p>
<hr>
<h2 id="Boost-Asio-缓冲区（boost-asio-buffer）详解"><a href="#Boost-Asio-缓冲区（boost-asio-buffer）详解" class="headerlink" title="Boost.Asio 缓冲区（boost::asio:: buffer）详解"></a>Boost.Asio 缓冲区（<code>boost::asio:: buffer</code>）详解</h2><h3 id="缓冲区的基本概念"><a href="#缓冲区的基本概念" class="headerlink" title="缓冲区的基本概念"></a>缓冲区的基本概念</h3><p>在 Boost.Asio 中，<strong>缓冲区（Buffer）</strong> 用于表示一块连续的内存区域，用于数据的读取和写入。它是网络通信中数据传递的核心载体，封装了内存地址和大小信息，并提供类型安全的接口。</p>
<h3 id="为什么使用-boost-asio-buffer？"><a href="#为什么使用-boost-asio-buffer？" class="headerlink" title="为什么使用 boost::asio:: buffer？"></a>为什么使用 <code>boost::asio:: buffer</code>？</h3><ol>
<li><strong>类型安全</strong>：支持多种容器类型（如数组、<code>std::vector</code>、<code>std::string</code>），避免手动计算大小。</li>
<li><strong>灵活性</strong>：自动推导内存区域的大小和类型，简化代码。</li>
<li><strong>兼容性</strong>：与 Boost.Asio 的异步操作无缝集成，支持分散-聚集（Scatter-Gather）IO。</li>
</ol>
<hr>
<h3 id="缓冲区的创建方式"><a href="#缓冲区的创建方式" class="headerlink" title="缓冲区的创建方式"></a>缓冲区的创建方式</h3><h4 id="从原始数组创建"><a href="#从原始数组创建" class="headerlink" title="从原始数组创建"></a>从原始数组创建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> raw_data[<span class="number">1024</span>];</span><br><span class="line">boost::asio:: mutable_buffer buffer = boost::asio:: <span class="built_in">buffer</span>(raw_data, <span class="built_in">sizeof</span>(raw_data));</span><br></pre></td></tr></table></figure>

<h4 id="从-std-vector-创建"><a href="#从-std-vector-创建" class="headerlink" title="从 std::vector 创建"></a>从 <code>std::vector</code> 创建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std:: vector &lt;<span class="type">char</span>&gt; <span class="built_in">vec_data</span>(<span class="number">1024</span>);</span><br><span class="line">boost::asio:: mutable_buffer buffer = boost::asio:: <span class="built_in">buffer</span>(vec_data);</span><br></pre></td></tr></table></figure>

<h4 id="从-std-string-创建"><a href="#从-std-string-创建" class="headerlink" title="从 std::string 创建"></a>从 <code>std::string</code> 创建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std:: string str_data = <span class="string">&quot;Hello, Boost.Asio!&quot;</span>;</span><br><span class="line">boost::asio:: const_buffer buffer = boost::asio:: <span class="built_in">buffer</span>(str_data); <span class="comment">// 只读缓冲区</span></span><br></pre></td></tr></table></figure>

<h4 id="从智能指针创建（需管理生命周期）"><a href="#从智能指针创建（需管理生命周期）" class="headerlink" title="从智能指针创建（需管理生命周期）"></a>从智能指针创建（需管理生命周期）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> shared_data = std:: make_shared &lt;std::vector&lt;<span class="type">char</span>&gt; &gt;(<span class="number">1024</span>);</span><br><span class="line">boost::asio:: mutable_buffer buffer = boost::asio:: <span class="built_in">buffer</span>(*shared_data);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、缓冲区的类型"><a href="#四、缓冲区的类型" class="headerlink" title="四、缓冲区的类型"></a>四、缓冲区的类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>mutable_buffer</code></strong></td>
<td>可读写的内存区域</td>
<td>接收数据（如 <code>async_read</code>）</td>
</tr>
<tr>
<td><strong><code>const_buffer</code></strong></td>
<td>只读的内存区域</td>
<td>发送数据（如 <code>async_write</code>）</td>
</tr>
</tbody></table>
<hr>
<h3 id="缓冲区的使用示例"><a href="#缓冲区的使用示例" class="headerlink" title="缓冲区的使用示例"></a>缓冲区的使用示例</h3><h4 id="示例-1：同步写入数据"><a href="#示例-1：同步写入数据" class="headerlink" title="示例 1：同步写入数据"></a>示例 1：同步写入数据</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boost::asio:: io_context io;</span><br><span class="line">boost::asio::ip::tcp:: <span class="function">socket <span class="title">socket</span><span class="params">(io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务端（略）</span></span><br><span class="line">std:: string message = <span class="string">&quot;Hello Server!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> bytes_transferred = boost::asio:: <span class="built_in">write</span>(</span><br><span class="line">    socket, </span><br><span class="line">    boost::asio:: <span class="built_in">buffer</span>(message) <span class="comment">// 隐式转换为 const_buffer</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：异步读取数据"><a href="#示例-2：异步读取数据" class="headerlink" title="示例 2：异步读取数据"></a>示例 2：异步读取数据</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std:: vector &lt;<span class="type">char</span>&gt; <span class="built_in">receive_buffer</span>(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_handler</span><span class="params">(<span class="type">const</span> boost::system:: error_code&amp; ec, <span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> </span><br><span class="line">                  &lt;&lt; std:: <span class="built_in">string</span>(receive_buffer.<span class="built_in">data</span>(), bytes_transferred) </span><br><span class="line">                  &lt;&lt; std:: endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动异步读取</span></span><br><span class="line">socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">    boost::asio:: <span class="built_in">buffer</span>(receive_buffer), <span class="comment">// mutable_buffer</span></span><br><span class="line">    read_handler</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="缓冲区的生命周期管理"><a href="#缓冲区的生命周期管理" class="headerlink" title="缓冲区的生命周期管理"></a>缓冲区的生命周期管理</h3><h4 id="关键规则："><a href="#关键规则：" class="headerlink" title="关键规则："></a>关键规则：</h4><ul>
<li><strong>同步操作</strong>：缓冲区只需在调用期间有效。</li>
<li><strong>异步操作</strong>：缓冲区必须保持有效，直到操作完成。</li>
</ul>
<h4 id="安全实践："><a href="#安全实践：" class="headerlink" title="安全实践："></a>安全实践：</h4><ul>
<li><p>使用 <code>std::shared_ptr</code> 管理动态分配的缓冲区：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> buffer = std:: make_shared &lt;std::vector&lt;<span class="type">char</span>&gt; &gt;(<span class="number">1024</span>);</span><br><span class="line">socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">    boost::asio:: <span class="built_in">buffer</span>(*buffer),</span><br><span class="line">    [buffer](<span class="keyword">auto</span> ec, <span class="keyword">auto</span> size) &#123; <span class="comment">/* 操作完成前 buffer 保持有效 */</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="分散-聚集-IO（Scatter-Gather）"><a href="#分散-聚集-IO（Scatter-Gather）" class="headerlink" title="分散-聚集 IO（Scatter-Gather）"></a>分散-聚集 IO（Scatter-Gather）</h3><p>Boost.Asio 允许同时操作多个缓冲区，适用于协议头和消息体分离的场景。</p>
<h4 id="示例：同时写入头和体"><a href="#示例：同时写入头和体" class="headerlink" title="示例：同时写入头和体"></a>示例：同时写入头和体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std:: string header = <span class="string">&quot;HEADER&quot;</span>;</span><br><span class="line">std:: string body = <span class="string">&quot;BODY&quot;</span>;</span><br><span class="line"></span><br><span class="line">std:: array &lt; boost::asio:: const_buffer, 2 &gt; buffers = &#123;</span><br><span class="line">    boost::asio:: <span class="built_in">buffer</span>(header),</span><br><span class="line">    boost::asio:: <span class="built_in">buffer</span>(body)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并写入头和体</span></span><br><span class="line">boost::asio:: <span class="built_in">write</span>(socket, buffers);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="动态缓冲区（dynamic-buffer）"><a href="#动态缓冲区（dynamic-buffer）" class="headerlink" title="动态缓冲区（dynamic_buffer）"></a>动态缓冲区（<code>dynamic_buffer</code>）</h3><p>Boost.Asio 提供 <code>dynamic_buffer</code> 适配器，允许缓冲区在需要时自动扩展。</p>
<h4 id="示例：动态读取数据"><a href="#示例：动态读取数据" class="headerlink" title="示例：动态读取数据"></a>示例：动态读取数据</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">boost::beast:: flat_buffer dynamic_buf; <span class="comment">// 或 boost::asio:: dynamic_buffer(...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步读取直到条件满足</span></span><br><span class="line">boost::asio:: <span class="built_in">async_read_until</span>(</span><br><span class="line">    socket, </span><br><span class="line">    dynamic_buf, </span><br><span class="line">    <span class="string">&quot;\r\n\r\n&quot;</span>, <span class="comment">// 分隔符</span></span><br><span class="line">    [](<span class="keyword">auto</span> ec, <span class="keyword">auto</span> size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">            <span class="comment">// 处理 dynamic_buf 中的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见问题与解决方案-1"><a href="#常见问题与解决方案-1" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h3><table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>缓冲区溢出</strong></td>
<td>接收数据超出缓冲区大小</td>
<td>使用 <code>dynamic_buffer</code> 或动态调整缓冲区</td>
</tr>
<tr>
<td><strong>悬空指针</strong></td>
<td>异步操作中缓冲区提前释放</td>
<td>使用 <code>shared_ptr</code> 管理缓冲区生命周期</td>
</tr>
<tr>
<td><strong>类型不匹配</strong></td>
<td>传递错误的缓冲区类型</td>
<td>确保 <code>async_read</code> 用 <code>mutable_buffer</code>，<code>async_write</code> 用 <code>const_buffer</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>核心作用</strong>：<code>boost::asio:: buffer</code> 封装内存区域，简化数据传递。</li>
<li><strong>关键类型</strong>：<code>mutable_buffer</code>（读写）和 <code>const_buffer</code>（只读）。</li>
<li><strong>生命周期</strong>：异步操作中需确保缓冲区有效。</li>
<li><strong>高级特性</strong>：分散-聚集 IO 和动态缓冲区提升灵活性。</li>
</ul>
<p>通过合理使用缓冲区，可以高效、安全地实现 Boost.Asio 的网络通信功能。</p>
<p>任何网络库都有提供 buffer 的数据结构，所谓 buffer 就是接收和发送数据时缓存数据的结构。<br>boost:: asio 提供了 asio:: mutable_buffer 和 asio:: const_buffer 这两个结构，他们是一段连续的空间，首字节存储了后续数据的长度。<br>asio:: mutable_buffer 用于写服务，asio:: const_buffer 用于读服务。但是这两个结构都没有被 asio 的 api 直接使用。<br>对于 api 的 buffer 参数，asio 提出了 MutableBufferSequence 和 ConstBufferSequence 概念，他们是由多个 asio:: mutable_buffer 和 asio:: const_buffer 组成的。也就是说 boost:: asio 为了节省空间，将一部分连续的空间组合起来，作为参数交给 api 使用。<br>我们可以理解为 MutableBufferSequence 的数据结构为 std:: vector <a href="asio::mutable_buffer">asio:: mutable_buffer</a><br>结构如下</p>
<p><img src="/2025/09/17/C-%E9%9D%A2%E8%AF%95%E9%A2%98/44ad3fa4-8385-4257-a2be-cc8e65bbb364.jpg"></p>
<p>每隔 vector 存储的都是 mutable_buffer 的地址，每个 mutable_buffer 的第一个字节表示数据的长度，后面跟着数据内容。<br>这么复杂的结构交给用户使用并不合适，所以 asio 提出了 buffer()函数，该函数接收多种形式的字节流，该函数返回 asio:: mutable_buffers_1 o 或者 asio:: const_buffers_1 结构的对象。<br>如果传递给 buffer()的参数是一个只读类型，则函数返回 asio:: const_buffers_1 类型对象。<br>如果传递给 buffer()的参数是一个可写类型，则返回 asio:: mutable_buffers_1 类型对象。<br>asio:: const_buffers_1 和 asio:: mutable_buffers_1 是 asio:: mutable_buffer 和 asio:: const_buffer 的适配器，提供了符合 MutableBufferSequence 和 ConstBufferSequence 概念的接口，所以他们可以作为 boost:: asio 的 api 函数的参数使用。<br>简单概括一下，我们可以用 buffer()函数生成我们要用的缓存存储数据。<br>比如 boost 的发送接口 send 要求的参数为 ConstBufferSequence 类型</p>
<h2 id="缓冲序列详解"><a href="#缓冲序列详解" class="headerlink" title="缓冲序列详解"></a>缓冲序列详解</h2><p>在 Boost.Asio 中，<code>asio::const_buffers_1</code> 和 <code>asio::mutable_buffers_1</code> 是用于将单个缓冲区（<code>const_buffer</code> 或 <code>mutable_buffer</code>）适配成符合 <strong>缓冲区序列（Buffer Sequence）</strong> 概念的包装器。它们的核心区别在于 <strong>用途</strong> 和 <strong>类型安全</strong>，下面详细解释：</p>
<hr>
<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><h4 id="1-缓冲区类型"><a href="#1-缓冲区类型" class="headerlink" title="1. 缓冲区类型"></a>1. <strong>缓冲区类型</strong></h4><ul>
<li><strong><code>mutable_buffer</code></strong><br>表示一块 <strong>可修改</strong> 的内存区域（如接收数据的缓冲区）。</li>
<li><strong><code>const_buffer</code></strong><br>表示一块 <strong>只读</strong> 的内存区域（如发送数据的缓冲区）。</li>
</ul>
<h4 id="2-缓冲区序列（Buffer-Sequence）"><a href="#2-缓冲区序列（Buffer-Sequence）" class="headerlink" title="2. 缓冲区序列（Buffer Sequence）"></a>2. <strong>缓冲区序列（Buffer Sequence）</strong></h4><p>Boost.Asio 的许多函数（如 <code>async_read</code>、<code>async_write</code>）要求传入的参数满足 <strong>缓冲区序列概念</strong>（<code>MutableBufferSequence</code> 或 <code>ConstBufferSequence</code>）。  </p>
<ul>
<li><strong><code>MutableBufferSequence</code></strong><br>序列中的每个元素必须是 <code>mutable_buffer</code>。</li>
<li><strong><code>ConstBufferSequence</code></strong><br>序列中的每个元素必须是 <code>const_buffer</code>。</li>
</ul>
<h4 id="3-适配器的作用"><a href="#3-适配器的作用" class="headerlink" title="3. 适配器的作用"></a>3. <strong>适配器的作用</strong></h4><ul>
<li><strong><code>const_buffers_1</code></strong><br>将单个 <code>const_buffer</code> 包装成一个符合 <code>ConstBufferSequence</code> 的序列。</li>
<li><strong><code>mutable_buffers_1</code></strong><br>将单个 <code>mutable_buffer</code> 包装成一个符合 <code>MutableBufferSequence</code> 的序列。</li>
</ul>
<hr>
<h3 id="二、核心区别"><a href="#二、核心区别" class="headerlink" title="二、核心区别"></a>二、核心区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>const_buffers_1</code></th>
<th><code>mutable_buffers_1</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层类型</strong></td>
<td>包装 <code>const_buffer</code></td>
<td>包装 <code>mutable_buffer</code></td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>用于 <strong>发送数据</strong>（如 <code>async_write</code>）</td>
<td>用于 <strong>接收数据</strong>（如 <code>async_read</code>）</td>
</tr>
<tr>
<td><strong>数据可修改性</strong></td>
<td>不可修改（只读）</td>
<td>可修改（读写）</td>
</tr>
<tr>
<td><strong>序列概念</strong></td>
<td>符合 <code>ConstBufferSequence</code></td>
<td>符合 <code>MutableBufferSequence</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="三、为什么需要这些适配器？"><a href="#三、为什么需要这些适配器？" class="headerlink" title="三、为什么需要这些适配器？"></a>三、为什么需要这些适配器？</h3><p>Boost.Asio 的函数设计需要支持 <strong>分散-聚集 I&#x2F;O（Scatter-Gather I&#x2F;O）</strong>，即同时操作多个缓冲区。例如：</p>
<ul>
<li><strong>发送多个数据块</strong>：将多个 <code>const_buffer</code> 合并发送。</li>
<li><strong>接收数据到多个缓冲区</strong>：将数据分散写入多个 <code>mutable_buffer</code>。</li>
</ul>
<p><strong>问题</strong>：如果用户只传递单个缓冲区（如 <code>mutable_buffer</code> 或 <code>const_buffer</code>），如何让这些函数统一处理？</p>
<p><strong>答案</strong>：通过 <code>const_buffers_1</code> 和 <code>mutable_buffers_1</code> 将单个缓冲区包装成 <strong>单元素序列</strong>，使其符合缓冲区序列的接口要求。</p>
<hr>
<h3 id="四、实际用法示例"><a href="#四、实际用法示例" class="headerlink" title="四、实际用法示例"></a>四、实际用法示例</h3><h4 id="1-发送数据（使用-const-buffers-1）"><a href="#1-发送数据（使用-const-buffers-1）" class="headerlink" title="1. 发送数据（使用 const_buffers_1）"></a>1. <strong>发送数据（使用 <code>const_buffers_1</code>）</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::string data = <span class="string">&quot;Hello Server!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 const_buffer（隐式转换为 const_buffers_1）</span></span><br><span class="line">boost::asio:: const_buffers_1 send_buf = boost::asio:: <span class="built_in">buffer</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步发送（需要 ConstBufferSequence）</span></span><br><span class="line">boost::asio:: <span class="built_in">async_write</span>(socket, send_buf, [](<span class="keyword">auto</span> ec, <span class="keyword">auto</span> size) &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-接收数据（使用-mutable-buffers-1）"><a href="#2-接收数据（使用-mutable-buffers-1）" class="headerlink" title="2. 接收数据（使用 mutable_buffers_1）"></a>2. <strong>接收数据（使用 <code>mutable_buffers_1</code>）</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std:: vector &lt;<span class="type">char</span>&gt; <span class="built_in">recv_buf</span>(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 mutable_buffer（隐式转换为 mutable_buffers_1）</span></span><br><span class="line">boost::asio:: mutable_buffers_1 recv_buf_seq = boost::asio:: <span class="built_in">buffer</span>(recv_buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步接收（需要 MutableBufferSequence）</span></span><br><span class="line">boost::asio:: <span class="built_in">async_read</span>(socket, recv_buf_seq, [](<span class="keyword">auto</span> ec, <span class="keyword">auto</span> size) &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-手动创建适配器"><a href="#3-手动创建适配器" class="headerlink" title="3. 手动创建适配器"></a>3. <strong>手动创建适配器</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> raw_data [<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动包装 mutable_buffer</span></span><br><span class="line">boost::asio:: <span class="function">mutable_buffers_1 <span class="title">buf1</span><span class="params">(boost::asio:: buffer(raw_data))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动包装 const_buffer</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">boost::asio:: <span class="function">const_buffers_1 <span class="title">buf2</span><span class="params">(boost::asio:: buffer(cstr, <span class="number">5</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="五、底层实现分析"><a href="#五、底层实现分析" class="headerlink" title="五、底层实现分析"></a>五、底层实现分析</h3><h4 id="1-const-buffers-1-的定义"><a href="#1-const-buffers-1-的定义" class="headerlink" title="1. const_buffers_1 的定义"></a>1. <strong><code>const_buffers_1</code> 的定义</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">const_buffers_1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">const_buffers_1</span><span class="params">(<span class="type">const</span> const_buffer&amp; b)</span> : buffer_(b) &#123;</span>&#125;</span><br><span class="line">    <span class="function">const_buffer* <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;buffer_; &#125;</span><br><span class="line">    <span class="function">const_buffer* <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;buffer_ + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    const_buffer buffer_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>它是一个单元素序列，迭代器范围是 <code>[&amp;buffer_, &amp;buffer_ + 1)</code>。</li>
</ul>
<h4 id="2-mutable-buffers-1-的定义"><a href="#2-mutable-buffers-1-的定义" class="headerlink" title="2. mutable_buffers_1 的定义"></a>2. <strong><code>mutable_buffers_1</code> 的定义</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mutable_buffers_1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mutable_buffers_1</span><span class="params">(<span class="type">const</span> mutable_buffer&amp; b)</span> : buffer_(b) &#123;</span>&#125;</span><br><span class="line">    <span class="function">mutable_buffer* <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;buffer_; &#125;</span><br><span class="line">    <span class="function">mutable_buffer* <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;buffer_ + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutable_buffer buffer_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构与 <code>const_buffers_1</code> 类似，但包装的是 <code>mutable_buffer</code>。</li>
</ul>
<hr>
<h3 id="六、自动类型转换"><a href="#六、自动类型转换" class="headerlink" title="六、自动类型转换"></a>六、自动类型转换</h3><p>当直接传递 <code>mutable_buffer</code> 或 <code>const_buffer</code> 给需要缓冲区序列的函数时，Boost.Asio 会自动将它们包装成 <code>mutable_buffers_1</code> 或 <code>const_buffers_1</code>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std:: string data = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">boost::asio:: <span class="built_in">async_write</span>(socket, boost::asio:: <span class="built_in">buffer</span>(data), handler);</span><br><span class="line"><span class="comment">// 等效于：</span></span><br><span class="line">boost::asio:: <span class="built_in">async_write</span>(socket, <span class="built_in">const_buffers_1</span>(boost::asio:: <span class="built_in">buffer</span>(data)), handler);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>使用的类型</strong></th>
<th><strong>目的</strong></th>
</tr>
</thead>
<tbody><tr>
<td>发送数据（<code>async_write</code>）</td>
<td><code>const_buffers_1</code> 或 <code>const_buffer</code></td>
<td>保证数据只读，符合 <code>ConstBufferSequence</code></td>
</tr>
<tr>
<td>接收数据（<code>async_read</code>）</td>
<td><code>mutable_buffers_1</code> 或 <code>mutable_buffer</code></td>
<td>允许修改数据，符合 <code>MutableBufferSequence</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>核心区别</strong>：数据可修改性和对应的序列概念。</li>
<li><strong>实际开发中</strong>：通常直接使用 <code>boost::asio:: buffer()</code> 自动生成适配器，无需手动构造 <code>const_buffers_1</code> 或 <code> mutable_buffers_1</code>。</li>
</ul>
<p>通过理解这些适配器的作用，可以更安全、高效地使用 Boost.Asio 进行网络编程。</p>
<h2 id="socket-write-some-详解"><a href="#socket-write-some-详解" class="headerlink" title="socket.write_some 详解"></a>socket.write_some 详解</h2><hr>
<h3 id="socket-write-some-详解-1"><a href="#socket-write-some-详解-1" class="headerlink" title="socket.write_some 详解"></a><strong><code>socket.write_some</code> 详解</strong></h3><p><code>boost::asio::ip::tcp::socket:: write_some</code> 是 Boost.Asio 中用于 <strong>同步发送数据</strong> 的成员函数。它的核心特点是 <strong>尝试发送数据，但可能只发送部分内容</strong>，具体取决于底层操作系统的网络缓冲区状态。以下是其详细解析：</p>
<hr>
<h3 id="一、函数定义"><a href="#一、函数定义" class="headerlink" title="一、函数定义"></a><strong>一、函数定义</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">write_some</span><span class="params">(<span class="type">const</span> ConstBufferSequence&amp; buffers)</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">write_some</span><span class="params">(<span class="type">const</span> ConstBufferSequence&amp; buffers, boost::system:: error_code&amp; ec)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数</strong>：<ul>
<li><code>buffers</code>：符合 <code>ConstBufferSequence</code> 概念的数据缓冲区（如 <code>boost::asio:: buffer(&quot;Hello&quot;)</code>）。</li>
<li><code>ec</code>（可选）：用于接收错误码，避免抛出异常。</li>
</ul>
</li>
<li><strong>返回值</strong>：实际发送的字节数（可能小于缓冲区大小）。</li>
<li><strong>异常</strong>：如果未使用 <code>error_code</code> 参数，出错时抛出 <code>boost::system:: system_error</code>。</li>
</ul>
<hr>
<h3 id="二、核心特性"><a href="#二、核心特性" class="headerlink" title="二、核心特性"></a><strong>二、核心特性</strong></h3><ol>
<li><strong>同步操作</strong>：阻塞当前线程直到数据开始发送（不保证全部发送）。</li>
<li><strong>部分发送</strong>：可能只发送部分数据，需手动处理剩余部分。</li>
<li><strong>底层直接调用</strong>：对应操作系统的 <code>send()</code> 函数（Windows）或 <code>write()</code> 函数（Linux）。</li>
</ol>
<hr>
<h3 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a><strong>三、使用场景</strong></h3><ul>
<li><strong>精细控制</strong>：需要手动管理每次发送的数据量。</li>
<li><strong>非阻塞模式</strong>：结合 <code>non_blocking()</code> 设置，实现非阻塞发送。</li>
<li><strong>低延迟场景</strong>：避免等待全部数据发送完成，优先启动传输。</li>
</ul>
<hr>
<h3 id="四、与-boost-asio-write-的区别"><a href="#四、与-boost-asio-write-的区别" class="headerlink" title="四、与 boost::asio:: write 的区别"></a><strong>四、与 <code>boost::asio:: write</code> 的区别</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>socket.write_some</code></th>
<th><code>boost::asio:: write</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据完整性</strong></td>
<td>可能只发送部分数据，需循环调用</td>
<td>内部自动循环，直到所有数据发送完毕</td>
</tr>
<tr>
<td><strong>易用性</strong></td>
<td>需要手动处理部分发送</td>
<td>直接保证全部发送</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>需要精细控制发送过程</td>
<td>常规数据发送（推荐默认使用）</td>
</tr>
</tbody></table>
<hr>
<h3 id="五、代码示例"><a href="#五、代码示例" class="headerlink" title="五、代码示例"></a><strong>五、代码示例</strong></h3><h4 id="示例-1：基本用法（需处理部分发送）"><a href="#示例-1：基本用法（需处理部分发送）" class="headerlink" title="示例 1：基本用法（需处理部分发送）"></a>示例 1：基本用法（需处理部分发送）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">using</span> ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context io;</span><br><span class="line">    <span class="function">tcp::socket <span class="title">socket</span><span class="params">(io)</span></span>;</span><br><span class="line">    socket.<span class="built_in">connect</span>(tcp::<span class="built_in">endpoint</span>(ip::address:: <span class="built_in">from_string</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">    std:: string data = <span class="string">&quot;Hello, Server!&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* buffer = data.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">size_t</span> total_size = data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> bytes_sent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环发送，直到所有数据发送完毕</span></span><br><span class="line">    <span class="keyword">while</span> (bytes_sent &lt; total_size) &#123;</span><br><span class="line">        <span class="type">size_t</span> len = socket.<span class="built_in">write_some</span>(</span><br><span class="line">            boost::asio:: <span class="built_in">buffer</span>(buffer + bytes_sent, total_size - bytes_sent)</span><br><span class="line">        );</span><br><span class="line">        bytes_sent += len;</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;Sent &quot;</span> &lt;&lt; len &lt;&lt; <span class="string">&quot; bytes. Total sent: &quot;</span> &lt;&lt; bytes_sent &lt;&lt; std:: endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：错误处理"><a href="#示例-2：错误处理" class="headerlink" title="示例 2：错误处理"></a>示例 2：错误处理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boost::system:: error_code ec;</span><br><span class="line"><span class="type">size_t</span> len = socket.<span class="built_in">write_some</span>(boost::asio:: <span class="built_in">buffer</span>(data), ec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    std:: cerr &lt;&lt; <span class="string">&quot;Send failed: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std:: endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std:: cout &lt;&lt; <span class="string">&quot;Sent &quot;</span> &lt;&lt; len &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="六、关键注意事项"><a href="#六、关键注意事项" class="headerlink" title="六、关键注意事项"></a><strong>六、关键注意事项</strong></h3><ol>
<li><p><strong>部分发送处理</strong>：</p>
<ul>
<li><p>必须循环调用 <code>write_some</code> 直到所有数据发送完毕。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (bytes_sent &lt; total_size) &#123;</span><br><span class="line">    <span class="type">size_t</span> len = socket.<span class="built_in">write_some</span>(<span class="comment">/* ... */</span>);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 发送失败或连接关闭</span></span><br><span class="line">    bytes_sent += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>阻塞行为</strong>：</p>
<ul>
<li>在 <strong>阻塞模式</strong>（默认）下，<code>write_some</code> 会等待至少发送一个字节。</li>
<li>在 <strong>非阻塞模式</strong> 下（通过 <code>socket.non_blocking(true)</code> 设置），立即返回 <code>boost::asio::error:: would_block</code> 错误（需配合异步操作或轮询）。</li>
</ul>
</li>
<li><p><strong>缓冲区生命周期</strong>：</p>
<ul>
<li>确保在发送过程中，缓冲区内存始终有效（如避免局部变量被销毁）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="七、底层机制"><a href="#七、底层机制" class="headerlink" title="七、底层机制"></a><strong>七、底层机制</strong></h3><h4 id="1-操作系统对应函数"><a href="#1-操作系统对应函数" class="headerlink" title="1. 操作系统对应函数"></a>1. 操作系统对应函数</h4><ul>
<li><strong>Linux</strong>：调用 <code>write()</code> 或 <code>send()</code>。</li>
<li><strong>Windows</strong>：调用 <code>send()</code>。</li>
</ul>
<h4 id="2-发送流程"><a href="#2-发送流程" class="headerlink" title="2. 发送流程"></a>2. 发送流程</h4><ul>
<li><strong>步骤 1</strong>：数据从用户缓冲区复制到内核发送缓冲区。</li>
<li><strong>步骤 2</strong>：内核通过网络栈发送数据。</li>
<li><strong>限制</strong>：内核缓冲区剩余空间决定本次能发送的最大字节数。</li>
</ul>
<hr>
<h3 id="八、性能与最佳实践"><a href="#八、性能与最佳实践" class="headerlink" title="八、性能与最佳实践"></a><strong>八、性能与最佳实践</strong></h3><ol>
<li><p><strong>避免频繁小数据发送</strong>：</p>
<ul>
<li>合并多次小数据为单次发送，减少系统调用开销。</li>
<li>示例：使用 <code>std::vector</code> 或 <code>boost::asio:: streambuf</code> 缓存数据。</li>
</ul>
</li>
<li><p><strong>错误处理优先级</strong>：</p>
<ul>
<li>检查 <code>boost::asio::error:: connection_reset </code> 或 <code> broken_pipe</code>，及时关闭连接。</li>
</ul>
</li>
<li><p><strong>非阻塞模式配合</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="built_in">non_blocking</span>(<span class="literal">true</span>);</span><br><span class="line">boost::system:: error_code ec;</span><br><span class="line"><span class="type">size_t</span> len = socket.<span class="built_in">write_some</span>(boost::asio:: <span class="built_in">buffer</span>(data), ec);</span><br><span class="line"><span class="keyword">if</span> (ec == boost::asio::error:: would_block) &#123;</span><br><span class="line">    <span class="comment">// 使用异步操作或等待可写事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a><strong>九、总结</strong></h3><ul>
<li><strong>核心用途</strong>：手动控制数据发送过程，适用于需要部分发送或非阻塞场景。</li>
<li><strong>必须处理</strong>：循环发送、错误检查、缓冲区生命周期。</li>
<li><strong>推荐替代</strong>：多数场景优先使用 <code>boost::asio:: write</code> 简化逻辑。</li>
</ul>
<p>通过合理使用 <code>write_some</code>，可以在特定需求下实现高效、可控的网络数据传输。</p>
<p>在 Boost.Asio 中，<code>read</code>&#x2F;<code>write</code> 和 <code>read_some</code>&#x2F;<code>write_some</code> 的行为差异与其设计哲学密切相关。以下是针对 Boost.Asio 的详细解释，包含用法和注意事项：</p>
<hr>
<h2 id="一、read-some-vs-read"><a href="#一、read-some-vs-read" class="headerlink" title="一、read_some vs read"></a><strong>一、<code>read_some</code> vs <code>read</code></strong></h2><h3 id="basic-stream-socket-read-some"><a href="#basic-stream-socket-read-some" class="headerlink" title="basic_stream_socket::read_some"></a><code>basic_stream_socket::read_some</code></h3><ul>
<li><p><strong>用途</strong><br>底层非阻塞&#x2F;部分读取操作，尝试从 socket 读取 <strong>至少 1 字节</strong>，但不会保证填满整个缓冲区。</p>
</li>
<li><p><strong>行为</strong>  </p>
<ul>
<li>在 <strong>阻塞模式</strong> 下，会阻塞直到至少读取 1 字节。  </li>
<li>在 <strong>非阻塞模式</strong> 下，若无可读数据，立即返回 <code>boost::asio::error:: would_block</code> 错误。  </li>
<li>返回实际读取的字节数（可能小于缓冲区大小）。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::ip::tcp:: <span class="function">socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="type">char</span> buffer [<span class="number">1024</span>];</span><br><span class="line">boost::system:: error_code ec;</span><br><span class="line"><span class="type">size_t</span> bytes_read = socket.<span class="built_in">read_some</span>(boost::asio:: <span class="built_in">buffer</span>(buffer), ec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ec == boost::asio::error:: would_block) &#123;</span><br><span class="line">    <span class="comment">// 非阻塞模式下无数据可读</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    <span class="comment">// 处理其他错误</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理读取的 bytes_read 字节数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>  </p>
<ul>
<li>需手动处理部分读取（可能需要循环调用）。  </li>
<li>非阻塞模式下需结合 <code>io_context</code> 和异步操作（如 <code>async_read_some</code>）实现高效事件驱动。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="boost-asio-read-自由函数"><a href="#boost-asio-read-自由函数" class="headerlink" title="boost::asio:: read 自由函数"></a><code>boost::asio:: read</code> 自由函数</h3><ul>
<li><p><strong>用途</strong><br>高级封装操作，确保读取 <strong>完整指定字节数</strong> 或直到发生错误。</p>
</li>
<li><p><strong>行为</strong>  </p>
<ul>
<li>内部循环调用 <code>read_some</code>，直到缓冲区被填满。  </li>
<li>在阻塞模式下会一直等待；非阻塞模式下需确保 socket 设置为阻塞或通过 <code>async_read</code> 使用异步模式。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::ip::tcp:: <span class="function">socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="type">char</span> buffer [<span class="number">1024</span>];</span><br><span class="line">boost::system:: error_code ec;</span><br><span class="line"><span class="type">size_t</span> bytes_read = boost::asio:: <span class="built_in">read</span>(socket, boost::asio:: <span class="built_in">buffer</span>(buffer), ec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    <span class="comment">// 处理错误（如连接关闭）</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 缓冲区已被完整填充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>  </p>
<ul>
<li>若 socket 在非阻塞模式且数据未就绪，可能直接返回错误。  </li>
<li>适合需要简化逻辑的场景（如文件传输）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、write-some-vs-write"><a href="#二、write-some-vs-write" class="headerlink" title="二、write_some vs write"></a><strong>二、<code>write_some</code> vs <code>write</code></strong></h3><h4 id="1-basic-stream-socket-write-some"><a href="#1-basic-stream-socket-write-some" class="headerlink" title="1. basic_stream_socket::write_some"></a><strong>1. <code>basic_stream_socket::write_some</code></strong></h4><ul>
<li><p><strong>用途</strong><br>底层非阻塞&#x2F;部分写入操作，尝试发送 <strong>尽可能多</strong> 的数据，但不保证发送全部字节。</p>
</li>
<li><p><strong>行为</strong>  </p>
<ul>
<li>在阻塞模式下，会阻塞直到至少发送 1 字节。  </li>
<li>在非阻塞模式下，若内核发送缓冲区已满，返回 <code>boost::asio::error:: would_block</code>。  </li>
<li>返回实际发送的字节数（可能小于请求的大小）。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* data = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> total_bytes = <span class="built_in">strlen</span>(data);</span><br><span class="line">boost::system:: error_code ec;</span><br><span class="line"><span class="type">size_t</span> bytes_sent = socket.<span class="built_in">write_some</span>(boost::asio:: <span class="built_in">buffer</span>(data, total_bytes), ec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ec == boost::asio::error:: would_block) &#123;</span><br><span class="line">    <span class="comment">// 非阻塞模式下发送缓冲区已满</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    <span class="comment">// 处理其他错误</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 继续发送剩余数据（total_bytes - bytes_sent）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>  </p>
<ul>
<li>需手动处理部分写入（可能需要循环或异步续传）。  </li>
<li>结合非阻塞模式时，通常使用 <code>async_write_some</code> 实现高效发送。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-boost-asio-write-自由函数"><a href="#2-boost-asio-write-自由函数" class="headerlink" title="2. boost::asio:: write 自由函数"></a><strong>2. <code>boost::asio:: write</code> 自由函数</strong></h4><ul>
<li><p><strong>用途</strong><br>高级封装操作，确保 <strong>所有数据发送完毕</strong> 或发生错误。</p>
</li>
<li><p><strong>行为</strong>  </p>
<ul>
<li>内部循环调用 <code>write_some</code>，直到所有数据发送完成。  </li>
<li>在阻塞模式下会一直等待；非阻塞模式下需确保 socket 设置为阻塞或使用异步操作。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* data = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> total_bytes = <span class="built_in">strlen</span>(data);</span><br><span class="line">boost::system:: error_code ec;</span><br><span class="line"><span class="type">size_t</span> bytes_sent = boost::asio:: <span class="built_in">write</span>(socket, boost::asio:: <span class="built_in">buffer</span>(data, total_bytes), ec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    <span class="comment">// 处理错误（如连接中断）</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 所有数据已发送</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>  </p>
<ul>
<li>非阻塞模式下可能无法直接使用（需通过异步接口）。  </li>
<li>适合需要原子性写入的场景（如协议头+体的完整发送）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三、关键区别总结"><a href="#三、关键区别总结" class="headerlink" title="三、关键区别总结"></a><strong>三、关键区别总结</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><code>read_some</code>&#x2F;<code>write_some</code> (成员函数)</th>
<th><code>read</code>&#x2F;<code>write</code> (自由函数)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据完整性</strong></td>
<td>可能部分传输</td>
<td>确保完整传输</td>
</tr>
<tr>
<td><strong>底层控制</strong></td>
<td>需手动循环处理剩余数据</td>
<td>自动处理循环</td>
</tr>
<tr>
<td><strong>适用模式</strong></td>
<td>非阻塞 I&#x2F;O、自定义事件循环</td>
<td>阻塞模式、简化逻辑</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>可能返回 <code>would_block</code></td>
<td>直接返回最终错误或成功</td>
</tr>
<tr>
<td><strong>性能优化</strong></td>
<td>适合精细控制（如结合 <code>io_context</code> 轮询）</td>
<td>适合简单场景</td>
</tr>
</tbody></table>
<hr>
<h3 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a><strong>四、注意事项</strong></h3><h4 id="1-阻塞-vs-非阻塞模式"><a href="#1-阻塞-vs-非阻塞模式" class="headerlink" title="1. 阻塞 vs 非阻塞模式"></a><strong>1. 阻塞 vs 非阻塞模式</strong></h4><ul>
<li><p><strong>阻塞模式</strong>：  </p>
<ul>
<li><code>read_some</code>&#x2F;<code>write_some</code> 会阻塞直到至少操作 1 字节。  </li>
<li><code>read</code>&#x2F;<code>write</code> 会阻塞直到完成所有操作。</li>
</ul>
</li>
<li><p><strong>非阻塞模式</strong>：  </p>
<ul>
<li><code>read_some</code>&#x2F;<code>write_some</code> 可能立即返回 <code>would_block</code>，需结合异步操作。  </li>
<li><code>read</code>&#x2F;<code>write</code> 在非阻塞模式下可能直接失败，除非数据已就绪。</li>
</ul>
</li>
</ul>
<h4 id="2-异步操作"><a href="#2-异步操作" class="headerlink" title="2. 异步操作"></a><strong>2. 异步操作</strong></h4><ul>
<li>使用 <code>async_read_some</code> 和 <code>async_write_some</code> 时，需通过回调处理部分数据。  </li>
<li><code>async_read</code> 和 <code>async_write</code> 会自动处理循环，直到完成完整传输。</li>
</ul>
<h4 id="3-缓冲区管理"><a href="#3-缓冲区管理" class="headerlink" title="3. 缓冲区管理"></a><strong>3. 缓冲区管理</strong></h4><ul>
<li>确保缓冲区生命周期在异步操作中有效（如使用 <code>std::shared_ptr</code> 或 <code>boost::asio:: buffer</code> 的拷贝）。</li>
</ul>
<hr>
<h3 id="五、代码实践示例"><a href="#五、代码实践示例" class="headerlink" title="五、代码实践示例"></a><strong>五、代码实践示例</strong></h3><h4 id="使用-read-some-手动循环读取"><a href="#使用-read-some-手动循环读取" class="headerlink" title="使用 read_some 手动循环读取"></a><strong>使用 <code>read_some</code> 手动循环读取</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">size_t</span> total_needed = <span class="number">1024</span>;</span><br><span class="line"><span class="type">size_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (bytes_read &lt; total_needed) &#123;</span><br><span class="line">    boost::system:: error_code ec;</span><br><span class="line">    <span class="type">size_t</span> n = socket.<span class="built_in">read_some</span>(</span><br><span class="line">        boost::asio:: <span class="built_in">buffer</span>(buffer + bytes_read, total_needed - bytes_read), ec);</span><br><span class="line">    <span class="keyword">if</span> (ec == boost::asio::error:: would_block) &#123;</span><br><span class="line">        <span class="comment">// 等待数据就绪（如通过 select 或 io_context.poll()）</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">        <span class="keyword">throw</span> boost::system:: <span class="built_in">system_error</span>(ec);</span><br><span class="line">    &#125;</span><br><span class="line">    bytes_read += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-async-read-简化异步读取"><a href="#使用-async-read-简化异步读取" class="headerlink" title="使用 async_read 简化异步读取"></a><strong>使用 <code>async_read</code> 简化异步读取</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer [<span class="number">1024</span>];</span><br><span class="line">boost::asio:: <span class="built_in">async_read</span>(socket, boost::asio:: <span class="built_in">buffer</span>(buffer),</span><br><span class="line">    [](<span class="type">const</span> boost::system:: error_code&amp; ec, <span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">            <span class="comment">// 所有 1024 字节已读取</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="六、总结-1"><a href="#六、总结-1" class="headerlink" title="六、总结"></a><strong>六、总结</strong></h3><ul>
<li><p><strong>选择 <code>read_some</code>&#x2F;<code>write_some</code></strong>：<br>需要精细控制非阻塞 I&#x2F;O 或实现自定义协议（如分片处理）。  </p>
</li>
<li><p><strong>选择 <code>read</code>&#x2F;<code>write</code></strong>：<br>需要简化代码逻辑或确保数据完整性（如文件传输、固定头协议）。</p>
</li>
</ul>
<p>通过理解 Boost.Asio 的设计哲学，可以更高效地利用其同步&#x2F;异步接口实现高性能网络应用。</p>
<h2 id="async-write-some"><a href="#async-write-some" class="headerlink" title="async_write_some"></a>async_write_some</h2><p>在 Boost.Asio 中，<code>async_write_some</code> 是一个用于异步发送数据的底层成员函数，它允许非阻塞地发送尽可能多的数据，但<strong>不保证一次性发送全部内容</strong>。以下是对 <code>async_write_some</code> 的详细解释，包括其用法、行为、注意事项及与 <code>async_write</code> 的对比。</p>
<hr>
<h3 id="一、async-write-some-基本用法"><a href="#一、async-write-some-基本用法" class="headerlink" title="一、async_write_some 基本用法"></a><strong>一、<code>async_write_some</code> 基本用法</strong></h3><h4 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a><strong>函数签名</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConstBufferSequence, <span class="keyword">typename</span> WriteHandler&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_write_some</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ConstBufferSequence&amp; buffers,</span></span></span><br><span class="line"><span class="params"><span class="function">    WriteHandler&amp;&amp; handler</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h4><ul>
<li><p><strong><code>buffers</code></strong><br>要发送的数据缓冲区，通常通过 <code>boost::asio:: buffer </code> 包装（如 <code> boost::asio:: buffer(data, size)</code>）。</p>
</li>
<li><p><strong><code>handler</code></strong><br>异步操作完成后的回调函数，其签名为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> boost::system:: error_code&amp; ec,  <span class="comment">// 错误码</span></span></span></span><br><span class="line"><span class="params"><span class="function">    std:: <span class="type">size_t</span> bytes_transferred         <span class="comment">// 实际发送的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost:: asio;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_data</span><span class="params">(ip::tcp:: socket&amp; socket, <span class="type">const</span> std:: string&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数据包装为缓冲区</span></span><br><span class="line">    <span class="keyword">auto</span> buffer = boost::asio:: <span class="built_in">buffer</span>(data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动异步发送</span></span><br><span class="line">    socket.<span class="built_in">async_write_some</span>(buffer,</span><br><span class="line">        [&amp;socket, data](<span class="type">const</span> boost::system:: error_code&amp; ec, std:: <span class="type">size_t</span> bytes_sent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">                <span class="comment">// 处理部分发送的情况</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_sent &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 继续发送剩余数据</span></span><br><span class="line">                    std:: string remaining_data = data.<span class="built_in">substr</span>(bytes_sent);</span><br><span class="line">                    <span class="built_in">send_data</span>(socket, remaining_data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    std:: cout &lt;&lt; <span class="string">&quot;All data sent successfully.&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std:: cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std:: endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、async-write-some-的行为"><a href="#二、async-write-some-的行为" class="headerlink" title="二、async_write_some 的行为"></a><strong>二、<code>async_write_some</code> 的行为</strong></h3><h4 id="1-非阻塞操作"><a href="#1-非阻塞操作" class="headerlink" title="1. 非阻塞操作"></a><strong>1. 非阻塞操作</strong></h4><ul>
<li><code>async_write_some</code> 是异步的，调用后立即返回，不会阻塞当前线程。</li>
<li>实际的数据发送由操作系统在后台完成。</li>
</ul>
<h4 id="2-部分发送"><a href="#2-部分发送" class="headerlink" title="2. 部分发送"></a><strong>2. 部分发送</strong></h4><ul>
<li>可能只发送部分数据（例如，发送缓冲区满时）。</li>
<li>回调函数的 <code>bytes_transferred</code> 表示实际发送的字节数，需手动处理剩余数据。</li>
</ul>
<h4 id="3-错误处理"><a href="#3-错误处理" class="headerlink" title="3. 错误处理"></a><strong>3. 错误处理</strong></h4><ul>
<li>如果发送过程中出现错误（如连接断开），<code>ec</code> 参数会指示具体错误类型。</li>
<li>常见错误：<code>boost::asio::error:: operation_aborted </code>（操作被取消）、<code> boost::asio::error:: connection_reset</code>（连接重置）。</li>
</ul>
<hr>
<h3 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a><strong>三、注意事项</strong></h3><h4 id="1-数据缓冲区的生命周期"><a href="#1-数据缓冲区的生命周期" class="headerlink" title="1. 数据缓冲区的生命周期"></a><strong>1. 数据缓冲区的生命周期</strong></h4><ul>
<li>异步操作未完成时，必须确保缓冲区内存有效。</li>
<li>如果数据是临时变量，需将其拷贝到长期存储（如 <code>std::shared_ptr</code>）或在回调中管理生命周期。</li>
</ul>
<h4 id="2-处理部分发送"><a href="#2-处理部分发送" class="headerlink" title="2. 处理部分发送"></a><strong>2. 处理部分发送</strong></h4><ul>
<li>需在回调中检查 <code>bytes_transferred</code>，并继续发送剩余数据（递归或循环调用 <code>async_write_some</code>）。</li>
</ul>
<h4 id="3-线程安全性"><a href="#3-线程安全性" class="headerlink" title="3. 线程安全性"></a><strong>3. 线程安全性</strong></h4><ul>
<li>回调函数可能在任意线程中执行，需确保线程安全（如使用 <code>strand</code> 或锁）。</li>
</ul>
<h4 id="4-错误传播"><a href="#4-错误传播" class="headerlink" title="4. 错误传播"></a><strong>4. 错误传播</strong></h4><ul>
<li>若发生错误，需终止发送或重试，避免无限循环。</li>
</ul>
<hr>
<h3 id="四、async-write-some-vs-async-write"><a href="#四、async-write-some-vs-async-write" class="headerlink" title="四、async_write_some vs async_write"></a><strong>四、<code>async_write_some</code> vs <code>async_write</code></strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><code>async_write_some</code> (成员函数)</th>
<th><code>async_write</code> (自由函数)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据完整性</strong></td>
<td>可能部分发送，需手动处理剩余数据</td>
<td>确保全部数据发送完毕</td>
</tr>
<tr>
<td><strong>控制粒度</strong></td>
<td>底层操作，适合精细控制</td>
<td>高层封装，简化逻辑</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>自定义协议、分片发送</td>
<td>需要原子性发送完整数据的场景</td>
</tr>
<tr>
<td><strong>缓冲区管理</strong></td>
<td>需手动维护剩余数据</td>
<td>自动处理多次发送</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>需手动处理每次发送的错误</td>
<td>统一处理最终错误</td>
</tr>
</tbody></table>
<hr>
<h3 id="五、完整示例：分片发送数据"><a href="#五、完整示例：分片发送数据" class="headerlink" title="五、完整示例：分片发送数据"></a><strong>五、完整示例：分片发送数据</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 shared_ptr 管理数据生命周期</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_send</span><span class="params">(ip::tcp:: socket&amp; socket, std:: shared_ptr &lt;std::string&gt; data, std:: <span class="type">size_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> buffer = boost::asio:: <span class="built_in">buffer</span>(data-&gt; <span class="built_in">data</span>() + offset, data-&gt; <span class="built_in">size</span>() - offset);</span><br><span class="line">    </span><br><span class="line">    socket.<span class="built_in">async_write_some</span>(buffer,</span><br><span class="line">        [&amp;socket, data, offset](<span class="type">const</span> boost::system:: error_code&amp; ec, std:: <span class="type">size_t</span> bytes_sent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">                std:: <span class="type">size_t</span> new_offset = offset + bytes_sent;</span><br><span class="line">                <span class="keyword">if</span> (new_offset &lt; data-&gt; <span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 继续发送剩余数据</span></span><br><span class="line">                    <span class="built_in">async_send</span>(socket, data, new_offset);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    std:: cout &lt;&lt; <span class="string">&quot;All data sent.&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std:: cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std:: endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context io_ctx;</span><br><span class="line">    ip::tcp:: <span class="function">socket <span class="title">socket</span><span class="params">(io_ctx)</span></span>;</span><br><span class="line">    <span class="comment">// 假设 socket 已连接...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> data = std:: make_shared &lt;std::string&gt;(<span class="string">&quot;Hello, Boost.Asio!&quot;</span>);</span><br><span class="line">    <span class="built_in">async_send</span>(socket, data, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    io_ctx.<span class="built_in">run</span>(); <span class="comment">// 启动事件循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a><strong>六、常见问题</strong></h3><h4 id="1-如何处理非阻塞模式下的-would-block？"><a href="#1-如何处理非阻塞模式下的-would-block？" class="headerlink" title="1. 如何处理非阻塞模式下的 would_block？"></a><strong>1. 如何处理非阻塞模式下的 <code>would_block</code>？</strong></h4><ul>
<li><code>async_write_some</code> 不会直接返回 <code>would_block</code>，因为它是异步的。</li>
<li>如果底层发送缓冲区已满，操作系统会排队数据，回调函数会在可写时触发。</li>
</ul>
<h4 id="2-如何取消异步操作？"><a href="#2-如何取消异步操作？" class="headerlink" title="2. 如何取消异步操作？"></a><strong>2. 如何取消异步操作？</strong></h4><ul>
<li>调用 <code>socket.cancel()</code> 取消所有未完成的异步操作，回调函数会收到 <code>operation_aborted</code> 错误。</li>
</ul>
<h4 id="3-如何优化性能？"><a href="#3-如何优化性能？" class="headerlink" title="3. 如何优化性能？"></a><strong>3. 如何优化性能？</strong></h4><ul>
<li>合并小数据包，减少系统调用次数。</li>
<li>使用 <code>boost::asio:: buffer</code> 的聚集写（scatter-gather）功能发送多个缓冲区。</li>
</ul>
<hr>
<h3 id="七、总结-1"><a href="#七、总结-1" class="headerlink" title="七、总结"></a><strong>七、总结</strong></h3><ul>
<li><p><strong>使用 <code>async_write_some</code></strong>：<br>需要手动控制异步发送过程，适合实现自定义协议或分片逻辑（如大文件分块传输）。<br>需注意缓冲区生命周期、部分发送处理和错误传播。</p>
</li>
<li><p><strong>使用 <code>async_write</code></strong>：<br>更简单安全，适合需要原子性发送完整数据的场景（如发送固定长度的协议头）。</p>
</li>
</ul>
<p>通过合理选择二者，可以在灵活性和开发效率之间取得平衡。</p>
<h2 id="async-read-some-是如何工作的"><a href="#async-read-some-是如何工作的" class="headerlink" title="async_read_some 是如何工作的"></a><code>async_read_some</code> 是如何工作的</h2><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_read_some</span>(</span><br><span class="line">    boost::asio:: <span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_current_length, </span><br><span class="line">                        send_data-&gt;_total_length - send_data-&gt;_current_length), </span><br><span class="line">    std:: <span class="built_in">bind</span>(&amp;Session:: WriteCallback, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong><code>async_read_some</code> 函数的作用</strong></p>
<ul>
<li><p><code>async_read_some</code> 是 Asio 库中用于异步读取数据的函数。它尝试从套接字中读取数据，并将读取的数据存储到指定的缓冲区中。</p>
</li>
<li><p>它的原型大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MutableBufferSequence, <span class="keyword">typename</span> ReadHandler&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_read_some</span><span class="params">(<span class="type">const</span> MutableBufferSequence&amp; buffers, ReadHandler handler)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>buffers</code>：表示要存储读取数据的缓冲区。</li>
<li><code>handler</code>：是一个回调函数，当读取操作完成时会被调用。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>缓冲区参数</strong></p>
<ul>
<li><code>boost::asio:: buffer(send_data-&gt;_msg + send_data-&gt;_current_length, send_data-&gt;_total_length - send_data-&gt;_current_length)</code><ul>
<li>这里使用 <code>boost::asio:: buffer </code> 创建了一个缓冲区，指定了从 <code>send_data-&gt;_msg</code> 的 <code>_current_length </code> 位置开始，长度为 <code>_total_length - _current_length</code> 的内存区域。</li>
<li>这意味着从 <code>send_data-&gt;_msg</code> 的当前未读取部分开始，尝试读取剩余的数据。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>回调函数</strong></p>
<ul>
<li><code>std:: bind(&amp;Session:: WriteCallback, this, std::placeholders::_1, std::placeholders::_2)</code><ul>
<li>这里使用 <code>std::bind</code> 创建了一个可调用对象，用于作为 <code>async_read_some</code> 的回调函数。</li>
<li><code>&amp;Session::WriteCallback</code> 是 <code>Session</code> 类中的一个成员函数，表示当异步读取操作完成时要调用的回调函数。</li>
<li><code>this</code> 是当前对象的指针，表示 <code>WriteCallback</code> 函数将作为当前对象的成员函数被调用。</li>
<li><code>std::placeholders::_1 </code> 和 <code>std::placeholders::_2</code> 是占位符，分别表示 <code> async_read_some</code> 完成时传递给回调函数的两个参数：<ul>
<li><code>_1</code>：通常是表示操作是否成功的 <code>boost::system:: error_code</code>。</li>
<li><code>_2</code>：通常是表示实际读取的字节数。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="std-bind-的返回值作为回调函数"><a href="#std-bind-的返回值作为回调函数" class="headerlink" title="std::bind 的返回值作为回调函数"></a><code>std::bind</code> 的返回值作为回调函数</h3><p><code>std::bind</code> 返回的是一个可调用对象，这个对象可以像普通函数一样被调用。在 Asio 的异步操作中，回调函数可以是一个普通函数、一个绑定的成员函数，或者是一个可调用对象（如 <code>std::bind</code> 的返回值）。</p>
<p>当 <code>async_read_some</code> 完成时，Asio 会调用回调函数，并将操作结果作为参数传递给回调函数。在这个例子中，<code>std::bind</code> 返回的可调用对象会被调用，它会将 <code>WriteCallback</code> 成员函数绑定到当前对象，并将 Asio 传递的参数（<code>error_code</code> 和实际读取的字节数）传递给 <code>WriteCallback</code>。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设 <code>Session</code> 类的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteCallback</span><span class="params">(<span class="type">const</span> boost::system:: error_code&amp; ec, std:: <span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">            std:: cout &lt;&lt; <span class="string">&quot;Read &quot;</span> &lt;&lt; bytes_transferred &lt;&lt; <span class="string">&quot; bytes successfully.&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std:: cerr &lt;&lt; <span class="string">&quot;Read error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std:: endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当 <code>async_read_some</code> 完成时，Asio 会调用 <code>std::bind</code> 返回的可调用对象，它会调用 <code>Session::WriteCallback</code>，并将 <code>error_code</code> 和 <code>bytes_transferred</code> 作为参数传递给它。</p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>std::bind</code> 返回的可调用对象可以直接作为回调函数传递给 <code>async_read_some</code>。</li>
<li>这种方式允许你将成员函数作为回调函数使用，同时将当前对象的上下文（<code>this</code>）绑定到回调函数中。</li>
<li>Asio 会调用这个可调用对象，并将操作结果传递给它，最终调用 <code>WriteCallback</code> 成员函数。</li>
</ul>
<h2 id="async-send-的详细解析"><a href="#async-send-的详细解析" class="headerlink" title="async_send 的详细解析"></a><code>async_send</code> 的详细解析</h2><p><code>async_send</code> 是 Boost.Asio 库中用于异步发送数据的函数。它通常用于 TCP 套接字，用于将数据发送到连接的对端。以下是 <code>async_send</code> 的详细解析和使用方法：</p>
<h3 id="async-send-函数原型"><a href="#async-send-函数原型" class="headerlink" title="async_send 函数原型"></a><code>async_send</code> 函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConstBufferSequence, <span class="keyword">typename</span> WriteHandler&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_send</span><span class="params">(<span class="type">const</span> ConstBufferSequence&amp; buffers, WriteHandler handler)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>buffers</code></strong>：表示要发送的数据缓冲区。可以是一个或多个缓冲区，通常使用 <code>boost::asio:: buffer</code> 来创建。</p>
</li>
<li><p><strong><code>handler</code></strong>：当发送操作完成时被调用的回调函数。回调函数的签名必须为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">const</span> boost::system:: error_code&amp; error, std:: <span class="type">size_t</span> bytes_transferred)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>error</code>：表示操作是否成功。如果为 <code>boost::system:: error_code()</code>，则表示操作成功。</li>
<li><code>bytes_transferred</code>：表示实际发送的字节数。</li>
</ul>
</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><code>async_send</code> 内部会循环调用 <code>async_write_some</code>，直到所有数据都被发送完毕。</li>
<li>回调函数只在发送完成或发生错误时触发。</li>
<li>该函数是非阻塞的，调用后会立即返回。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>当需要简化发送逻辑时，<code>async_send</code> 是一个很好的选择。</li>
<li>适用于需要确保所有数据都发送完毕的场景。</li>
</ul>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>async_send</code> 的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Session</span>(boost::asio::ip::tcp:: socket socket) : _socket(std:: <span class="built_in">move</span>(socket)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteAllToSocket</span><span class="params">(<span class="type">const</span> std:: string&amp; buf)</span> </span>&#123;</span><br><span class="line">        _send_queue.<span class="built_in">emplace</span>(std:: make_shared &lt;MsgNode&gt;(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line">        <span class="keyword">if</span> (_send_pending) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        _send_pending = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> front = _send_queue.<span class="built_in">front</span>();</span><br><span class="line">        _socket-&gt; <span class="built_in">async_send</span>(</span><br><span class="line">            boost::asio:: <span class="built_in">buffer</span>(front-&gt;_msg, front-&gt;_total_len),</span><br><span class="line">            [<span class="keyword">this</span>, front](<span class="type">const</span> boost::system:: error_code&amp; ec, std:: <span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt; <span class="built_in">WriteAllCallBack</span>(ec, bytes_transferred);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteAllCallBack</span><span class="params">(<span class="type">const</span> boost::system:: error_code&amp; ec, std:: <span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">            std:: cerr &lt;&lt; <span class="string">&quot;Error during async send: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std:: endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _send_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _send_pending = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">WriteAllToSocket</span>(<span class="string">&quot;&quot;</span>);  <span class="comment">// 继续发送队列中的下一个消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    boost::asio::ip::tcp:: socket _socket;</span><br><span class="line">    std:: queue &lt;std::shared_ptr&lt;MsgNode&gt; &gt; _send_queue;</span><br><span class="line">    <span class="type">bool</span> _send_pending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MsgNode</span> &#123;</span><br><span class="line">        <span class="type">char</span>* _msg;</span><br><span class="line">        <span class="type">size_t</span> _total_len;</span><br><span class="line">        <span class="built_in">MsgNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">size_t</span> len) : _msg(<span class="keyword">new</span> <span class="type">char</span> [len]), _total_len(len) &#123;</span><br><span class="line">            std:: <span class="built_in">copy</span>(msg, msg + len, _msg);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] _msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><code>WriteAllToSocket</code> 方法将数据添加到发送队列中，并启动异步发送操作。</li>
<li><code>WriteAllCallBack</code> 是回调函数，用于处理发送完成后的逻辑。</li>
<li>使用 <code>async_send</code> 确保所有数据都被发送完毕。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>确保在回调函数中正确处理错误情况。</li>
<li>如果需要发送多个数据块，可以使用队列管理待发送数据。</li>
<li>在发送操作完成之前，不要释放或修改缓冲区。</li>
</ul>
<p>希望这些信息对你理解 <code>async_send</code> 有所帮助！</p>
<h2 id="处理粘包"><a href="#处理粘包" class="headerlink" title="处理粘包"></a>处理粘包</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CSession:: <span class="built_in">HandleRead</span>(<span class="type">const</span> boost::system:: error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std:: shared_ptr &lt;CSession&gt; shared_self)&#123;</span><br><span class="line">    <span class="keyword">if</span> (! error) &#123;</span><br><span class="line">        <span class="comment">//已经移动的字符数</span></span><br><span class="line">        <span class="type">int</span> copy_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (bytes_transferred &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_b_head_parse) &#123;</span><br><span class="line">                <span class="comment">//收到的数据不足头部大小</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data+ copy_len, bytes_transferred);</span><br><span class="line">                    _recv_head_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    :: <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio:: <span class="built_in">buffer</span>(_data, MAX_LENGTH), </span><br><span class="line">                        std:: <span class="built_in">bind</span>(&amp;CSession:: HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收到的数据比头部多</span></span><br><span class="line">                <span class="comment">//头部剩余未复制的长度</span></span><br><span class="line">                <span class="type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;</span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data+copy_len, head_remain);</span><br><span class="line">                <span class="comment">//更新已处理的 data 长度和剩余未处理的长度</span></span><br><span class="line">                copy_len += head_remain;</span><br><span class="line">                bytes_transferred -= head_remain;</span><br><span class="line">                <span class="comment">//获取头部数据</span></span><br><span class="line">                <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">                <span class="comment">//头部长度非法</span></span><br><span class="line">                <span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;</span><br><span class="line">                    std:: cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">                    _server-&gt; <span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                _recv_msg_node = make_shared &lt;MsgNode&gt;(data_len);</span><br><span class="line">                <span class="comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt; data_len) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    :: <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio:: <span class="built_in">buffer</span>(_data, MAX_LENGTH), </span><br><span class="line">                        std:: <span class="built_in">bind</span>(&amp;CSession:: HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="comment">//头部处理完成</span></span><br><span class="line">                    _b_head_parse = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);</span><br><span class="line">                _recv_msg_node-&gt;_cur_len += data_len;</span><br><span class="line">                copy_len += data_len;</span><br><span class="line">                bytes_transferred -= data_len;</span><br><span class="line">                _recv_msg_node-&gt;_data [_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span><br><span class="line">                <span class="comment">//此处可以调用 Send 发送测试</span></span><br><span class="line">                <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line">                <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">                _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">                _recv_head_node-&gt; <span class="built_in">Clear</span>();</span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    :: <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio:: <span class="built_in">buffer</span>(_data, MAX_LENGTH), </span><br><span class="line">                        std:: <span class="built_in">bind</span>(&amp;CSession:: HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已经处理完头部，处理上次未接受完的消息数据</span></span><br><span class="line">            <span class="comment">//接收的数据仍不足剩余未处理的</span></span><br><span class="line">            <span class="type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                :: <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                _socket.<span class="built_in">async_read_some</span>(boost::asio:: <span class="built_in">buffer</span>(_data, MAX_LENGTH), </span><br><span class="line">                    std:: <span class="built_in">bind</span>(&amp;CSession:: HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);</span><br><span class="line">            _recv_msg_node-&gt;_cur_len += remain_msg;</span><br><span class="line">            bytes_transferred -= remain_msg;</span><br><span class="line">            copy_len += remain_msg;</span><br><span class="line">            _recv_msg_node-&gt;_data [_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span><br><span class="line">            <span class="comment">//此处可以调用 Send 发送测试</span></span><br><span class="line">            <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);</span><br><span class="line">            <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">            _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">            _recv_head_node-&gt; <span class="built_in">Clear</span>();</span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                :: <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                _socket.<span class="built_in">async_read_some</span>(boost::asio:: <span class="built_in">buffer</span>(_data, MAX_LENGTH),</span><br><span class="line">                    std:: <span class="built_in">bind</span>(&amp;CSession:: HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        _server-&gt; <span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boost-asio协程实现"><a href="#boost-asio协程实现" class="headerlink" title="boost::asio协程实现"></a>boost::asio协程实现</h2><p>​	协程不是操作系统的底层特性，系统感知不到它的存在。它运行在线程里面，通过分时复用线程的方式运行，不会增加线程的数量。协程也有上下文切换，但是不会切换到内核态去，比线程切换的开销要小很多。每个协程的体积比线程要小得多，一个线程可以容纳数量相当可观的协程。在IO密集型的任务中有着大量的阻塞等待过程，协程采用协作式调度，在IO阻塞的时候让出CPU，当IO就绪后再主动占用CPU，牺牲任务执行的公平性换取吞吐量。事物都有两面性，协程也存在几个弊端：线程可以在多核CPU上并行，无法将一个线程的多个协程分摊到多核上。协程执行中不能有阻塞操作，否则整个线程被阻塞。协程的控制权由用户态决定，可能执行恶意的代码。</p>
<p>无论是线程还是协程，都只是操作系统层面的抽象概念，本质是函数执行的载体。可以简单的认为协程是一个能够被暂停以及被恢复运行的函数，在协作调度器的控制下执行，同一个时刻只能运行一个函数。</p>
<p><strong>函数状态的维护完全依赖于线程栈，线程栈中分类连续地址保存函数的运行状态，函数是线程相关的。</strong></p>
<p><strong>如果函数是协程，调用函数的时候，保存函数状态（代码位置，局部变量，函数参数）所需要的内存会提前在堆上分配，独立于线程栈。而调用同时会从堆中读取函数运行状态并复制到线程栈的连续空间中。如果函数需要暂停，当前运行状态会被记录到堆的内存中。当下次协程再次运行时，再次从堆区读取上次所保存的函数运行状态到线程栈。协程与线程无关，因为两次调用协程可能是不同的线程，但是同一个协程。所以协程可以暂停和继续执行。</strong></p>
<p>协程会主动让出控制权，而线程是争抢控制权。</p>
<h3 id="协程定义"><a href="#协程定义" class="headerlink" title="协程定义"></a>协程定义</h3><p>​	定义一个函数，只要出现了co_await,co_yield,co_return中的任意一个，就是定义了一个协程。协程的返回值必须是一个coroutine_interface对象。</p>
<h3 id="协程关键字"><a href="#协程关键字" class="headerlink" title="协程关键字"></a>协程关键字</h3><p>下面把 <strong>C++20 协程</strong>里最常用的 3 个关键字（还有 2 个配套类型）用“<strong>一句话解释 + 最小可编译示例</strong>”的方式梳理出来。看完就能直接写 demo。</p>
<hr>
<ol>
<li>co_await  —— “先挂起，等好了再回来继续”<br>• 让协程<strong>异步等待</strong>某个结果，而不会阻塞线程。<br>• 只要表达式实现了 awaitable 三接口（await_ready &#x2F; await_suspend &#x2F; await_resume）就能放在 co_await 后面。</li>
</ol>
<p>最小示例：自己做一个“睡眠 1 秒后返回 42”的 awaitable。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SleepOneSec</span> &#123;</span><br><span class="line">    std::chrono:: seconds dur&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;          <span class="comment">// 永远没准备好</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std:: coroutine_handle &lt;&gt; h)</span> <span class="type">const</span> </span>&#123;        <span class="comment">// 开线程到时恢复</span></span><br><span class="line">        std:: <span class="built_in">thread</span>([h] &#123;</span><br><span class="line">            std::this_thread:: <span class="built_in">sleep_for</span>(std::chrono:: <span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">            h.<span class="built_in">resume</span>();</span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;             <span class="comment">// 恢复时给结果</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        std:: <span class="function">suspend_never <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        std:: <span class="function">suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; std:: <span class="built_in">terminate</span>(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">example_co_await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v = <span class="keyword">co_await</span> SleepOneSec&#123;&#125;;</span><br><span class="line">    std:: cout &lt;&lt; <span class="string">&quot;co_await 得到: &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">example_co_await</span>();</span><br><span class="line">    std::this_thread:: <span class="built_in">sleep_for</span>(std::chrono:: <span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Start → 1 秒停顿 → <code>co_await 得到: 42</code>。</p>
<hr>
<ol start="2">
<li>co_yield  —— “产生一个值，然后挂起”<br>• 常用于<strong>生成器</strong>（generator），每次 yield 把值送出去，调用者 <code>resume()</code> 后继续循环。</li>
</ol>
<p>最小示例：一个范围生成器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        T current_value;</span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Generator&#123;<span class="keyword">this</span>&#125;; &#125;</span><br><span class="line">        std:: <span class="function">suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        std:: <span class="function">suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; std:: <span class="built_in">terminate</span>(); &#125;</span><br><span class="line">        std:: <span class="function">suspend_always <span class="title">yield_value</span><span class="params">(T value)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            current_value = value;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">using</span> handle = std:: coroutine_handle &lt;promise_type&gt;;</span><br><span class="line">    handle h;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Generator</span><span class="params">(promise_type * p)</span> : h(handle:: from_promise(* p)) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Generator</span>() &#123; <span class="keyword">if</span> (h) h.<span class="built_in">destroy</span>(); &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Iter</span> &#123;</span><br><span class="line">        handle h; <span class="type">bool</span> done;</span><br><span class="line">        Iter&amp; <span class="keyword">operator</span>++() &#123; h.<span class="built_in">resume</span>(); done = h.<span class="built_in">done</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">        T <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> h.<span class="built_in">promise</span>().current_value; &#125;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iter&amp; o) <span class="type">const</span> &#123; <span class="keyword">return</span> done != o.done; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">Iter <span class="title">begin</span><span class="params">()</span> </span>&#123; h.<span class="built_in">resume</span>(); <span class="keyword">return</span> Iter&#123;h, h.<span class="built_in">done</span>()&#125;; &#125;</span><br><span class="line">    <span class="function">Iter <span class="title">end</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> Iter&#123;h, <span class="literal">true</span>&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Generator &lt;<span class="type">int</span>&gt; <span class="built_in">range</span>(<span class="type">int</span> from, <span class="type">int</span> to) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = from; i &lt; to; ++i)</span><br><span class="line">        <span class="keyword">co_yield</span> i;          <span class="comment">// 产生 i 并挂起</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">        std:: cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;   <span class="comment">// 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ol start="3">
<li>co_return  —— “协程的最终返回”<br>• 与 <code>return</code> 类似，但<strong>只能在协程里用</strong>。<br>• 把结果交给 promise_type，然后协程进入 final_suspend。</li>
</ol>
<p>最小示例：返回字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StringTask</span> &#123;</span><br><span class="line">    std:: string value;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">StringTask <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        std:: <span class="function">suspend_never <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        std:: <span class="function">suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(std:: string s)</span> </span>&#123; <span class="comment">/* 存到外部对象 */</span> &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; std:: <span class="built_in">terminate</span>(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">StringTask <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">co_return</span> <span class="string">&quot;Hello from co_return&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="built_in">hello</span>();</span><br><span class="line">    std:: cout &lt;&lt; t.value;   <span class="comment">// 实际工程中通过 promise 把值回传</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ol start="4">
<li>两个极简 awaitable 工具：</li>
</ol>
<ul>
<li><code>std::suspend_always&#123;&#125;</code>  —— 总是挂起（最常用占位符）。  </li>
<li><code>std::suspend_never&#123;&#125;</code>   —— 从不挂起，直接继续执行。</li>
</ul>
<hr>
<p>一句话速记  </p>
<ul>
<li><code>co_await</code> 等异步结果  </li>
<li><code>co_yield</code> 产一个值  </li>
<li><code>co_return</code> 给最终结果</li>
</ul>
<p>把这三板斧 + promise_type 拼起来，就能写出 <strong>异步任务、生成器、Lazy 值</strong> 等各种 C++20 协程应用。</p>
<h3 id="co-spawn和awaitable"><a href="#co-spawn和awaitable" class="headerlink" title="co_spawn和awaitable"></a>co_spawn和awaitable</h3><p>一句话先回答  </p>
<ul>
<li><code>co_spawn</code>：<strong>把协程“扔”到某个执行器（io_context &#x2F; 线程池）里跑</strong>  </li>
<li><code>awaitable&lt;&gt;</code>：<strong>Boost.Asio 协程的“返回类型”，告诉编译器这是一个能 <code>co_await</code> 的异步协程</strong></li>
</ul>
<p>下面分开说，再给最小可编译例子。</p>
<hr>
<ol>
<li>co_spawn —— 启动器 &#x2F; 调度器</li>
</ol>
<p>作用  </p>
<ul>
<li>负责把 <strong>用户写的协程函数</strong> 绑定到 <strong>执行器</strong>（<code>io_context</code>, <code>thread_pool</code>, <code>strand</code>…）  </li>
<li>还能指定启动令牌（<code>detached</code>、<code>use_awaitable</code>、<code>bind_executor</code>…）  </li>
<li>类似线程池的 <code>std::async</code>，但专为协程优化。</li>
</ul>
<p>原型（简化）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Executor, <span class="keyword">typename</span> Coro, <span class="keyword">typename</span> Token&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">co_spawn</span><span class="params">(Executor ex, Coro&amp;&amp; c, Token&amp;&amp; t)</span></span>;</span><br></pre></td></tr></table></figure>

<p>常用 3 种 Token</p>
<ul>
<li><p><code>boost::asio:: detached</code><br>启动后“自生自灭”，不返回句柄，也不抛异常。</p>
</li>
<li><p><code>boost::asio:: use_awaitable</code><br>启动后返回 <code>awaitable&lt;T&gt;</code>，外层协程可以 <code>co_await</code> 它。</p>
</li>
<li><p><code>boost::asio:: bind_executor</code><br>把协程绑定到某个 strand &#x2F; 指定执行器。</p>
</li>
</ul>
<hr>
<ol start="2">
<li>awaitable <T> —— 返回类型</li>
</ol>
<p>作用  </p>
<ul>
<li>Boost.Asio 自带的 <strong>协程返回对象</strong>，内部实现了 C++20 promise_type。  </li>
<li>只能出现在 <strong>协程函数</strong> 的返回类型：<br><code>awaitable&lt;void&gt;</code> &#x2F; <code>awaitable&lt;size_t&gt;</code> &#x2F; <code>awaitable&lt;std::string&gt;</code> …  </li>
<li>任何返回 <code>awaitable&lt;&gt;</code> 的函数都 <strong>必须</strong> 在内部用 <code>co_await</code> &#x2F; <code>co_return</code> &#x2F; <code>co_yield</code>。</li>
</ul>
<hr>
<ol start="3">
<li>最小完整例子（Boost.Asio + C++20）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> asio = boost::asio;</span><br><span class="line"><span class="keyword">using</span> asio::ip:: tcp;</span><br><span class="line"><span class="keyword">using</span> asio:: awaitable;</span><br><span class="line"><span class="keyword">using</span> asio:: co_spawn;</span><br><span class="line"><span class="keyword">using</span> asio:: detached;</span><br><span class="line"></span><br><span class="line">awaitable &lt;<span class="type">void</span>&gt; <span class="built_in">delay_and_print</span>(asio:: io_context&amp; io) &#123;</span><br><span class="line">    asio:: <span class="function">steady_timer <span class="title">timer</span><span class="params">(io, std::chrono:: seconds(<span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">co_await</span> timer.<span class="built_in">async_wait</span>(asio:: use_awaitable);</span><br><span class="line">    std:: cout &lt;&lt; <span class="string">&quot;Hello from coroutine!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    asio:: io_context io;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把协程扔到 io_context 里跑，启动令牌 detached</span></span><br><span class="line">    <span class="built_in">co_spawn</span>(io, <span class="built_in">delay_and_print</span>(io), detached);</span><br><span class="line"></span><br><span class="line">    io.<span class="built_in">run</span>();               <span class="comment">// 事件循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程  </p>
<ol>
<li><code>co_spawn</code> 创建协程帧 → 绑定到 <code>io</code> → 立即调度。  </li>
<li>协程里 <code>co_await timer.async_wait(...)</code> → 挂起 1 秒。  </li>
<li>计时器到时 → 协程恢复 → 打印 → <code>co_return</code> → 协程结束。</li>
</ol>
<hr>
<p>一句话速记  </p>
<ul>
<li><code>co_spawn</code> ＝ “调度器，把协程送进事件循环”。  </li>
<li><code>awaitable&lt;T&gt;</code> ＝ “Boost.Asio 的协程返回类型，声明这个函数是协程”。</li>
</ul>
<h1 id="Boost-Asio-网络编程概念详解"><a href="#Boost-Asio-网络编程概念详解" class="headerlink" title="Boost.Asio 网络编程概念详解"></a>Boost.Asio 网络编程概念详解</h1><p>您提出了几个关于 Boost.Asio 网络编程的核心概念问题，让我逐一详细解释。</p>
<h2 id="1-Endpoint-的角色：服务端-vs-客户端"><a href="#1-Endpoint-的角色：服务端-vs-客户端" class="headerlink" title="1. Endpoint 的角色：服务端 vs 客户端"></a>1. Endpoint 的角色：服务端 vs 客户端</h2><p>您理解得完全正确：</p>
<h3 id="服务端-Endpoint"><a href="#服务端-Endpoint" class="headerlink" title="服务端 Endpoint"></a>服务端 Endpoint</h3><ul>
<li><p><strong>作用</strong>：指定服务器要监听的地址和端口</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听所有 IPv4 地址的 8080 端口</span></span><br><span class="line">tcp:: <span class="function">endpoint <span class="title">endpoint</span><span class="params">(tcp:: v4(), <span class="number">8080</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者监听特定 IP 地址</span></span><br><span class="line">tcp:: <span class="function">endpoint <span class="title">endpoint</span><span class="params">(boost::asio::ip::address:: from_string(<span class="string">&quot;192.168.1.100&quot;</span>), <span class="number">8080</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="客户端-Endpoint"><a href="#客户端-Endpoint" class="headerlink" title="客户端 Endpoint"></a>客户端 Endpoint</h3><ul>
<li><p><strong>作用</strong>：指定要连接的服务器的地址和端口</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接至特定服务器的 8080 端口</span></span><br><span class="line">tcp:: <span class="function">endpoint <span class="title">endpoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    boost::asio::ip::address:: from_string(<span class="string">&quot;192.168.1.100&quot;</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="number">8080</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>总结</strong>：Endpoint 在服务端表示”我要在这里监听”，在客户端表示”我要连接到哪里”。</p>
<h2 id="2-Socket-的使用：独立还是共享"><a href="#2-Socket-的使用：独立还是共享" class="headerlink" title="2. Socket 的使用：独立还是共享"></a>2. Socket 的使用：独立还是共享</h2><p>在 Boost.Asio 中，<strong>每个连接都有自己独立的 socket</strong>：</p>
<h3 id="服务端-Socket-使用模式"><a href="#服务端-Socket-使用模式" class="headerlink" title="服务端 Socket 使用模式"></a>服务端 Socket 使用模式</h3><ol>
<li><strong>监听 Socket (Acceptor)</strong>：只有一个，用于接受新连接</li>
<li><strong>连接 Socket</strong>：每个客户端连接都有一个独立的 socket</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端代码示例</span></span><br><span class="line">tcp:: <span class="function">acceptor <span class="title">acceptor</span><span class="params">(io_context, endpoint)</span></span>; <span class="comment">// 监听 socket</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当接受新连接时</span></span><br><span class="line">tcp:: <span class="function">socket <span class="title">client_socket</span><span class="params">(io_context)</span></span>; <span class="comment">// 为每个连接创建独立的 socket</span></span><br><span class="line">acceptor.<span class="built_in">accept</span>(client_socket); <span class="comment">// 将新连接绑定到这个 socket</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以使用 client_socket 与特定客户端通信</span></span><br></pre></td></tr></table></figure>

<h3 id="客户端-Socket-使用模式"><a href="#客户端-Socket-使用模式" class="headerlink" title="客户端 Socket 使用模式"></a>客户端 Socket 使用模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码示例</span></span><br><span class="line">tcp:: <span class="function">socket <span class="title">socket</span><span class="params">(io_context)</span></span>; <span class="comment">// 客户端只需要一个 socket</span></span><br><span class="line">socket.<span class="built_in">connect</span>(server_endpoint); <span class="comment">// 连接到服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个 socket 与服务器通信</span></span><br></pre></td></tr></table></figure>

<p><strong>重要原则</strong>：</p>
<ul>
<li>不要在不同的连接间共享 socket</li>
<li>每个 TCP 连接对应一个独立的 socket 对象</li>
<li>socket 不是线程安全的，不应在多个线程中同时访问同一个 socket</li>
</ul>
<h2 id="3-IO-Context-的使用模式"><a href="#3-IO-Context-的使用模式" class="headerlink" title="3. IO Context 的使用模式"></a>3. IO Context 的使用模式</h2><p>IO Context 是 Boost.Asio 的核心，有多种使用模式：</p>
<h3 id="模式一：单-IO-Context（最简单）"><a href="#模式一：单-IO-Context（最简单）" class="headerlink" title="模式一：单 IO Context（最简单）"></a>模式一：单 IO Context（最简单）</h3><ul>
<li>整个应用程序使用一个 <code>io_context</code></li>
<li>适合简单应用或低并发场景</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boost::asio:: io_context io_context;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端和客户端都使用同一个 io_context</span></span><br><span class="line"><span class="function">CServer <span class="title">server</span><span class="params">(io_context, endpoint)</span></span>;</span><br><span class="line"><span class="function">CClient <span class="title">client</span><span class="params">(io_context, server_endpoint)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行事件循环</span></span><br><span class="line">io_context.<span class="built_in">run</span>();</span><br></pre></td></tr></table></figure>

<h3 id="模式二：多线程共享一个-IO-Context（常见模式）"><a href="#模式二：多线程共享一个-IO-Context（常见模式）" class="headerlink" title="模式二：多线程共享一个 IO Context（常见模式）"></a>模式二：多线程共享一个 IO Context（常见模式）</h3><ul>
<li>一个 <code>io_context</code> 被多个线程共享</li>
<li>适合中等并发场景</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">boost::asio:: io_context io_context;</span><br><span class="line"><span class="function">CServer <span class="title">server</span><span class="params">(io_context, endpoint)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在工作线程中运行 io_context</span></span><br><span class="line">std:: vector &lt;std::thread&gt; threads;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>([&amp;io_context]() &#123;</span><br><span class="line">        io_context.<span class="built_in">run</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程也可以运行 io_context</span></span><br><span class="line">io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待所有线程结束</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式三：IO-Context-池（高性能模式）"><a href="#模式三：IO-Context-池（高性能模式）" class="headerlink" title="模式三：IO Context 池（高性能模式）"></a>模式三：IO Context 池（高性能模式）</h3><ul>
<li>多个 <code>io_context</code> 实例组成池</li>
<li>每个 <code>io_context</code> 在单独线程中运行</li>
<li>适合高并发场景</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IO Context 池</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IoContextPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">IoContextPool</span><span class="params">(std:: <span class="type">size_t</span> pool_size)</span></span></span><br><span class="line"><span class="function">        : next_io_context_(<span class="number">0</span>) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (std:: <span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pool_size; ++i) &#123;</span><br><span class="line">            io_contexts_.<span class="built_in">push_back</span>(std:: make_shared &lt; boost::asio:: io_context &gt;());</span><br><span class="line">            workers_.<span class="built_in">push_back</span>(std:: make_shared &lt; boost::asio::io_context:: work &gt;(*io_contexts_.<span class="built_in">back</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std:: vector &lt;std::thread&gt; threads;</span><br><span class="line">        <span class="keyword">for</span> (std:: <span class="type">size_t</span> i = <span class="number">0</span>; i &lt; io_contexts_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i]() &#123;</span><br><span class="line">                io_contexts_[i]-&gt; <span class="built_in">run</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    boost::asio:: <span class="function">io_context&amp; <span class="title">get_io_context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; io_context = *io_contexts_[next_io_context_];</span><br><span class="line">        ++next_io_context_;</span><br><span class="line">        <span class="keyword">if</span> (next_io_context_ == io_contexts_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            next_io_context_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> io_context;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std:: vector &lt; std:: shared_ptr &lt; boost::asio:: io_context &gt;&gt; io_contexts_;</span><br><span class="line">    std:: vector &lt; std:: shared_ptr &lt; boost::asio::io_context:: work &gt;&gt; workers_;</span><br><span class="line">    std:: <span class="type">size_t</span> next_io_context_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用池</span></span><br><span class="line"><span class="function">IoContextPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// 4 个 io_context</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个会话分配 io_context</span></span><br><span class="line"><span class="keyword">auto</span>&amp; io_context = pool.<span class="built_in">get_io_context</span>();</span><br><span class="line">std:: make_shared &lt;CSession&gt;(io_context)-&gt; <span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">pool.<span class="built_in">run</span>(); <span class="comment">// 运行所有 io_context</span></span><br></pre></td></tr></table></figure>

<h3 id="模式四：专用-IO-Context（高级模式）"><a href="#模式四：专用-IO-Context（高级模式）" class="headerlink" title="模式四：专用 IO Context（高级模式）"></a>模式四：专用 IO Context（高级模式）</h3><ul>
<li>为特定类型的操作分配专用的 <code>io_context</code></li>
<li>例如：一个用于接受连接，一个用于数据处理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专用 io_context 用于接受连接</span></span><br><span class="line">boost::asio:: io_context accept_io_context;</span><br><span class="line">tcp:: <span class="function">acceptor <span class="title">acceptor</span><span class="params">(accept_io_context, endpoint)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 专用 io_context 池用于处理连接</span></span><br><span class="line"><span class="function">IoContextPool <span class="title">session_pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在接受连接时，为会话分配 io_context</span></span><br><span class="line">acceptor.<span class="built_in">async_accept</span>([&amp;](boost::system:: error_code ec, tcp:: socket socket) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; session_io_context = session_pool.<span class="built_in">get_io_context</span>();</span><br><span class="line">        std:: make_shared &lt;CSession&gt;(session_io_context, std:: <span class="built_in">move</span>(socket))-&gt; <span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在不同线程中运行不同的 io_context</span></span><br><span class="line">std:: <span class="function">thread <span class="title">accept_thread</span><span class="params">([&amp;]() &#123; accept_io_context.run(); &#125;)</span></span>;</span><br><span class="line">session_pool.<span class="built_in">run</span>();</span><br><span class="line">accept_thread.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><strong>Endpoint</strong>：</p>
<ul>
<li>服务端：设置自己的监听地址</li>
<li>客户端：设置要连接的服务端地址</li>
</ul>
</li>
<li><p><strong>Socket</strong>：</p>
<ul>
<li>每个 TCP 连接有自己独立的 socket</li>
<li>不要在不同连接间共享 socket</li>
</ul>
</li>
<li><p><strong>IO Context</strong>：</p>
<ul>
<li><strong>单 IO Context</strong>：简单应用</li>
<li><strong>多线程共享一个 IO Context</strong>：常见模式，中等并发</li>
<li><strong>IO Context 池</strong>：高性能，高并发场景</li>
<li><strong>专用 IO Context</strong>：高级用法，为不同操作类型优化</li>
</ul>
</li>
</ol>
<p>选择哪种模式取决于您的应用需求：</p>
<ul>
<li>低并发、简单应用：单 IO Context</li>
<li>中等并发：多线程共享一个 IO Context</li>
<li>高并发、高性能：IO Context 池</li>
<li>特殊需求：专用 IO Context</li>
</ul>
<p>理解这些概念对于构建高效、可扩展的网络应用程序至关重要。</p>
<h1 id="Boost-Asio-异步操作深度解析"><a href="#Boost-Asio-异步操作深度解析" class="headerlink" title="Boost.Asio 异步操作深度解析"></a>Boost.Asio 异步操作深度解析</h1><p>您提出了一个非常核心的问题，这涉及到 Boost.Asio 库的工作原理和操作系统底层机制。让我详细解释异步操作的整个执行过程。</p>
<h2 id="异步操作的整体流程"><a href="#异步操作的整体流程" class="headerlink" title="异步操作的整体流程"></a>异步操作的整体流程</h2><p>Boost.Asio 的异步操作遵循一个清晰的流程，可以用以下图示表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">应用程序线程          Boost.Asio          操作系统           硬件</span><br><span class="line">     |                  |                   |               |</span><br><span class="line">     | async_read()     |                   |               |</span><br><span class="line">     |-----------------&gt;|                   |               |</span><br><span class="line">     |                  | 将操作存入队列      |               |</span><br><span class="line">     |                  |------------------&gt;|               |</span><br><span class="line">     |                  |                   | 注册事件通知    |</span><br><span class="line">     |                  |                   |--------------&gt;|</span><br><span class="line">     | 立即返回          |                   |               |</span><br><span class="line">     |&lt;-----------------|                   |               |</span><br><span class="line">     | 继续其他工作       |                   |               |</span><br><span class="line">     |     .            |                   |               |</span><br><span class="line">     |     .            |                   | 数据到达/事件发生 |</span><br><span class="line">     |     .            |                   |&lt;--------------|</span><br><span class="line">     |     .            |                   | 通知事件就绪    |</span><br><span class="line">     |     .            |&lt;----------------------------------|</span><br><span class="line">     |     .            | 从队列取出回调      |               |</span><br><span class="line">     |     .            | 分派到 io_context   |               |</span><br><span class="line">     |     .            |------------------&gt;|               |</span><br><span class="line">     |                  | 执行回调函数       |               |</span><br><span class="line">     |&lt;-------------------------------------|               |</span><br></pre></td></tr></table></figure>

<h2 id="详细分解执行过程"><a href="#详细分解执行过程" class="headerlink" title="详细分解执行过程"></a>详细分解执行过程</h2><h3 id="1-发起异步操作-async-read-async-write-async-accept"><a href="#1-发起异步操作-async-read-async-write-async-accept" class="headerlink" title="1. 发起异步操作 (async_read, async_write, async_accept)"></a>1. 发起异步操作 (<code>async_read</code>, <code>async_write</code>, <code>async_accept</code>)</h3><p>当您调用异步操作时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">async_read</span>(socket, buffer, [](error_code ec, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    <span class="comment">// 完成处理程序</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>发生的过程</strong>：</p>
<ol>
<li><p><strong>请求封装</strong>：Asio 将您的请求封装成一个操作对象，包含：</p>
<ul>
<li>操作类型（读、写、接受）</li>
<li>socket 描述符</li>
<li>缓冲区信息</li>
<li>完成处理程序（您的 lambda 函数）</li>
</ul>
</li>
<li><p><strong>排队操作</strong>：这个操作对象被放入 Asio 的内部队列中</p>
</li>
<li><p><strong>立即返回</strong>：函数调用立即返回，不会阻塞当前线程</p>
</li>
</ol>
<h3 id="2-操作系统层面的处理"><a href="#2-操作系统层面的处理" class="headerlink" title="2. 操作系统层面的处理"></a>2. 操作系统层面的处理</h3><h4 id="Linux-使用-epoll"><a href="#Linux-使用-epoll" class="headerlink" title="Linux (使用 epoll)"></a>Linux (使用 epoll)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的内部过程</span></span><br><span class="line"><span class="type">int</span> epoll_fd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于每个异步操作，Asio 会：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">event.events = EPOLLIN;  <span class="comment">// 对于读操作</span></span><br><span class="line">event.data.ptr = operation_object; <span class="comment">// 指向 Asio 操作对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, socket_fd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在一个或多个线程中运行：</span></span><br><span class="line"><span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>具体过程</strong>：</p>
<ol>
<li><strong>注册事件监听</strong>：Asio 通过 <code>epoll_ctl()</code> 告诉内核：”当这个 socket 有数据可读时通知我”</li>
<li><strong>等待事件</strong>：Asio 调用 <code>epoll_wait()</code> 阻塞等待事件发生</li>
<li><strong>事件发生</strong>：当数据到达 socket 时，内核唤醒 <code>epoll_wait()</code></li>
<li><strong>事件处理</strong>：Asio 获取事件信息并找到对应的操作对象</li>
</ol>
<h4 id="Windows-使用-IOCP"><a href="#Windows-使用-IOCP" class="headerlink" title="Windows (使用 IOCP)"></a>Windows (使用 IOCP)</h4><p>在 Windows 上，Asio 使用 I&#x2F;O Completion Ports：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建完成端口</span></span><br><span class="line">HANDLE iocp = <span class="built_in">CreateIoCompletionPort</span>(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联 socket 和完成端口</span></span><br><span class="line"><span class="built_in">CreateIoCompletionPort</span>(socket_handle, iocp, completion_key, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起异步操作</span></span><br><span class="line">OVERLAPPED* overlapped = operation_object;</span><br><span class="line"><span class="built_in">WSARecv</span>(socket, buffers, buffer_count, &amp;bytes_transferred, &amp;flags, overlapped, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待完成通知</span></span><br><span class="line"><span class="built_in">GetQueuedCompletionStatus</span>(iocp, &amp;bytes_transferred, &amp;completion_key, &amp;overlapped, INFINITE);</span><br></pre></td></tr></table></figure>

<h3 id="3-完成处理与回调执行"><a href="#3-完成处理与回调执行" class="headerlink" title="3. 完成处理与回调执行"></a>3. 完成处理与回调执行</h3><p>当操作系统通知事件就绪时：</p>
<ol>
<li><strong>取出操作对象</strong>：Asio 从内部队列中找到对应的操作对象</li>
<li><strong>执行后续处理</strong>：读取数据、处理错误等</li>
<li><strong>准备回调</strong>：准备调用完成处理程序所需的参数</li>
<li><strong>分派回调</strong>：将回调任务放入 io_context 的执行队列</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的内部逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_operation_completion</span><span class="params">(operation_object* op)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行实际 I/O 操作</span></span><br><span class="line">    <span class="type">size_t</span> bytes_transferred = op-&gt; socket.<span class="built_in">read_some</span>(op-&gt; buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备回调参数</span></span><br><span class="line">    error_code ec = <span class="built_in">get_error_code</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将回调放入 io_context 队列</span></span><br><span class="line">    io_context.<span class="built_in">post</span>([op, ec, bytes_transferred]() &#123;</span><br><span class="line">        op-&gt; <span class="built_in">handler</span>(ec, bytes_transferred); <span class="comment">// 执行用户的回调</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-IO-Context-的角色"><a href="#4-IO-Context-的角色" class="headerlink" title="4. IO Context 的角色"></a>4. IO Context 的角色</h3><p><code>io_context</code> 是整个过程的核心协调者：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">boost::asio:: io_context io_context;</span><br><span class="line"></span><br><span class="line"><span class="comment">// io_context 内部维护：</span></span><br><span class="line"><span class="comment">// 1. 任务队列：存储待执行的完成处理程序</span></span><br><span class="line"><span class="comment">// 2. 操作系统特定的 I/O 多路复用器（epoll/iocp）</span></span><br><span class="line"><span class="comment">// 3. 线程调度器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当您调用 run()</span></span><br><span class="line">io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部循环大致如下：</span></span><br><span class="line"><span class="keyword">while</span> (! stopped) &#123;</span><br><span class="line">    <span class="comment">// 检查是否有待执行的任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">has_ready_handlers</span>()) &#123;</span><br><span class="line">        <span class="built_in">execute_ready_handlers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待 I/O 事件</span></span><br><span class="line">    <span class="type">size_t</span> triggered = <span class="built_in">poll_os_for_events</span>(timeout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理触发的事件</span></span><br><span class="line">    <span class="keyword">for</span> (每个触发的事件) &#123;</span><br><span class="line">        <span class="built_in">translate_os_event_to_handler</span>();</span><br><span class="line">        <span class="built_in">add_handler_to_ready_queue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实际代码示例"><a href="#实际代码示例" class="headerlink" title="实际代码示例"></a>实际代码示例</h2><p>让我们通过一个具体的例子来看整个流程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost:: asio;</span><br><span class="line"><span class="keyword">using</span> ip:: tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context io_context;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 socket</span></span><br><span class="line">    tcp:: <span class="function">socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接至服务器（省略连接代码）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发起异步读取</span></span><br><span class="line">    <span class="type">char</span> buffer [<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">async_read</span>(socket, <span class="built_in">buffer</span>(buffer), </span><br><span class="line">        [](boost::system:: error_code ec, std:: <span class="type">size_t</span> length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">                std:: cout &lt;&lt; <span class="string">&quot;Read &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    std:: cout &lt;&lt; <span class="string">&quot;async_read called, but we continue immediately\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运行事件循环 - 这里会处理异步操作</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行顺序</strong>：</p>
<ol>
<li><code>async_read()</code> 被调用，立即返回</li>
<li>程序继续执行，打印消息</li>
<li><code>io_context.run()</code> 开始处理事件循环</li>
<li>当数据到达时，操作系统通知 Asio</li>
<li>Asio 读取数据并调用您的 lambda 回调</li>
</ol>
<h2 id="为什么这种设计强大？"><a href="#为什么这种设计强大？" class="headerlink" title="为什么这种设计强大？"></a>为什么这种设计强大？</h2><ol>
<li><strong>可扩展性</strong>：单线程可以处理数千个并发连接</li>
<li><strong>资源高效</strong>：避免了为每个连接创建线程的开销</li>
<li><strong>响应性</strong>：不会因为 I&#x2F;O 操作而阻塞主线程</li>
<li><strong>平台抽象</strong>：统一接口，底层使用最高效的 OS 机制</li>
</ol>
<h2 id="底层机制对比"><a href="#底层机制对比" class="headerlink" title="底层机制对比"></a>底层机制对比</h2><table>
<thead>
<tr>
<th>平台</th>
<th>机制</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>epoll</td>
<td>水平触发，高效处理大量连接</td>
</tr>
<tr>
<td>Windows</td>
<td>IOCP</td>
<td>完成端口，真正的异步I&#x2F;O</td>
</tr>
<tr>
<td>macOS&#x2F;BSD</td>
<td>kqueue</td>
<td>类似epoll的高效事件通知</td>
</tr>
<tr>
<td>其他</td>
<td>select&#x2F;poll</td>
<td>作为回退机制，效率较低</td>
</tr>
</tbody></table>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>Boost.Asio 的异步操作是一个精心设计的多层系统：</p>
<ol>
<li><strong>应用层</strong>：您调用 <code>async_xxx</code> 并提供回调</li>
<li><strong>Asio层</strong>：封装操作、管理队列、与OS交互</li>
<li><strong>OS层</strong>：使用最高效的机制（epoll&#x2F;IOCP&#x2F;kqueue）监听事件</li>
<li><strong>回调层</strong>：事件就绪时，通过 <code>io_context</code> 执行您的回调</li>
</ol>
<p>这种设计使得您可以用同步的编程思维编写异步的高性能代码，而无需直接处理复杂的底层操作系统API。</p>
<p>理解这个过程有助于您编写更高效的网络代码，并更好地调试异步应用程序。</p>
<h1 id="Boost-Asio-异步读取机制深度解析"><a href="#Boost-Asio-异步读取机制深度解析" class="headerlink" title="Boost.Asio 异步读取机制深度解析"></a>Boost.Asio 异步读取机制深度解析</h1><p>您提出了几个非常关键的问题，这些正是理解异步I&#x2F;O编程的核心。让我逐一详细解释。</p>
<h2 id="1-async-read-调用后立即返回什么？"><a href="#1-async-read-调用后立即返回什么？" class="headerlink" title="1. async_read() 调用后立即返回什么？"></a>1. <code>async_read()</code> 调用后立即返回什么？</h2><p>当您调用 <code>async_read()</code> 时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">async_read</span>(socket, buffer, [](error_code ec, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    <span class="comment">// 回调函数</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>立即返回的是”操作的初始化状态”，而不是读取的结果</strong>。具体来说：</p>
<ol>
<li><strong>函数立即返回</strong>：<code>async_read()</code> 调用不会阻塞，它会立即将控制权返回给调用者</li>
<li><strong>返回类型</strong>：在Boost.Asio中，大多数异步函数返回 <code>void</code>（无返回值）</li>
<li><strong>操作未完成</strong>：实际的读取操作还没有开始，只是”请求”已经被提交</li>
</ol>
<p><strong>关键理解</strong>：<code>async_read()</code> 的调用完成不代表读取操作完成，它只是表示”我已请求在将来某个时间读取数据”</p>
<h2 id="2-异步函数执行完了吗？触发回调函数了吗？"><a href="#2-异步函数执行完了吗？触发回调函数了吗？" class="headerlink" title="2. 异步函数执行完了吗？触发回调函数了吗？"></a>2. 异步函数执行完了吗？触发回调函数了吗？</h2><ul>
<li><strong>异步函数本身已执行完毕</strong>：<code>async_read()</code> 这个函数调用已经完成</li>
<li><strong>但异步操作尚未完成</strong>：实际的数据读取操作还在等待中</li>
<li><strong>回调函数尚未触发</strong>：回调函数只有在数据真正可用时才会被调用</li>
</ul>
<p>可以把 <code>async_read()</code> 想象成”下单订购商品”：</p>
<ul>
<li>您下了订单（调用 <code>async_read()</code>）</li>
<li>商店确认收到订单（函数返回）</li>
<li>但商品还没有送达（数据尚未读取）</li>
<li>当商品送达时，才会通知您（回调函数被调用）</li>
</ul>
<h2 id="3-读事件如何从阻塞变为就绪再执行？"><a href="#3-读事件如何从阻塞变为就绪再执行？" class="headerlink" title="3. 读事件如何从阻塞变为就绪再执行？"></a>3. 读事件如何从阻塞变为就绪再执行？</h2><p>这是最核心的部分，涉及操作系统级别的I&#x2F;O多路复用机制。整个过程可以分为几个阶段：</p>
<h3 id="阶段一：注册兴趣（Registering-Interest）"><a href="#阶段一：注册兴趣（Registering-Interest）" class="headerlink" title="阶段一：注册兴趣（Registering Interest）"></a>阶段一：注册兴趣（Registering Interest）</h3><p>当您调用 <code>async_read()</code> 时，Boost.Asio 内部会：</p>
<ol>
<li>创建一个操作对象，包含您的回调函数和其他相关信息</li>
<li>告诉操作系统：”当这个socket有数据可读时，请通知我”</li>
<li>具体实现取决于操作系统：<ul>
<li><strong>Linux</strong>：使用 <code>epoll_ctl()</code> 将socket添加到epoll实例中</li>
<li><strong>Windows</strong>：使用 <code>WSARecv()</code> 发起重叠I&#x2F;O操作</li>
<li><strong>macOS&#x2F;BSD</strong>：使用 <code>kqueue()</code> 注册事件</li>
</ul>
</li>
</ol>
<h3 id="阶段二：等待事件（Waiting-for-Events）"><a href="#阶段二：等待事件（Waiting-for-Events）" class="headerlink" title="阶段二：等待事件（Waiting for Events）"></a>阶段二：等待事件（Waiting for Events）</h3><p>在 <code>io_context.run()</code> 或类似调用中，Boost.Asio 会：</p>
<ol>
<li><p>调用操作系统的多路复用函数等待事件：</p>
<ul>
<li><strong>Linux</strong>：<code>epoll_wait()</code></li>
<li><strong>Windows</strong>：<code>GetQueuedCompletionStatus()</code></li>
<li><strong>macOS&#x2F;BSD</strong>：<code>kevent()</code></li>
</ul>
</li>
<li><p>这些函数会<strong>阻塞</strong>，直到至少一个注册的事件发生</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的内部逻辑</span></span><br><span class="line"><span class="keyword">while</span> (! stopped) &#123;</span><br><span class="line">    <span class="comment">// 等待事件发生（这里会阻塞）</span></span><br><span class="line">    <span class="type">int</span> num_events = <span class="built_in">epoll_wait</span>(epoll_fd, events, max_events, timeout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理就绪的事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_events; ++i) &#123;</span><br><span class="line">        <span class="comment">// 找到对应的操作对象并执行回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阶段三：事件就绪（Event-Becomes-Ready）"><a href="#阶段三：事件就绪（Event-Becomes-Ready）" class="headerlink" title="阶段三：事件就绪（Event Becomes Ready）"></a>阶段三：事件就绪（Event Becomes Ready）</h3><p>当数据到达网络缓冲区时：</p>
<ol>
<li>网络接口卡收到数据包</li>
<li>操作系统内核处理数据包，将其放入对应socket的接收缓冲区</li>
<li>操作系统标记socket为”可读”</li>
<li>多路复用函数（如 <code>epoll_wait()</code>）检测到状态变化并返回</li>
</ol>
<h3 id="阶段四：执行回调（Executing-the-Callback）"><a href="#阶段四：执行回调（Executing-the-Callback）" class="headerlink" title="阶段四：执行回调（Executing the Callback）"></a>阶段四：执行回调（Executing the Callback）</h3><p>当多路复用函数返回后，Boost.Asio：</p>
<ol>
<li>确定哪些socket有就绪的事件</li>
<li>找到对应的操作对象</li>
<li>执行实际的读取操作（从socket缓冲区复制数据到用户缓冲区）</li>
<li>将回调函数放入执行队列</li>
<li>最终调用您的回调函数</li>
</ol>
<h2 id="完整流程示例-1"><a href="#完整流程示例-1" class="headerlink" title="完整流程示例"></a>完整流程示例</h2><p>让我们通过一个时间线来理解整个过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">时间 | 操作</span><br><span class="line">----|-----</span><br><span class="line">t0 | 程序调用 async_read(socket, buffer, callback)</span><br><span class="line">t1 | async_read() 立即返回，控制权交还程序</span><br><span class="line">t2 | 程序继续执行其他代码</span><br><span class="line">t3 | 程序调用 io_context.run()（可能在其他线程）</span><br><span class="line">t4 | io_context 调用 epoll_wait() 并阻塞</span><br><span class="line">t5 | 数据到达网络接口</span><br><span class="line">t6 | 操作系统处理数据，放入 socket 缓冲区</span><br><span class="line">t7 | 操作系统标记 socket 为可读，唤醒 epoll_wait()</span><br><span class="line">t8 | epoll_wait() 返回就绪的 socket 列表</span><br><span class="line">t9 | Boost.Asio 执行实际读取操作</span><br><span class="line">t10| Boost.Asio 将回调函数加入执行队列</span><br><span class="line">t11| 回调函数被调用，处理读取到的数据</span><br></pre></td></tr></table></figure>

<h2 id="为什么需要这种复杂机制？"><a href="#为什么需要这种复杂机制？" class="headerlink" title="为什么需要这种复杂机制？"></a>为什么需要这种复杂机制？</h2><p>这种异步模型的主要优势是：</p>
<ol>
<li><strong>高并发</strong>：单线程可以处理数千个连接</li>
<li><strong>资源高效</strong>：避免了线程创建和上下文切换的开销</li>
<li><strong>响应性</strong>：不会因为I&#x2F;O操作而阻塞主线程</li>
</ol>
<h2 id="代码示例与解释"><a href="#代码示例与解释" class="headerlink" title="代码示例与解释"></a>代码示例与解释</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost:: asio;</span><br><span class="line"><span class="keyword">using</span> ip:: tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context io_context;</span><br><span class="line">    tcp:: <span class="function">socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 假设 socket 已连接</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buffer [<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发起异步读取</span></span><br><span class="line">    <span class="built_in">async_read</span>(socket, <span class="built_in">buffer</span>(buffer), </span><br><span class="line">        [](boost::system:: error_code ec, std:: <span class="type">size_t</span> length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! ec) &#123;</span><br><span class="line">                std:: cout &lt;&lt; <span class="string">&quot;Read &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot; bytes: &quot;</span>;</span><br><span class="line">                std:: cout.<span class="built_in">write</span>(buffer, length) &lt;&lt; std:: endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std:: cout &lt;&lt; <span class="string">&quot;Read error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std:: endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    std:: cout &lt;&lt; <span class="string">&quot;async_read called, continuing immediately...&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时读取操作尚未完成，回调函数尚未调用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运行事件循环 - 这里会等待并处理异步操作</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当 run()返回时，所有异步操作已完成</span></span><br><span class="line">    std:: cout &lt;&lt; <span class="string">&quot;All async operations completed&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong><code>async_read()</code> 立即返回</strong>：表示异步读取请求已提交，但操作未完成</li>
<li><strong>回调函数尚未触发</strong>：只有在数据真正可用时才会调用</li>
<li><strong>从阻塞到就绪的过程</strong>：<ul>
<li>注册对读事件的兴趣</li>
<li>等待操作系统通知数据可用</li>
<li>数据到达时，操作系统唤醒等待的线程</li>
<li>执行实际读取操作并调用回调</li>
</ul>
</li>
</ol>
<p>这种机制使得单个线程可以高效地管理大量并发连接，是现代高性能网络编程的基石。理解这个过程对于编写高效的异步网络应用程序至关重要。</p>
<h1 id="TCP-是面向字节流的：深入解析"><a href="#TCP-是面向字节流的：深入解析" class="headerlink" title="TCP 是面向字节流的：深入解析"></a>TCP 是面向字节流的：深入解析</h1><p>这是一个非常好的问题，触及了TCP协议最核心的特征之一。简单来说，<strong>“TCP是面向字节流的”</strong> 这句话描述了TCP协议处理数据的方式：它不关心应用层消息的边界，只关心字节的正确性和顺序。</p>
<p>让我用一个生动的比喻和详细的技术解释来帮您彻底理解这个概念。</p>
<h2 id="核心比喻：水管送水"><a href="#核心比喻：水管送水" class="headerlink" title="核心比喻：水管送水"></a>核心比喻：水管送水</h2><p>想象一下TCP连接就像一根<strong>水管</strong>：</p>
<ul>
<li><strong>发送端</strong>：你从一端倒入一瓢瓢的水（应用层消息）</li>
<li><strong>接收端</strong>：从另一端接水，但你接到的可能不是完整的一瓢瓢水，而是<strong>连续的水流</strong></li>
<li><strong>TCP保证</strong>：水的总量正确、水的顺序正确、没有杂质</li>
<li><strong>TCP不保证</strong>：你每次接到的正好是完整的一瓢水</li>
</ul>
<h2 id="与UDP的对比：数据报-vs-字节流"><a href="#与UDP的对比：数据报-vs-字节流" class="headerlink" title="与UDP的对比：数据报 vs 字节流"></a>与UDP的对比：数据报 vs 字节流</h2><table>
<thead>
<tr>
<th>特性</th>
<th><strong>TCP (面向字节流)</strong></th>
<th><strong>UDP (面向数据报)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据视图</strong></td>
<td>无边界的数据流</td>
<td>有边界的独立数据包</td>
</tr>
<tr>
<td><strong>传输单位</strong></td>
<td>字节序列</td>
<td>完整的消息(数据报)</td>
</tr>
<tr>
<td><strong>消息边界</strong></td>
<td>不维护</td>
<td>严格维护</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>可靠，保证顺序</td>
<td>不可靠，可能乱序</td>
</tr>
<tr>
<td><strong>类比</strong></td>
<td>水管送水</td>
<td>邮局寄信</td>
</tr>
</tbody></table>
<h2 id="技术层面的详细解释"><a href="#技术层面的详细解释" class="headerlink" title="技术层面的详细解释"></a>技术层面的详细解释</h2><h3 id="1-发送端的视角"><a href="#1-发送端的视角" class="headerlink" title="1. 发送端的视角"></a>1. 发送端的视角</h3><p>当应用程序调用发送函数时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用程序发送三条消息</span></span><br><span class="line"><span class="built_in">send</span>(socket, <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>, <span class="number">0</span>);  <span class="comment">// 发送第一条消息</span></span><br><span class="line"><span class="built_in">send</span>(socket, <span class="string">&quot;World&quot;</span>, <span class="number">5</span>, <span class="number">0</span>);  <span class="comment">// 发送第二条消息  </span></span><br><span class="line"><span class="built_in">send</span>(socket, <span class="string">&quot;!&quot;</span>, <span class="number">1</span>, <span class="number">0</span>);      <span class="comment">// 发送第三条消息</span></span><br></pre></td></tr></table></figure>

<p>在TCP层面，这些数据可能被<strong>组合、拆分</strong>后发送：</p>
<ul>
<li>可能一次发送：<code>HelloWorld!</code> (11字节)</li>
<li>可能分多次发送：<code>Hel</code> + <code>loWorld</code> + <code>!</code></li>
<li>TCP只保证所有字节最终都能按顺序到达</li>
</ul>
<h3 id="2-接收端的视角"><a href="#2-接收端的视角" class="headerlink" title="2. 接收端的视角"></a>2. 接收端的视角</h3><p>接收端看到的是连续的字节流，不知道原始的消息边界：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer [<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> received = <span class="built_in">recv</span>(socket, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"><span class="comment">// received 可能是：11 (收到所有数据)</span></span><br><span class="line"><span class="comment">// 也可能是：3 (只收到部分数据) → 需要再次调用 recv 获取剩余数据</span></span><br></pre></td></tr></table></figure>

<h3 id="3-TCP的内部工作机制"><a href="#3-TCP的内部工作机制" class="headerlink" title="3. TCP的内部工作机制"></a>3. TCP的内部工作机制</h3><p>TCP使用<strong>序列号</strong>来跟踪每个字节的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">发送端序列号： HelloWorld!</span><br><span class="line">              0123456789A (每个字符一个序列号)</span><br><span class="line"></span><br><span class="line">接收端确认：   ACK 11 (确认收到 0-10 号字节)</span><br></pre></td></tr></table></figure>

<p>TCP维护的是字节的序列，而不是消息的边界。</p>
<h2 id="为什么这样设计？优点是什么？"><a href="#为什么这样设计？优点是什么？" class="headerlink" title="为什么这样设计？优点是什么？"></a>为什么这样设计？优点是什么？</h2><h3 id="1-灵活性"><a href="#1-灵活性" class="headerlink" title="1. 灵活性"></a>1. 灵活性</h3><p>应用程序可以自由决定如何组织数据，不受网络传输限制。</p>
<h3 id="2-效率优化"><a href="#2-效率优化" class="headerlink" title="2. 效率优化"></a>2. 效率优化</h3><ul>
<li><strong>Nagle算法</strong>：将多个小数据包组合成一个大包发送，减少网络开销</li>
<li><strong>流量控制</strong>：根据网络状况动态调整发送速率</li>
<li><strong>拥塞控制</strong>：避免网络过载，提高整体效率</li>
</ul>
<h3 id="3-可靠性保证"><a href="#3-可靠性保证" class="headerlink" title="3. 可靠性保证"></a>3. 可靠性保证</h3><p>通过序列号和确认机制，确保每个字节都正确到达。</p>
<h2 id="带来的挑战：粘包-拆包问题"><a href="#带来的挑战：粘包-拆包问题" class="headerlink" title="带来的挑战：粘包&#x2F;拆包问题"></a>带来的挑战：粘包&#x2F;拆包问题</h2><p>正因为TCP不维护消息边界，应用程序需要自己处理<strong>消息重组</strong>的问题：</p>
<h3 id="常见解决方案："><a href="#常见解决方案：" class="headerlink" title="常见解决方案："></a>常见解决方案：</h3><ol>
<li><p><strong>长度前缀法</strong>（最常用）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端：先发送 4 字节长度，再发送数据</span></span><br><span class="line"><span class="type">uint32_t</span> length = <span class="built_in">htonl</span>(data.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">send</span>(socket, &amp;length, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">send</span>(socket, data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收端：先读 4 字节长度，再读取相应长度的数据</span></span><br><span class="line"><span class="type">uint32_t</span> length;</span><br><span class="line"><span class="built_in">recv</span>(socket, &amp;length, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">length = <span class="built_in">ntohl</span>(length);</span><br><span class="line">std:: vector &lt;<span class="type">char</span>&gt; <span class="built_in">buffer</span>(length);</span><br><span class="line"><span class="built_in">recv</span>(socket, buffer.<span class="built_in">data</span>(), length, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分隔符法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在每个消息末尾添加特殊分隔符，如 &quot;\r\n&quot;</span></span><br><span class="line">std:: string message = <span class="string">&quot;Hello\r\n&quot;</span>;</span><br><span class="line"><span class="built_in">send</span>(socket, message.<span class="built_in">data</span>(), message.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>固定长度法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有消息都是固定长度，不足部分填充</span></span><br><span class="line"><span class="type">char</span> message [<span class="number">128</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">send</span>(socket, message, <span class="number">128</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="实际编程中的体现"><a href="#实际编程中的体现" class="headerlink" title="实际编程中的体现"></a>实际编程中的体现</h2><p>在Boost.Asio或类似网络库中，您会直接体验到这种字节流特性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送多次，但可能一次接收</span></span><br><span class="line"><span class="built_in">async_write</span>(socket, <span class="built_in">buffer</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>), ...);</span><br><span class="line"><span class="built_in">async_write</span>(socket, <span class="built_in">buffer</span>(<span class="string">&quot;World&quot;</span>, <span class="number">5</span>), ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收端可能一次收到 &quot;HelloWorld&quot;</span></span><br><span class="line"><span class="built_in">async_read</span>(socket, buffer, [](error_code ec, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    <span class="comment">// bytes 可能是 10，而不是 5+5</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p><strong>TCP是面向字节流的</strong>意味着：</p>
<ol>
<li><strong>数据无边界</strong>：TCP将数据视为连续的字节序列，不维护应用层消息边界</li>
<li><strong>可靠性在字节层面</strong>：保证每个字节的正确性和顺序，但不保证消息完整性</li>
<li><strong>需要应用层处理消息边界</strong>：应用程序必须自己实现消息分割和重组机制</li>
<li><strong>灵活高效</strong>：这种设计提供了更大的灵活性和网络效率优化空间</li>
</ol>
<p>理解这个概念对于编写正确的网络应用程序至关重要，因为它解释了为什么我们需要在应用层处理消息边界，而不是依赖TCP来自动完成这个任务。</p>
<h2 id="json解析错误"><a href="#json解析错误" class="headerlink" title="json解析错误"></a>json解析错误</h2><p>这个 JSON 输出中的 <code>null</code> 出现在 JSON 对象之前，这通常是因为在序列化 JSON 对象之前，您的代码中有一个未初始化的或空的 JSON 值被序列化了。在您的代码中，问题可能出现在以下几个方面：</p>
<h3 id="可能的原因和解决方案"><a href="#可能的原因和解决方案" class="headerlink" title="可能的原因和解决方案"></a>可能的原因和解决方案</h3><ol>
<li><p><strong>在设置 JSON 字段之前序列化了空的 <code>root</code> 对象</strong>：<br>在您的代码中，有一个地方在用户密码匹配后立即序列化了 <code>root</code> 对象，而此时 <code>root</code> 可能还没有设置任何字段（即为 null）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户邮箱密码匹配</span></span><br><span class="line">std:: cout &lt;&lt; <span class="string">&quot; user pwd  match&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">jsonstr = root.<span class="built_in">toStyledString</span>();  <span class="comment">// 这里序列化了空的/未设置的 root</span></span><br><span class="line">beast:: <span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br></pre></td></tr></table></figure>

<p>这行代码在设置任何字段之前就序列化了 <code>root</code>，所以会输出 <code>null</code>。然后您继续处理，设置了更多字段并再次序列化，导致输出中既有 <code>null</code> 又有完整的 JSON 对象。</p>
<p><strong>解决方案</strong>：删除这行不必要的序列化代码。</p>
</li>
<li><p><strong>多次序列化并写入响应体</strong>：<br>您的代码中有多个地方序列化 <code>root</code> 并写入响应体。如果某个分支执行后没有立即返回，可能会继续执行后续代码，导致多次写入。</p>
<p><strong>解决方案</strong>：确保每个分支在执行完毕后都立即返回，避免重复写入。</p>
</li>
</ol>
<h3 id="修改后的代码"><a href="#修改后的代码" class="headerlink" title="修改后的代码"></a>修改后的代码</h3><p>以下是修改后的代码，解决了上述问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RegPost</span>(<span class="string">&quot;/post_login&quot;</span>, [](std::shared_ptr&lt;HttpConnection&gt; connection) &#123;</span><br><span class="line">    <span class="keyword">auto</span> body_str = boost::beast:: <span class="built_in">buffers_to_string</span>(connection-&gt;_request.<span class="built_in">body</span>().<span class="built_in">data</span>());</span><br><span class="line">    std:: cout &lt;&lt; <span class="string">&quot;receive body is &quot;</span> &lt;&lt; body_str &lt;&lt; std:: endl;</span><br><span class="line">    connection-&gt;_response.<span class="built_in">set</span>(http::field:: content_type, <span class="string">&quot;text/json&quot;</span>);</span><br><span class="line">    Json:: Value root;</span><br><span class="line">    Json:: Reader reader;</span><br><span class="line">    Json:: Value src_root;</span><br><span class="line">    std:: string jsonstr;</span><br><span class="line">    <span class="type">bool</span> parse_success = reader.<span class="built_in">parse</span>(body_str, src_root);</span><br><span class="line">    <span class="keyword">if</span> (! parse_success) &#123;</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;Failed to parse JSON data!&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">        root [<span class="string">&quot;error&quot;</span>] = ErrorCodes:: Error_Json;</span><br><span class="line">        jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">        beast:: <span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出 response body</span></span><br><span class="line">        std:: string response_body = boost::beast:: <span class="built_in">buffers_to_string</span>(connection-&gt;_response.<span class="built_in">body</span>().<span class="built_in">data</span>());</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;Response body: &quot;</span> &lt;&lt; response_body &lt;&lt; std:: endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> email = src_root [<span class="string">&quot;email&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">    <span class="keyword">auto</span> pwd = src_root [<span class="string">&quot;password&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">    <span class="comment">//查询数据库判断用户名和密码是否匹配</span></span><br><span class="line">    UserInfo userInfo;</span><br><span class="line">    <span class="type">bool</span> pwd_valid = MysqlManager:: <span class="built_in">GetInstance</span>()-&gt; <span class="built_in">Login</span>(email, pwd, userInfo);</span><br><span class="line">    <span class="keyword">if</span> (! pwd_valid) &#123;<span class="comment">//不匹配</span></span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot; user pwd not match&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">        root [<span class="string">&quot;error&quot;</span>] = ErrorCodes:: PasswdErr;</span><br><span class="line">        jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">        beast:: <span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出 response body</span></span><br><span class="line">        std:: string response_body = boost::beast:: <span class="built_in">buffers_to_string</span>(connection-&gt;_response.<span class="built_in">body</span>().<span class="built_in">data</span>());</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;Response body: &quot;</span> &lt;&lt; response_body &lt;&lt; std:: endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用户邮箱密码匹配</span></span><br><span class="line">    std:: cout &lt;&lt; <span class="string">&quot; user pwd match&quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回成功查询 StatusServer 找到合适的连接</span></span><br><span class="line">    <span class="keyword">auto</span> reply = StatusGrpcClient:: <span class="built_in">GetInstance</span>()-&gt; <span class="built_in">GetChatServer</span>(userInfo.id);</span><br><span class="line">    <span class="comment">//未查找到合适的连接</span></span><br><span class="line">    <span class="keyword">if</span> (reply.<span class="built_in">error</span>()) &#123;</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot; grpc get chat server failed, error is &quot;</span> &lt;&lt; reply.<span class="built_in">error</span>() &lt;&lt; std:: endl;</span><br><span class="line">        root [<span class="string">&quot;error&quot;</span>] = ErrorCodes:: RPCFailed;</span><br><span class="line">        jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">        beast:: <span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出 response body</span></span><br><span class="line">        std:: string response_body = boost::beast:: <span class="built_in">buffers_to_string</span>(connection-&gt;_response.<span class="built_in">body</span>().<span class="built_in">data</span>());</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;Response body: &quot;</span> &lt;&lt; response_body &lt;&lt; std:: endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找到合适的连接返回</span></span><br><span class="line">    std:: cout &lt;&lt; <span class="string">&quot;succeed to load userinfo uid is &quot;</span> &lt;&lt; userInfo.id &lt;&lt; std:: endl;</span><br><span class="line">    root [<span class="string">&quot;error&quot;</span>] = ErrorCodes:: Success;</span><br><span class="line">    root [<span class="string">&quot;email&quot;</span>] = email;</span><br><span class="line">    root [<span class="string">&quot;uid&quot;</span>] = userInfo.id;</span><br><span class="line">    root [<span class="string">&quot;token&quot;</span>] = reply.<span class="built_in">token</span>();</span><br><span class="line">    root [<span class="string">&quot;host&quot;</span>] = reply.<span class="built_in">host</span>();</span><br><span class="line">    root [<span class="string">&quot;port&quot;</span>] = reply.<span class="built_in">port</span>();</span><br><span class="line">    jsonstr = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">    beast:: <span class="built_in">ostream</span>(connection-&gt;_response.<span class="built_in">body</span>()) &lt;&lt; jsonstr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出 response body</span></span><br><span class="line">    std:: string response_body = boost::beast:: <span class="built_in">buffers_to_string</span>(connection-&gt;_response.<span class="built_in">body</span>().<span class="built_in">data</span>());</span><br><span class="line">    std:: cout &lt;&lt; <span class="string">&quot;Response body: &quot;</span> &lt;&lt; response_body &lt;&lt; std:: endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="关键修改"><a href="#关键修改" class="headerlink" title="关键修改"></a>关键修改</h3><ol>
<li><p>删除了在用户密码匹配后立即序列化 <code>root</code> 的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除了这两行：</span></span><br><span class="line"><span class="comment">// jsonstr = root.toStyledString();</span></span><br><span class="line"><span class="comment">// beast:: ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>确保每个分支在执行完毕后都立即返回，避免重复写入响应体。</p>
</li>
</ol>
<h3 id="其他可能的原因"><a href="#其他可能的原因" class="headerlink" title="其他可能的原因"></a>其他可能的原因</h3><p>如果上述修改后问题仍然存在，请检查：</p>
<ol>
<li><p><strong>是否有其他代码在处理相同的请求</strong>：确保没有其他处理程序也在处理 <code>/post_login</code> 请求并写入响应体。</p>
</li>
<li><p><strong>响应体是否被多次写入</strong>：检查是否有其他地方调用了 <code>beast::ostream(connection-&gt;_response.body())</code>。</p>
</li>
<li><p><strong>JSON 序列化问题</strong>：确保 <code>root</code> 对象在序列化前已正确初始化并设置了所有必要的字段。</p>
</li>
</ol>
<p>通过以上修改，您应该能够消除 JSON 输出中的 <code>null</code>，只输出完整的 JSON 对象。</p>
<p>好的，这是一个非常实际且重要的问题。我们来详细拆解一下TCP和UDP的区别，并看看在Boost.Asio代码上如何体现。</p>
<h3 id="一、TCP-vs-UDP-核心区别"><a href="#一、TCP-vs-UDP-核心区别" class="headerlink" title="一、TCP vs UDP 核心区别"></a>一、TCP vs UDP 核心区别</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">TCP (传输控制协议)</th>
<th align="left">UDP (用户数据报协议)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>连接</strong></td>
<td align="left"><strong>面向连接的</strong> (Connection-oriented)。通信前必须通过三次握手建立稳定连接。</td>
<td align="left"><strong>无连接的</strong> (Connectionless)。直接发送数据，无需建立连接。</td>
</tr>
<tr>
<td align="left"><strong>可靠性</strong></td>
<td align="left"><strong>可靠的</strong> (Reliable)。通过确认、重传、校验和等机制确保数据<strong>不丢失、不重复、按序到达</strong>。</td>
<td align="left"><strong>不可靠的</strong> (Unreliable)。发送即忘，不保证送达，不保证顺序。</td>
</tr>
<tr>
<td align="left"><strong>数据传输</strong></td>
<td align="left"><strong>字节流</strong> (Byte Stream)。没有消息边界。你写入10字节+20字节，对方可能一次收到30字节。</td>
<td align="left"><strong>数据报</strong> (Datagram)。<strong>有消息边界</strong>。你发送一个数据报（包），对方就会作为一个完整的消息接收。</td>
</tr>
<tr>
<td align="left"><strong>拥塞控制</strong></td>
<td align="left"><strong>有</strong>。会动态调整发送速率以避免网络过载，更公平。</td>
<td align="left"><strong>无</strong>。尽可能快地发送数据，容易造成网络拥堵。</td>
</tr>
<tr>
<td align="left"><strong>速度&#x2F;开销</strong></td>
<td align="left"><strong>慢</strong>，开销大。因为要维护连接、保证可靠性和顺序。</td>
<td align="left"><strong>快</strong>，开销小。几乎没有额外控制开销。</td>
</tr>
<tr>
<td align="left"><strong>头部大小</strong></td>
<td align="left">较大 (通常20字节以上)</td>
<td align="left">较小 (仅8字节)</td>
</tr>
<tr>
<td align="left"><strong>通信模型</strong></td>
<td align="left">只能是一对一 (单播)</td>
<td align="left">支持单播、多播、广播</td>
</tr>
</tbody></table>
<h1 id="简单比喻：TCP-and-UDP"><a href="#简单比喻：TCP-and-UDP" class="headerlink" title="简单比喻：TCP and UDP"></a>简单比喻：TCP and UDP</h1><ul>
<li><strong>TCP</strong> 像打电话：需要先拨号接通（建立连接），双方确认对方在听，你说一句对方回复一句（确认），确保信息准确传达。</li>
<li><strong>UDP</strong> 像发邮政明信片：你写好地址内容就扔进邮筒（发送），不确认对方是否收到，明信片也可能丢失或乱序到达。</li>
</ul>
<hr>
<h3 id="二、代码实现上的区别-基于-Boost-Asio"><a href="#二、代码实现上的区别-基于-Boost-Asio" class="headerlink" title="二、代码实现上的区别 (基于 Boost.Asio)"></a>二、代码实现上的区别 (基于 Boost.Asio)</h3><p>你平时用<code>boost::asio::ip::tcp::socket</code>，而UDP则使用<code>boost::asio::ip::udp::socket</code>。这是最根本的区别。以下是关键差异点：</p>
<h4 id="1-无需连接管理-Connectionless"><a href="#1-无需连接管理-Connectionless" class="headerlink" title="1. 无需连接管理 (Connectionless)"></a>1. 无需连接管理 (Connectionless)</h4><p>UDP没有<code>connect()</code>, <code>accept()</code>, <code>listen()</code>这些概念（虽然Boost.Asio提供了<code>connect()</code>函数用于过滤发送源，但并非建立连接）。</p>
<ul>
<li><strong>TCP服务端</strong>典型流程：<code>acceptor.accept(socket)</code> -&gt; 得到一个与客户端连接的socket。</li>
<li><strong>UDP服务端</strong>典型流程：创建一个socket并绑定到端点<code>(ip, port)</code>，然后直接在这个socket上<code>receive_from</code>和<code>send_to</code>任何客户端。</li>
</ul>
<h4 id="2-使用-send-to-receive-from-而非-send-receive"><a href="#2-使用-send-to-receive-from-而非-send-receive" class="headerlink" title="2. 使用 send_to &#x2F; receive_from 而非 send &#x2F; receive"></a>2. 使用 <code>send_to</code> &#x2F; <code>receive_from</code> 而非 <code>send</code> &#x2F; <code>receive</code></h4><p>因为无连接，每次发送都必须指定目标地址，每次接收也都能得到发送方的地址。</p>
<ul>
<li><p><strong>TCP</strong> 使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::<span class="built_in">write</span>(socket, boost::asio::<span class="built_in">buffer</span>(data)); <span class="comment">// 发送</span></span><br><span class="line">boost::asio::<span class="built_in">read</span>(socket, boost::asio::<span class="built_in">buffer</span>(data));  <span class="comment">// 接收</span></span><br><span class="line"><span class="comment">// 或者 socket.async_read_some / async_write_some</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>UDP</strong> 使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送：需要指定目标端点 (endpoint)</span></span><br><span class="line">socket.<span class="built_in">send_to</span>(boost::asio::<span class="built_in">buffer</span>(data), receiver_endpoint);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收：需要一个变量来存储“是谁发来的”</span></span><br><span class="line">udp::endpoint remote_endpoint; <span class="comment">// 用来存放发送方的地址</span></span><br><span class="line">socket.<span class="built_in">receive_from</span>(boost::asio::<span class="built_in">buffer</span>(recv_buf), remote_endpoint);</span><br><span class="line"><span class="comment">// 异步版本类似</span></span><br><span class="line">socket.<span class="built_in">async_receive_from</span>(boost::asio::<span class="built_in">buffer</span>(recv_buf), remote_endpoint, handler);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-消息边界-Message-Boundary"><a href="#3-消息边界-Message-Boundary" class="headerlink" title="3. 消息边界 (Message Boundary)"></a>3. 消息边界 (Message Boundary)</h4><p>这是处理数据时最大的不同。</p>
<ul>
<li><strong>TCP</strong>：你需要自己定义<strong>协议</strong>来划分消息边界（例如：在每个消息前加一个消息头，指明消息体的长度）。</li>
<li><strong>UDP</strong>：一次<code>receive_from</code>调用对应对方的一次<code>send_to</code>调用。你收到的就是一个完整的包。无需担心粘包问题。</li>
</ul>
<hr>
<h3 id="三、代码示例：UDP-Echo-Server-vs-TCP-Echo-Server"><a href="#三、代码示例：UDP-Echo-Server-vs-TCP-Echo-Server" class="headerlink" title="三、代码示例：UDP Echo Server vs TCP Echo Server"></a>三、代码示例：UDP Echo Server vs TCP Echo Server</h3><p>让我们看一个最简单的Echo服务器对比。</p>
<h4 id="TCP-Echo-Server-片段-异步接受后"><a href="#TCP-Echo-Server-片段-异步接受后" class="headerlink" title="TCP Echo Server (片段 - 异步接受后)"></a>TCP Echo Server (片段 - 异步接受后)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 有 acceptor.accept 过程 ...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    socket_.<span class="built_in">async_read_some</span>(</span><br><span class="line">        boost::asio::<span class="built_in">buffer</span>(data_),</span><br><span class="line">        [<span class="keyword">this</span>](boost::system::error_code ec, std::<span class="type">size_t</span> length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                <span class="comment">// 收到数据，直接写回。注意：读到的长度是length，不代表一个完整的“消息”</span></span><br><span class="line">                boost::asio::<span class="built_in">async_write</span>(</span><br><span class="line">                    socket_,</span><br><span class="line">                    boost::asio::<span class="built_in">buffer</span>(data_, length),</span><br><span class="line">                    [<span class="keyword">this</span>](boost::system::error_code ec, std::<span class="type">size_t</span> <span class="comment">/*length*/</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                            <span class="built_in">do_read</span>(); <span class="comment">// 继续读</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UDP-Echo-Server-完整示例"><a href="#UDP-Echo-Server-完整示例" class="headerlink" title="UDP Echo Server (完整示例)"></a>UDP Echo Server (完整示例)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UDP_Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UDP_Server</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port)</span><br><span class="line">        : <span class="built_in">socket_</span>(io_context, udp::<span class="built_in">endpoint</span>(udp::<span class="built_in">v4</span>(), port)) <span class="comment">// 创建并绑定！</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">start_receive</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start_receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备一个缓冲区和一个端点来接收数据</span></span><br><span class="line">        socket_.<span class="built_in">async_receive_from</span>(</span><br><span class="line">            boost::asio::<span class="built_in">buffer</span>(recv_buffer_), remote_endpoint_,</span><br><span class="line">            [<span class="keyword">this</span>](boost::system::error_code ec, std::<span class="type">size_t</span> bytes_recvd) &#123;</span><br><span class="line">                <span class="built_in">handle_receive</span>(ec, bytes_recvd);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_receive</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!error &amp;&amp; bytes_transferred &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将收到的数据原封不动地发回给发送者 (remote_endpoint_)</span></span><br><span class="line">            <span class="comment">// 注意：我们使用 bytes_transferred 来确定发送多少字节</span></span><br><span class="line">            socket_.<span class="built_in">async_send_to</span>(</span><br><span class="line">                boost::asio::<span class="built_in">buffer</span>(recv_buffer_, bytes_transferred), remote_endpoint_,</span><br><span class="line">                [<span class="keyword">this</span>](boost::system::error_code <span class="comment">/*ec*/</span>, std::<span class="type">size_t</span> <span class="comment">/*bytes_sent*/</span>) &#123;</span><br><span class="line">                    <span class="comment">// 发送完成后，继续监听下一个数据报</span></span><br><span class="line">                    <span class="built_in">start_receive</span>();</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 出错也继续监听</span></span><br><span class="line">            <span class="built_in">start_receive</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    udp::socket socket_;</span><br><span class="line">    udp::endpoint remote_endpoint_; <span class="comment">// 关键！用于存放发送方地址</span></span><br><span class="line">    std::array&lt;<span class="type">char</span>, 1024&gt; recv_buffer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context io_context;</span><br><span class="line">        <span class="function">UDP_Server <span class="title">server</span><span class="params">(io_context, <span class="number">12345</span>)</span></span>; <span class="comment">// 在12345端口启动UDP服务器</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;UDP Server started on port 12345\n&quot;</span>;</span><br><span class="line">        io_context.<span class="built_in">run</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、何时使用UDP？"><a href="#四、何时使用UDP？" class="headerlink" title="四、何时使用UDP？"></a>四、何时使用UDP？</h3><p>既然UDP不可靠，为什么还要用它？<strong>在特定场景下，速度比可靠性更重要。</strong></p>
<ol>
<li><strong>音视频流媒体&#x2F;实时游戏</strong>：丢失一两个帧（数据包）远比赛道卡顿（等待重传）要好。例如：视频通话、在线游戏的角色位置。</li>
<li><strong>DNS查询</strong>：查询请求很小，无连接开销低，如果没收到回复，客户端重试一次即可。</li>
<li><strong>广播&#x2F;多播</strong>：例如网络发现协议（“谁是这个网段里的打印机？”）。</li>
<li>** VoIP**：和音视频类似。</li>
<li><strong>自定义可靠协议</strong>：在UDP之上实现<strong>自己需要的</strong>可靠性机制（例如：<strong>KCP</strong>、<strong>QUIC</strong>&#x2F;HTTP3）。这可以让你摆脱TCP的拥塞控制算法，为你的特定应用优化传输效率。</li>
</ol>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">代码层面</th>
<th align="left">TCP</th>
<th align="left">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Socket类型</strong></td>
<td align="left"><code>boost::asio::ip::tcp::socket</code></td>
<td align="left"><code>boost::asio::ip::udp::socket</code></td>
</tr>
<tr>
<td align="left"><strong>建立连接</strong></td>
<td align="left">需要 <code>acceptor</code>, <code>accept()</code>, <code>connect()</code></td>
<td align="left">无需，直接 <code>bind()</code> 即可</td>
</tr>
<tr>
<td align="left"><strong>发送函数</strong></td>
<td align="left"><code>async_write</code>, <code>send</code></td>
<td align="left"><code>async_send_to</code>, <code>send_to</code></td>
</tr>
<tr>
<td align="left"><strong>接收函数</strong></td>
<td align="left"><code>async_read_some</code>, <code>receive</code></td>
<td align="left"><code>async_receive_from</code>, <code>receive_from</code></td>
</tr>
<tr>
<td align="left"><strong>数据边界</strong></td>
<td align="left">无，是流，需自定义协议</td>
<td align="left">有，数据报天然有边界</td>
</tr>
<tr>
<td align="left"><strong>端点管理</strong></td>
<td align="left">每个连接一个socket，端点固定</td>
<td align="left">一个socket与多个端点通信，需变量存储临时端点</td>
</tr>
</tbody></table>
<p>如果你想从TCP切换到UDP，最关键的就是改变<strong>无连接</strong>和<strong>数据报</strong>的思维模式，并在代码中熟练使用<code>send_to</code>&#x2F;<code>receive_from</code>和<code>endpoint</code>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://brinjaul521.github.io">贺腾</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://brinjaul521.github.io/2025/09/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">https://brinjaul521.github.io/2025/09/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://brinjaul521.github.io" target="_blank">贺腾的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">C++ 网络编程</a></div><div class="post-share"><div class="social-share" data-image="/img/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/17/Qt%E6%80%9D%E8%B7%AF/" title="Qt思路"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Qt思路</div></div><div class="info-2"><div class="info-item-1">Qt开发对象树级联问题打印结果说明两个窗口 对象都活着，但 isVisible() == false，所以它们 根本没被 show() 成功。出现这种情况只有两种可能：  你调用 show() 的对象并不是你正在打印的对象（名字或指针指错了）。   调用了 show() 之后，代码又在同一函数里把窗口立刻 hide() 掉了（或把父窗口隐藏导致子窗口也被隐藏）。   🔍 现场排查 2 步① 确认打印的实例 &#x3D;&#x3D; 你真正 show() 的实例在 showChildWindow() 里加一行： 12345qDebug() &lt;&lt; &quot;showChildWindow called on&quot; &lt;&lt; _childDialog;_childDialog-&gt;show();qDebug() &lt;&lt; &quot;after show:&quot;         &lt;&lt; &quot;visible&quot; &lt;&lt; _childDialog-&gt;isVisible()         &lt;&l...</div></div></div></a><a class="pagination-related" href="/2025/09/17/MySql%E7%AC%94%E8%AE%B0/" title="MySql笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MySql笔记</div></div><div class="info-2"><div class="info-item-1">Mysql索引好的，这是一个非常重要且常见的面试话题。我会从原理到实践，为你彻底讲清楚 MySQL 索引。  一、索引是什么？（本质与原理）你可以把数据库索引想象成一本书的目录。  没有索引（目录）：当你想在书中找到“索引失效”这个内容时，你只能一页一页地从头翻到尾（这叫做全表扫描），效率极低。 有索引（目录）：你可以直接查看目录，快速定位到“索引失效”内容所在的页码，然后直接翻到那一页。这个“目录”就是索引，它通过建立一种高效的数据结构，避免了逐行查找。  技术本质：索引是一种排好序的快速查找数据结构。MySQL 中最常用的索引类型是 B+Tree（B+树）。 B+Tree 的特点（为什么选它）：  矮胖树：层级低，通常只需要 3-4 次 I&#x2F;O 操作就能从上亿条数据中定位到目标，查找效率极高。 有序存储：叶子节点存储数据并按顺序链接，非常适合范围查询（WHERE id &gt; 100）和排序（ORDER BY）。 数据只存储在叶子节点：非叶子节点只存键值，使得每个节点能存放更多的关键字，让树更“矮胖”。  索引的代价：  空间代价：索引也是一张表，需要占用额外的磁...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">贺腾</div><div class="author-info-description">我等的不是海边</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/brinjaul521/" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/1061391142@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">网络编程笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">网络编程核心概念与流程详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">Socket 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA-Socket%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">为什么要创建 Socket？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%A5-TCP-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">Socket 的工作流程（以 TCP 为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1. 服务端流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E5%88%9B%E5%BB%BA-Socket"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">步骤 1：创建 Socket</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E7%BB%91%E5%AE%9A-IP-%E5%92%8C%E7%AB%AF%E5%8F%A3%EF%BC%88Bind%EF%BC%89"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">步骤 2：绑定 IP 和端口（Bind）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E7%9B%91%E5%90%AC%E8%BF%9E%E6%8E%A5%EF%BC%88Listen%EF%BC%89"><span class="toc-number">1.1.3.1.3.</span> <span class="toc-text">步骤 3：监听连接（Listen）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-4%EF%BC%9A%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5%EF%BC%88Accept%EF%BC%89"><span class="toc-number">1.1.3.1.4.</span> <span class="toc-text">步骤 4：接受连接（Accept）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-5%EF%BC%9A%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88Read-Write%EF%BC%89"><span class="toc-number">1.1.3.1.5.</span> <span class="toc-text">步骤 5：收发数据（Read&#x2F;Write）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2. 客户端流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E5%88%9B%E5%BB%BA-Socket-1"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">步骤 1：创建 Socket</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%88Connect%EF%BC%89"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">步骤 2：连接服务端（Connect）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88Write-Read%EF%BC%89"><span class="toc-number">1.1.3.2.3.</span> <span class="toc-text">步骤 3：收发数据（Write&#x2F;Read）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-%E7%9A%84%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.4.</span> <span class="toc-text">Socket 的底层工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1. TCP 三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9C%80%E8%A6%81%E5%A4%9A-Socket%EF%BC%9F"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2. 为什么服务端需要多 Socket？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">3. 数据传输流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">完整通信流程示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81%EF%BC%88%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">服务端代码（伪代码）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%EF%BC%88%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">客户端代码（伪代码）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.6.</span> <span class="toc-text">关键概念总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.7.</span> <span class="toc-text">类比理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.8.</span> <span class="toc-text">服务端与客户端的交互流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%86%E8%8A%82%E8%A1%A5%E5%85%85"><span class="toc-number">1.1.9.</span> <span class="toc-text">关键细节补充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AA-Socket%EF%BC%9F"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">1. 为什么需要两个 Socket？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TCP-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E6%97%B6%E6%9C%BA"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">2. TCP 连接的建立时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%9A%E8%AF%9D-Socket-%E7%9A%84%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.9.3.</span> <span class="toc-text">3. 会话 Socket 的端口问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">1.1.10.</span> <span class="toc-text">完整流程示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.11.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%EF%BC%88Endpoint%EF%BC%89%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A"><span class="toc-number">1.2.</span> <span class="toc-text">终端节点（Endpoint）的详细解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">终端节点的核心定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">组成要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">核心作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">终端节点在不同协议中的表现形式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-UDP"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">TCP&#x2F;UDP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UNIX-%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%88%E6%9C%AC%E5%9C%B0%E9%80%9A%E4%BF%A1%EF%BC%89"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">UNIX 域套接字（本地通信）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-WebSocket"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">HTTP&#x2F;WebSocket</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">终端节点的工作机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">客户端如何构造终端节点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">服务端如何绑定终端节点？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.4.</span> <span class="toc-text">终端节点的关键特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">唯一性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">动态性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%85%B3%E8%81%94%E6%80%A7"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">协议关联性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">终端节点的实际应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%88Python%EF%BC%89"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">客户端代码示例（Python）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%88Python%EF%BC%89"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">服务端代码示例（Python）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%9F"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">为什么需要端口号？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E8%8A%82%E7%82%B9%E4%B8%8E-Socket-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">终端节点与 Socket 的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">如何避免端口冲突？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.2.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">流程实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81%EF%BC%88%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">服务端代码（同步阻塞模型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%EF%BC%88%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">客户端代码（同步阻塞模型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.3.</span> <span class="toc-text">代码详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">服务端关键步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">客户端关键步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="toc-number">1.3.4.</span> <span class="toc-text">编译与运行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85-Boost-%E5%BA%93"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">1. 安装 Boost 库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4%EF%BC%88Linux%EF%BC%89"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">2. 编译命令（Linux）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%90%E8%A1%8C"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">3. 运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">1.3.5.</span> <span class="toc-text">流程示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.3.6.</span> <span class="toc-text">关键概念回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9F"><span class="toc-number">1.3.7.</span> <span class="toc-text">扩展：如何处理多个客户端？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">Socket 生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E8%A7%92%E8%89%B2"><span class="toc-number">1.4.1.</span> <span class="toc-text">Socket 的阶段性角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%9B%E5%BB%BA-Socket-%E6%97%B6%E4%B8%8D%E9%9C%80%E7%AB%AF%E7%82%B9%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">为什么创建 Socket 时不需端点信息？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Socket-%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%80%A7"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">(1) Socket 的抽象性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AB%AF%E7%82%B9%E4%BF%A1%E6%81%AF%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">(2) 端点信息的动态性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">完整流程示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81%EF%BC%88%E9%99%84%E5%8A%A0%E7%AB%AF%E7%82%B9%E4%BF%A1%E6%81%AF%E7%9A%84%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">服务端代码（附加端点信息的阶段）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%EF%BC%88%E9%99%84%E5%8A%A0%E7%AB%AF%E7%82%B9%E4%BF%A1%E6%81%AF%E7%9A%84%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">客户端代码（附加端点信息的阶段）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%9C%BA%E5%88%B6%E8%A7%A3%E9%87%8A"><span class="toc-number">1.4.4.</span> <span class="toc-text">关键机制解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%86%E9%85%8D"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">(1) 客户端端口的自动分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%9B%BA%E5%AE%9A%E6%80%A7"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">(2) 服务端端口的固定性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%AB%AF%E7%82%B9%E4%BF%A1%E6%81%AF%E7%9A%84%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">(3) 端点信息的延迟绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%AB%AF%E7%82%B9%E4%BF%A1%E6%81%AF%E6%B5%81"><span class="toc-number">1.4.5.</span> <span class="toc-text">完整通信流程中的端点信息流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.4.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boost-asio-ip-tcp-acceptor-%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">boost::asio::ip::tcp:: acceptor 的详细解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81tcp-acceptor-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">一、tcp::acceptor 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.5.2.</span> <span class="toc-text">二、核心方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1. 构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-bind-%E7%BB%91%E5%AE%9A%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%AB%AF%E7%82%B9"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">2. bind() - 绑定到本地端点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-listen-%E5%BC%80%E5%A7%8B%E7%9B%91%E5%90%AC"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">3. listen() - 开始监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-accept-%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">4. accept() - 接受连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-async-accept-%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">5. async_accept() - 异步接受连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">6. 其他方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">三、完整代码示例（同步模型）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">服务端代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.5.4.</span> <span class="toc-text">四、关键概念详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%B0%E5%9D%80%E9%87%8D%E7%94%A8-reuse-address"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">1. 地址重用 (reuse_address)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5-vs-%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">2. 同步 vs 异步接受连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">3. 处理多个客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.5.</span> <span class="toc-text">五、异步接受连接示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.6.</span> <span class="toc-text">六、总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#acceptor-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.5.7.</span> <span class="toc-text">acceptor 的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%80%BB%E8%BE%91"><span class="toc-number">1.5.8.</span> <span class="toc-text">** 设计逻辑**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81"><span class="toc-number">1.5.9.</span> <span class="toc-text">代码验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.10.</span> <span class="toc-text">功能区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.11.</span> <span class="toc-text">** 代码示例**</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BD%BF%E7%94%A8-acceptor-%E5%92%8C-socket%EF%BC%9A"><span class="toc-number">1.5.11.1.</span> <span class="toc-text">服务端使用 acceptor 和 socket：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.5.12.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A"><span class="toc-number">1.6.</span> <span class="toc-text">线程池：从入门到精通</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E7%A1%80"><span class="toc-number">1.6.1.</span> <span class="toc-text">线程池基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.2.</span> <span class="toc-text">线程池工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.3.</span> <span class="toc-text">线程池关键参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C-%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">实现一个简单线程池（C++示例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98"><span class="toc-number">1.6.5.</span> <span class="toc-text">线程池高级主题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.6.</span> <span class="toc-text">线程池性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.6.7.</span> <span class="toc-text">常见问题与解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.8.</span> <span class="toc-text">实际应用案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.6.9.</span> <span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boost-Asio-%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88boost-asio-buffer%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.7.</span> <span class="toc-text">Boost.Asio 缓冲区（boost::asio:: buffer）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">缓冲区的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-boost-asio-buffer%EF%BC%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">为什么使用 boost::asio:: buffer？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">缓冲区的创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">从原始数组创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-std-vector-%E5%88%9B%E5%BB%BA"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">从 std::vector 创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-std-string-%E5%88%9B%E5%BB%BA"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">从 std::string 创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%EF%BC%88%E9%9C%80%E7%AE%A1%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89"><span class="toc-number">1.7.3.4.</span> <span class="toc-text">从智能指针创建（需管理生命周期）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.4.</span> <span class="toc-text">四、缓冲区的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.7.5.</span> <span class="toc-text">缓冲区的使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E5%90%8C%E6%AD%A5%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">示例 1：同步写入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">示例 2：异步读取数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.6.</span> <span class="toc-text">缓冲区的生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">关键规则：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5%EF%BC%9A"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">安全实践：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%95%A3-%E8%81%9A%E9%9B%86-IO%EF%BC%88Scatter-Gather%EF%BC%89"><span class="toc-number">1.7.7.</span> <span class="toc-text">分散-聚集 IO（Scatter-Gather）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%90%8C%E6%97%B6%E5%86%99%E5%85%A5%E5%A4%B4%E5%92%8C%E4%BD%93"><span class="toc-number">1.7.7.1.</span> <span class="toc-text">示例：同时写入头和体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88dynamic-buffer%EF%BC%89"><span class="toc-number">1.7.8.</span> <span class="toc-text">动态缓冲区（dynamic_buffer）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8A%A8%E6%80%81%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.8.1.</span> <span class="toc-text">示例：动态读取数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">1.7.9.</span> <span class="toc-text">常见问题与解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">1.7.10.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%BA%8F%E5%88%97%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.8.</span> <span class="toc-text">缓冲序列详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">一、基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">1. 缓冲区类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%93%E5%86%B2%E5%8C%BA%E5%BA%8F%E5%88%97%EF%BC%88Buffer-Sequence%EF%BC%89"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">2. 缓冲区序列（Buffer Sequence）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">3. 适配器的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.2.</span> <span class="toc-text">二、核心区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%99%E4%BA%9B%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%9F"><span class="toc-number">1.8.3.</span> <span class="toc-text">三、为什么需要这些适配器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E9%99%85%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.4.</span> <span class="toc-text">四、实际用法示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%88%E4%BD%BF%E7%94%A8-const-buffers-1%EF%BC%89"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">1. 发送数据（使用 const_buffers_1）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%EF%BC%88%E4%BD%BF%E7%94%A8-mutable-buffers-1%EF%BC%89"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">2. 接收数据（使用 mutable_buffers_1）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">3. 手动创建适配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="toc-number">1.8.5.</span> <span class="toc-text">五、底层实现分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-const-buffers-1-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">1. const_buffers_1 的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-mutable-buffers-1-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">2. mutable_buffers_1 的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.8.6.</span> <span class="toc-text">六、自动类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.7.</span> <span class="toc-text">七、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket-write-some-%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.9.</span> <span class="toc-text">socket.write_some 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket-write-some-%E8%AF%A6%E8%A7%A3-1"><span class="toc-number">1.9.1.</span> <span class="toc-text">socket.write_some 详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">1.9.2.</span> <span class="toc-text">一、函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.9.3.</span> <span class="toc-text">二、核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.9.4.</span> <span class="toc-text">三、使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%8E-boost-asio-write-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.5.</span> <span class="toc-text">四、与 boost::asio:: write 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.9.6.</span> <span class="toc-text">五、代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%EF%BC%88%E9%9C%80%E5%A4%84%E7%90%86%E9%83%A8%E5%88%86%E5%8F%91%E9%80%81%EF%BC%89"><span class="toc-number">1.9.6.1.</span> <span class="toc-text">示例 1：基本用法（需处理部分发送）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.9.6.2.</span> <span class="toc-text">示例 2：错误处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.9.7.</span> <span class="toc-text">六、关键注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.8.</span> <span class="toc-text">七、底层机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%B9%E5%BA%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.8.1.</span> <span class="toc-text">1. 操作系统对应函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.9.8.2.</span> <span class="toc-text">2. 发送流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.9.9.</span> <span class="toc-text">八、性能与最佳实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.10.</span> <span class="toc-text">九、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81read-some-vs-read"><span class="toc-number">1.10.</span> <span class="toc-text">一、read_some vs read</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basic-stream-socket-read-some"><span class="toc-number">1.10.1.</span> <span class="toc-text">basic_stream_socket::read_some</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boost-asio-read-%E8%87%AA%E7%94%B1%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">boost::asio:: read 自由函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81write-some-vs-write"><span class="toc-number">1.10.3.</span> <span class="toc-text">二、write_some vs write</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-basic-stream-socket-write-some"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">1. basic_stream_socket::write_some</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-boost-asio-write-%E8%87%AA%E7%94%B1%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">2. boost::asio:: write 自由函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.4.</span> <span class="toc-text">三、关键区别总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.10.5.</span> <span class="toc-text">四、注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%98%BB%E5%A1%9E-vs-%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.10.5.1.</span> <span class="toc-text">1. 阻塞 vs 非阻塞模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.10.5.2.</span> <span class="toc-text">2. 异步操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">1.10.5.3.</span> <span class="toc-text">3. 缓冲区管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.10.6.</span> <span class="toc-text">五、代码实践示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-read-some-%E6%89%8B%E5%8A%A8%E5%BE%AA%E7%8E%AF%E8%AF%BB%E5%8F%96"><span class="toc-number">1.10.6.1.</span> <span class="toc-text">使用 read_some 手动循环读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-async-read-%E7%AE%80%E5%8C%96%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%8F%96"><span class="toc-number">1.10.6.2.</span> <span class="toc-text">使用 async_read 简化异步读取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.10.7.</span> <span class="toc-text">六、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-write-some"><span class="toc-number">1.11.</span> <span class="toc-text">async_write_some</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81async-write-some-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.11.1.</span> <span class="toc-text">一、async_write_some 基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">函数签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">参数说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.11.1.3.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81async-write-some-%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.11.2.</span> <span class="toc-text">二、async_write_some 的行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%93%8D%E4%BD%9C"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">1. 非阻塞操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%83%A8%E5%88%86%E5%8F%91%E9%80%81"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">2. 部分发送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.11.2.3.</span> <span class="toc-text">3. 错误处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.11.3.</span> <span class="toc-text">三、注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">1. 数据缓冲区的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%84%E7%90%86%E9%83%A8%E5%88%86%E5%8F%91%E9%80%81"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">2. 处理部分发送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">3. 线程安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%94%99%E8%AF%AF%E4%BC%A0%E6%92%AD"><span class="toc-number">1.11.3.4.</span> <span class="toc-text">4. 错误传播</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81async-write-some-vs-async-write"><span class="toc-number">1.11.4.</span> <span class="toc-text">四、async_write_some vs async_write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%86%E7%89%87%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">1.11.5.</span> <span class="toc-text">五、完整示例：分片发送数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.6.</span> <span class="toc-text">六、常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84-would-block%EF%BC%9F"><span class="toc-number">1.11.6.1.</span> <span class="toc-text">1. 如何处理非阻塞模式下的 would_block？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">1.11.6.2.</span> <span class="toc-text">2. 如何取消异步操作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">1.11.6.3.</span> <span class="toc-text">3. 如何优化性能？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.11.7.</span> <span class="toc-text">七、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-read-some-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">1.12.</span> <span class="toc-text">async_read_some 是如何工作的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.12.1.</span> <span class="toc-text">代码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-bind-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.2.</span> <span class="toc-text">std::bind 的返回值作为回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.12.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">1.12.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-send-%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90"><span class="toc-number">1.13.</span> <span class="toc-text">async_send 的详细解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async-send-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.13.1.</span> <span class="toc-text">async_send 函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.13.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.13.3.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.13.4.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.13.5.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%B2%98%E5%8C%85"><span class="toc-number">1.14.</span> <span class="toc-text">处理粘包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boost-asio%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.15.</span> <span class="toc-text">boost::asio协程实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">1.15.1.</span> <span class="toc-text">协程定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.15.2.</span> <span class="toc-text">协程关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#co-spawn%E5%92%8Cawaitable"><span class="toc-number">1.15.3.</span> <span class="toc-text">co_spawn和awaitable</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Boost-Asio-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">Boost.Asio 网络编程概念详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Endpoint-%E7%9A%84%E8%A7%92%E8%89%B2%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF-vs-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.1.</span> <span class="toc-text">1. Endpoint 的角色：服务端 vs 客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-Endpoint"><span class="toc-number">2.1.1.</span> <span class="toc-text">服务端 Endpoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-Endpoint"><span class="toc-number">2.1.2.</span> <span class="toc-text">客户端 Endpoint</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Socket-%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A%E7%8B%AC%E7%AB%8B%E8%BF%98%E6%98%AF%E5%85%B1%E4%BA%AB"><span class="toc-number">2.2.</span> <span class="toc-text">2. Socket 的使用：独立还是共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-Socket-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">服务端 Socket 使用模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-Socket-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">客户端 Socket 使用模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-IO-Context-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">3. IO Context 的使用模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%8D%95-IO-Context%EF%BC%88%E6%9C%80%E7%AE%80%E5%8D%95%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">模式一：单 IO Context（最简单）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA-IO-Context%EF%BC%88%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">模式二：多线程共享一个 IO Context（常见模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%89%EF%BC%9AIO-Context-%E6%B1%A0%EF%BC%88%E9%AB%98%E6%80%A7%E8%83%BD%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">2.3.3.</span> <span class="toc-text">模式三：IO Context 池（高性能模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%9B%9B%EF%BC%9A%E4%B8%93%E7%94%A8-IO-Context%EF%BC%88%E9%AB%98%E7%BA%A7%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">2.3.4.</span> <span class="toc-text">模式四：专用 IO Context（高级模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">2.3.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Boost-Asio-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">Boost.Asio 异步操作深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">异步操作的整体流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E5%88%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">详细分解执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%91%E8%B5%B7%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C-async-read-async-write-async-accept"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. 发起异步操作 (async_read, async_write, async_accept)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. 操作系统层面的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-%E4%BD%BF%E7%94%A8-epoll"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">Linux (使用 epoll)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows-%E4%BD%BF%E7%94%A8-IOCP"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">Windows (使用 IOCP)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%8C%E6%88%90%E5%A4%84%E7%90%86%E4%B8%8E%E5%9B%9E%E8%B0%83%E6%89%A7%E8%A1%8C"><span class="toc-number">3.2.3.</span> <span class="toc-text">3. 完成处理与回调执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-IO-Context-%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">3.2.4.</span> <span class="toc-text">4. IO Context 的角色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">实际代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E7%A7%8D%E8%AE%BE%E8%AE%A1%E5%BC%BA%E5%A4%A7%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">为什么这种设计强大？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">3.5.</span> <span class="toc-text">底层机制对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">3.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Boost-Asio-%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%8F%96%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">Boost.Asio 异步读取机制深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-async-read-%E8%B0%83%E7%94%A8%E5%90%8E%E7%AB%8B%E5%8D%B3%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1. async_read() 调用后立即返回什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E4%BA%86%E5%90%97%EF%BC%9F%E8%A7%A6%E5%8F%91%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%BA%86%E5%90%97%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2. 异步函数执行完了吗？触发回调函数了吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AF%BB%E4%BA%8B%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BB%8E%E9%98%BB%E5%A1%9E%E5%8F%98%E4%B8%BA%E5%B0%B1%E7%BB%AA%E5%86%8D%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3. 读事件如何从阻塞变为就绪再执行？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E6%B3%A8%E5%86%8C%E5%85%B4%E8%B6%A3%EF%BC%88Registering-Interest%EF%BC%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">阶段一：注册兴趣（Registering Interest）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6%EF%BC%88Waiting-for-Events%EF%BC%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">阶段二：等待事件（Waiting for Events）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%B0%B1%E7%BB%AA%EF%BC%88Event-Becomes-Ready%EF%BC%89"><span class="toc-number">4.3.3.</span> <span class="toc-text">阶段三：事件就绪（Event Becomes Ready）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E5%9B%9B%EF%BC%9A%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%EF%BC%88Executing-the-Callback%EF%BC%89"><span class="toc-number">4.3.4.</span> <span class="toc-text">阶段四：执行回调（Executing the Callback）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">4.4.</span> <span class="toc-text">完整流程示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%99%E7%A7%8D%E5%A4%8D%E6%9D%82%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">为什么需要这种复杂机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B8%8E%E8%A7%A3%E9%87%8A"><span class="toc-number">4.6.</span> <span class="toc-text">代码示例与解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">4.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-%E6%98%AF%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">TCP 是面向字节流的：深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%AF%94%E5%96%BB%EF%BC%9A%E6%B0%B4%E7%AE%A1%E9%80%81%E6%B0%B4"><span class="toc-number">5.1.</span> <span class="toc-text">核心比喻：水管送水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8EUDP%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8A%A5-vs-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">5.2.</span> <span class="toc-text">与UDP的对比：数据报 vs 字节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%B1%82%E9%9D%A2%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A"><span class="toc-number">5.3.</span> <span class="toc-text">技术层面的详细解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%91%E9%80%81%E7%AB%AF%E7%9A%84%E8%A7%86%E8%A7%92"><span class="toc-number">5.3.1.</span> <span class="toc-text">1. 发送端的视角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A5%E6%94%B6%E7%AB%AF%E7%9A%84%E8%A7%86%E8%A7%92"><span class="toc-number">5.3.2.</span> <span class="toc-text">2. 接收端的视角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-TCP%E7%9A%84%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.3.</span> <span class="toc-text">3. TCP的内部工作机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1%EF%BC%9F%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">为什么这样设计？优点是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="toc-number">5.4.1.</span> <span class="toc-text">1. 灵活性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96"><span class="toc-number">5.4.2.</span> <span class="toc-text">2. 效率优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">5.4.3.</span> <span class="toc-text">3. 可靠性保证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%8C%91%E6%88%98%EF%BC%9A%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.5.</span> <span class="toc-text">带来的挑战：粘包&#x2F;拆包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">5.5.1.</span> <span class="toc-text">常见解决方案：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">5.6.</span> <span class="toc-text">实际编程中的体现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-number">5.7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json%E8%A7%A3%E6%9E%90%E9%94%99%E8%AF%AF"><span class="toc-number">5.8.</span> <span class="toc-text">json解析错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.8.1.</span> <span class="toc-text">可能的原因和解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">5.8.2.</span> <span class="toc-text">修改后的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BF%AE%E6%94%B9"><span class="toc-number">5.8.3.</span> <span class="toc-text">关键修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.8.4.</span> <span class="toc-text">其他可能的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81TCP-vs-UDP-%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-number">5.8.5.</span> <span class="toc-text">一、TCP vs UDP 核心区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%AF%94%E5%96%BB%EF%BC%9ATCP-and-UDP"><span class="toc-number">6.</span> <span class="toc-text">简单比喻：TCP and UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%9F%BA%E4%BA%8E-Boost-Asio"><span class="toc-number">6.0.1.</span> <span class="toc-text">二、代码实现上的区别 (基于 Boost.Asio)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%97%A0%E9%9C%80%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86-Connectionless"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">1. 无需连接管理 (Connectionless)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-send-to-receive-from-%E8%80%8C%E9%9D%9E-send-receive"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">2. 使用 send_to &#x2F; receive_from 而非 send &#x2F; receive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C-Message-Boundary"><span class="toc-number">6.0.1.3.</span> <span class="toc-text">3. 消息边界 (Message Boundary)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9AUDP-Echo-Server-vs-TCP-Echo-Server"><span class="toc-number">6.0.2.</span> <span class="toc-text">三、代码示例：UDP Echo Server vs TCP Echo Server</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-Echo-Server-%E7%89%87%E6%AE%B5-%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%97%E5%90%8E"><span class="toc-number">6.0.2.1.</span> <span class="toc-text">TCP Echo Server (片段 - 异步接受后)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP-Echo-Server-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.0.2.2.</span> <span class="toc-text">UDP Echo Server (完整示例)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8UDP%EF%BC%9F"><span class="toc-number">6.0.3.</span> <span class="toc-text">四、何时使用UDP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-number">6.0.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/17/Qt%E6%80%9D%E8%B7%AF/" title="Qt思路">Qt思路</a><time datetime="2025-09-17T06:37:12.000Z" title="发表于 2025-09-17 14:37:12">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="网络编程笔记">网络编程笔记</a><time datetime="2025-09-17T06:21:12.000Z" title="发表于 2025-09-17 14:21:12">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/17/MySql%E7%AC%94%E8%AE%B0/" title="MySql笔记">MySql笔记</a><time datetime="2025-09-17T02:41:34.000Z" title="发表于 2025-09-17 10:41:34">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/17/C-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="C++面试题">C++面试题</a><time datetime="2025-09-17T02:35:14.000Z" title="发表于 2025-09-17 10:35:14">2025-09-17</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 贺腾</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>