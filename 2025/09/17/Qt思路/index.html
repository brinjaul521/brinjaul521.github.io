<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Qt思路 | 贺腾的博客</title><meta name="author" content="贺腾"><meta name="copyright" content="贺腾"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Qt开发对象树级联问题打印结果说明两个窗口 对象都活着，但 isVisible() &#x3D;&#x3D; false，所以它们 根本没被 show() 成功。出现这种情况只有两种可能：  你调用 show() 的对象并不是你正在打印的对象（名字或指针指错了）。   调用了 show() 之后，代码又在同一函数里把窗口立刻 hide() 掉了（或把父窗口隐藏导致子窗口也被隐藏）。   🔍 现场排查 2 步① 确认">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt思路">
<meta property="og:url" content="https://brinjaul521.github.io/2025/09/17/Qt%E6%80%9D%E8%B7%AF/index.html">
<meta property="og:site_name" content="贺腾的博客">
<meta property="og:description" content="Qt开发对象树级联问题打印结果说明两个窗口 对象都活着，但 isVisible() &#x3D;&#x3D; false，所以它们 根本没被 show() 成功。出现这种情况只有两种可能：  你调用 show() 的对象并不是你正在打印的对象（名字或指针指错了）。   调用了 show() 之后，代码又在同一函数里把窗口立刻 hide() 掉了（或把父窗口隐藏导致子窗口也被隐藏）。   🔍 现场排查 2 步① 确认">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://brinjaul521.github.io/img/head.jpg">
<meta property="article:published_time" content="2025-09-17T06:37:12.000Z">
<meta property="article:modified_time" content="2025-09-17T06:37:44.687Z">
<meta property="article:author" content="贺腾">
<meta property="article:tag" content="Qt开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://brinjaul521.github.io/img/head.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Qt思路",
  "url": "https://brinjaul521.github.io/2025/09/17/Qt%E6%80%9D%E8%B7%AF/",
  "image": "https://brinjaul521.github.io/img/head.jpg",
  "datePublished": "2025-09-17T06:37:12.000Z",
  "dateModified": "2025-09-17T06:37:44.687Z",
  "author": [
    {
      "@type": "Person",
      "name": "贺腾",
      "url": "https://brinjaul521.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://brinjaul521.github.io/2025/09/17/Qt%E6%80%9D%E8%B7%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Qt思路',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta property="og:type" content="article">
<meta property="og:title" content="{{ title | default config.title }}">
<meta property="og:image" content="{{ url | append cover | default config.url | append '/img/default-cover.jpg' }}">
<meta property="og:description" content="{{ description | default excerpt | default config.description }}">
<meta property="og:url" content="{{ url }}">
<meta name="twitter:card" content="summary_large_image">
<meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/background.png);"><nav id="nav"><span id="blog-info"><a href="/" title="贺腾的博客"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">贺腾的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Qt思路</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Qt思路</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-17T06:37:12.000Z" title="发表于 2025-09-17 14:37:12">2025-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-17T06:37:44.687Z" title="更新于 2025-09-17 14:37:44">2025-09-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Qt开发"><a href="#Qt开发" class="headerlink" title="Qt开发"></a>Qt开发</h1><h2 id="对象树级联问题"><a href="#对象树级联问题" class="headerlink" title="对象树级联问题"></a>对象树级联问题</h2><p>打印结果说明两个窗口 <strong>对象都活着</strong>，但 <strong><code>isVisible() == false</code></strong>，所以它们 <strong>根本没被 <code>show()</code> 成功</strong>。<br>出现这种情况只有两种可能：</p>
<ol>
<li><strong>你调用 <code>show()</code> 的对象并不是你正在打印的对象</strong>（名字或指针指错了）。  </li>
<li><strong>调用了 <code>show()</code> 之后，代码又在同一函数里把窗口立刻 <code>hide()</code> 掉了</strong>（或把父窗口隐藏导致子窗口也被隐藏）。</li>
</ol>
<hr>
<h3 id="🔍-现场排查-2-步"><a href="#🔍-现场排查-2-步" class="headerlink" title="🔍 现场排查 2 步"></a>🔍 现场排查 2 步</h3><h4 id="①-确认打印的实例-你真正-show-的实例"><a href="#①-确认打印的实例-你真正-show-的实例" class="headerlink" title="① 确认打印的实例 &#x3D;&#x3D; 你真正 show() 的实例"></a>① 确认打印的实例 &#x3D;&#x3D; 你真正 <code>show()</code> 的实例</h4><p>在 <code>showChildWindow()</code> 里加一行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;showChildWindow called on&quot;</span> &lt;&lt; _childDialog;</span><br><span class="line">_childDialog-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;after show:&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;visible&quot;</span> &lt;&lt; _childDialog-&gt;<span class="built_in">isVisible</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&quot;geometry&quot;</span> &lt;&lt; _childDialog-&gt;<span class="built_in">geometry</span>();</span><br></pre></td></tr></table></figure>

<p>再对比你调试打印里的 <code>_childDialog</code> 地址，如果地址不一致 → 你打印的是 <strong>另一个实例</strong>。</p>
<h4 id="②-确认没有被立即隐藏"><a href="#②-确认没有被立即隐藏" class="headerlink" title="② 确认没有被立即隐藏"></a>② 确认没有被立即隐藏</h4><p>把 <code>showChildWindow</code> 精简到只有两行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showChildWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;before show&quot;</span>;</span><br><span class="line">    _childDialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;after show&quot;</span> &lt;&lt; _childDialog-&gt;<span class="built_in">isVisible</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <strong>第一次</strong> 打印就得到 <code>visible = false</code>，说明 <code>show()</code> 被别的代码 <strong>立刻撤销</strong>；  </li>
<li>如果 <strong>第二次</strong> 再打印就得到 <code>visible = true</code>，说明你之前只是 <strong>忘记调用 <code>show()</code></strong> 或者 <strong>在别的函数里又 <code>hide()</code> 了</strong>。</li>
</ul>
<hr>
<h3 id="✅-最常见的“隐形”错误示例"><a href="#✅-最常见的“隐形”错误示例" class="headerlink" title="✅ 最常见的“隐形”错误示例"></a>✅ 最常见的“隐形”错误示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：同一函数里先 show 再 hide</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showChildWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _childDialog-&gt;<span class="built_in">show</span>();   <span class="comment">// 立即显示</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();           <span class="comment">// 主窗口 hide</span></span><br><span class="line">    <span class="comment">// 如果 _childDialog 的父对象是 this，Qt 会级联隐藏子窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修复：  </p>
<ul>
<li>让子窗口 <strong>无父对象</strong>（传 <code>nullptr</code>），或  </li>
<li>把 <code>hide()</code> 放在 <strong>信号槽里</strong> 延迟执行，不要放在同一函数里。</li>
</ul>
<hr>
<h3 id="一句话结论"><a href="#一句话结论" class="headerlink" title="一句话结论"></a>一句话结论</h3><p><strong><code>isVisible() == false</code> 就证明 <code>show()</code> 根本没生效</strong>；<br>90% 是因为 <strong>父窗口被隐藏导致子窗口也被隐藏</strong>，或者 <strong>你打印的实例并不是你真正 <code>show()</code> 的实例</strong>。<br>按上面两步打印地址和生命周期即可定位。</p>
<h2 id="模态对话框设置"><a href="#模态对话框设置" class="headerlink" title="模态对话框设置"></a>模态对话框设置</h2><p>Qt 中把对话框“变模态”有 4 种常用写法，可归纳为 <strong>两类 3 级 4 法</strong>，下面按「阻塞范围 × 阻塞方式」给出对照、优势及推荐场景。所有方法在 <strong>Qt5 &#x2F; Qt6</strong> 通用，差异仅默认退出策略（Qt6 需 <code>setQuitOnLastWindowClosed(false)</code>）。</p>
<hr>
<p>一、两类 3 级 4 法总览</p>
<table>
<thead>
<tr>
<th>#</th>
<th>写法</th>
<th>阻塞范围</th>
<th>阻塞方式</th>
<th>何时用</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>exec()</code></td>
<td>Application 级</td>
<td><strong>同步阻塞</strong></td>
<td>必须等待结果</td>
</tr>
<tr>
<td>2</td>
<td><code>open()</code></td>
<td>Window 级</td>
<td><strong>异步非阻塞</strong></td>
<td>Qt5+ 推荐</td>
</tr>
<tr>
<td>3</td>
<td><code>setModal(true)</code> + <code>show()</code></td>
<td>Application 级</td>
<td><strong>异步非阻塞</strong></td>
<td>需要非阻塞</td>
</tr>
<tr>
<td>4</td>
<td><code>setWindowModality(Qt::WindowModal)</code> + <code>show()</code></td>
<td>Window 级</td>
<td><strong>异步非阻塞</strong></td>
<td>与 #2 等价</td>
</tr>
</tbody></table>
<hr>
<p>二、代码示例 &amp; 优势</p>
<ol>
<li><strong>exec()</strong>（最经典）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QDialog <span class="title">dlg</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (dlg.<span class="built_in">exec</span>() == QDialog::Accepted) &#123; <span class="comment">/* 处理 */</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>✅ <strong>同步</strong> —— 代码停在 <code>exec()</code>，直到用户关闭。  </li>
<li>✅ <strong>自动 ApplicationModal</strong> —— 整个程序被阻塞。  </li>
<li>❌ UI 线程被挂起，不能继续响应其他事件。  </li>
<li><strong>推荐</strong>：一次性确认、文件选择、登录框。</li>
</ul>
<ol start="2">
<li><strong>open()</strong>（Qt5+ 官方主推）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> *dlg = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);   <span class="comment">// 需指定父窗口</span></span><br><span class="line"><span class="built_in">connect</span>(dlg, &amp;QDialog::finished, <span class="keyword">this</span>, [<span class="keyword">this</span>](<span class="type">int</span> r)&#123; <span class="comment">/* 处理 */</span> &#125;);</span><br><span class="line">dlg-&gt;<span class="built_in">open</span>();                     <span class="comment">// 等价于 setWindowModality + show</span></span><br></pre></td></tr></table></figure>

<ul>
<li>✅ <strong>异步</strong> —— <code>open()</code> 立即返回，不会卡死 UI。  </li>
<li>✅ <strong>WindowModal</strong> —— 只阻塞父窗口，用户体验更友好。  </li>
<li>✅ <strong>内存友好</strong> —— 可配合 <code>setAttribute(Qt::WA_DeleteOnClose)</code>。  </li>
<li><strong>推荐</strong>：设置面板、属性编辑等需要父窗口冻结的场景。</li>
</ul>
<ol start="3">
<li><strong>setModal(true) + show()</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog dlg;</span><br><span class="line">dlg.<span class="built_in">setModal</span>(<span class="literal">true</span>);   <span class="comment">// 等价于 setWindowModality(Qt::ApplicationModal)</span></span><br><span class="line">dlg.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>✅ 同样异步，但范围是整个应用。  </li>
<li>❌ 仍然需要手动管理生命周期。  </li>
<li><strong>推荐</strong>：需要 ApplicationModal 又不想用 <code>exec()</code> 的场合。</li>
</ul>
<ol start="4">
<li><strong>setWindowModality(Qt::WindowModal) + show()</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QDialog <span class="title">dlg</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">dlg.<span class="built_in">setWindowModality</span>(Qt::WindowModal);</span><br><span class="line">dlg.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>与 #2 功能完全等价，只是写法更原始。  </li>
<li><strong>推荐</strong>：当你不想继承 QDialog，而是用 QWidget 充当对话框时。</li>
</ul>
<hr>
<p>三、如何选择</p>
<table>
<thead>
<tr>
<th>需求</th>
<th>推荐写法</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞整程序并等待返回</td>
<td><code>exec()</code></td>
</tr>
<tr>
<td>只阻塞父窗口且异步</td>
<td><code>open()</code>（Qt5+ 官方）</td>
</tr>
<tr>
<td>需要 ApplicationModal 但异步</td>
<td><code>setModal(true) + show()</code></td>
</tr>
<tr>
<td>用 QWidget 做对话框</td>
<td><code>setWindowModality(Qt::WindowModal) + show()</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>一句话总结</strong>：<br><strong>Qt5&#x2F;Qt6 均优先用 <code>dialog-&gt;open()</code>（Window Modal 异步）</strong>；<br>必须同步阻塞、或要返回值时，才用 <code>exec()</code>。</p>
</blockquote>
<h2 id="弱指针与智能指针"><a href="#弱指针与智能指针" class="headerlink" title="弱指针与智能指针"></a>弱指针与智能指针</h2><p>在您提供的代码中，使用了 <code>std::shared_ptr</code>和 <code>std::weak_ptr</code>来管理对象生命周期，这种做法本身是安全的，不会造成循环引用或内存泄漏。以下是详细分析：</p>
<h3 id="1-代码行为分析"><a href="#1-代码行为分析" class="headerlink" title="1. 代码行为分析"></a>1. <strong>代码行为分析</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoginDialog::initSignals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _registerDialog = std::<span class="built_in">make_shared</span>&lt;RegisterDialog&gt;();  <span class="comment">// 创建 RegisterDialog 的共享指针</span></span><br><span class="line">    _registerDialog-&gt;<span class="built_in">setLogin</span>(<span class="built_in">shared_from_this</span>());         <span class="comment">// 传递当前对象的共享指针（转换为 weak_ptr）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_registerDialog</code>是 <code>LoginDialog</code>的成员变量（类型为 <code>std::shared_ptr&lt;RegisterDialog&gt;</code>），它持有 <code>RegisterDialog</code>的所有权。</li>
<li><code>shared_from_this()</code>返回当前 <code>LoginDialog</code>对象的 <code>std::shared_ptr&lt;LoginDialog&gt;</code>（要求对象必须已被 <code>shared_ptr</code>管理）。</li>
<li><code>setLogin()</code>接收一个 <code>std::weak_ptr&lt;LoginDialog&gt;</code>，赋值给 <code>RegisterDialog</code>的成员 <code>_loginDialog</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RegisterDialog::setLogin</span><span class="params">(<span class="type">const</span> std::weak_ptr&lt;LoginDialog&gt; &amp;loginDialog)</span> </span>&#123;</span><br><span class="line">    _loginDialog = loginDialog;  <span class="comment">// 存储为弱指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_loginDialog</code>是 <code>RegisterDialog</code>的成员变量（类型为 <code>std::weak_ptr&lt;LoginDialog&gt;</code>），它<strong>不持有所有权</strong>，仅观察 <code>LoginDialog</code>对象。</li>
</ul>
<hr>
<h3 id="2-引用计数变化"><a href="#2-引用计数变化" class="headerlink" title="2. 引用计数变化"></a>2. <strong>引用计数变化</strong></h3><ul>
<li><strong><code>std::make_shared&lt;RegisterDialog&gt;()</code></strong><ul>
<li>创建 <code>RegisterDialog</code>对象，引用计数 <strong>+1</strong>（<code>_registerDialog</code>持有）。</li>
</ul>
</li>
<li><strong><code>shared_from_this()</code></strong><ul>
<li>返回 <code>LoginDialog</code>的共享指针，但引用计数<strong>不变</strong>（因为该指针是额外的引用，但对象已被其他 <code>shared_ptr</code>管理）。</li>
</ul>
</li>
<li><strong>转换为 <code>std::weak_ptr</code></strong><ul>
<li>当 <code>shared_ptr</code>赋值给 <code>weak_ptr</code>时：<ul>
<li>引用计数<strong>不变</strong>（<code>weak_ptr</code>不增加强引用计数）。</li>
<li><code>weak_ptr</code>会关联到控制块，但不会阻止对象销毁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-安全性分析"><a href="#3-安全性分析" class="headerlink" title="3. 安全性分析"></a>3. <strong>安全性分析</strong></h3><h4 id="✅-无循环引用"><a href="#✅-无循环引用" class="headerlink" title="✅ 无循环引用"></a>✅ <strong>无循环引用</strong></h4><ul>
<li><p><code>LoginDialog</code>持有 <code>RegisterDialog</code>的 <code>shared_ptr</code>（强引用）。</p>
</li>
<li><p><code>RegisterDialog</code>持有 <code>LoginDialog</code>的 <code>weak_ptr</code>（弱引用，不增加引用计数）。</p>
</li>
<li><p>当外部不再持有 <code>LoginDialog</code>的 <code>shared_ptr</code>时：</p>
<ol>
<li><p><code>LoginDialog</code>对象销毁（引用计数归零）。</p>
</li>
<li><p><code>LoginDialog</code>的成员 <code>_registerDialog</code>（<code>shared_ptr&lt;RegisterDialog&gt;</code>）被销毁 → <code>RegisterDialog</code>的引用计数归零 → <code>RegisterDialog</code>对象销毁。</p>
<p><strong>不会</strong>因循环引用导致内存泄漏。</p>
</li>
</ol>
</li>
</ul>
<h4 id="✅-弱指针的安全访问"><a href="#✅-弱指针的安全访问" class="headerlink" title="✅ 弱指针的安全访问"></a>✅ <strong>弱指针的安全访问</strong></h4><ul>
<li><p>在 <code>RegisterDialog</code>中通过 <code>_loginDialog.lock()</code>获取 <code>shared_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> login = _loginDialog.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">    <span class="comment">// 安全使用 login 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 <code>LoginDialog</code>已销毁，<code>lock()</code>返回空指针，避免悬空指针。</p>
</li>
</ul>
<h4 id="⚠️-注意前提条件"><a href="#⚠️-注意前提条件" class="headerlink" title="⚠️ 注意前提条件"></a>⚠️ <strong>注意前提条件</strong></h4><ul>
<li><p><code>shared_from_this()</code>要求对象必须由 <code>shared_ptr</code>管理。若直接构造 <code>LoginDialog</code>而非通过 <code>shared_ptr</code>，会抛出 <code>std::bad_weak_ptr</code>异常。</p>
<p>正确创建方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> login = std::<span class="built_in">make_shared</span>&lt;LoginDialog&gt;();</span><br><span class="line">login-&gt;<span class="built_in">initSignals</span>();  <span class="comment">// 此时 shared_from_this() 有效</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h3><ul>
<li><strong>引用计数影响</strong>：<ul>
<li><code>weak_ptr</code>的赋值<strong>不增加</strong>强引用计数，不影响对象生命周期。</li>
</ul>
</li>
<li><strong>安全性</strong>：<ul>
<li>无循环引用风险（强引用是单向的）。</li>
<li><code>weak_ptr</code>避免悬空指针，需通过 <code>lock()</code>安全访问。</li>
</ul>
</li>
<li><strong>最佳实践</strong>：<ul>
<li>确保对象由 <code>shared_ptr</code>管理后再调用 <code>shared_from_this()</code>。</li>
<li>在 <code>RegisterDialog</code>中始终使用 <code>lock()</code>检查弱指针有效性。</li>
</ul>
</li>
</ul>
<p>您的代码是安全的，符合智能指针的设计意图。</p>
<h2 id="主窗口，窗口，对话框"><a href="#主窗口，窗口，对话框" class="headerlink" title="主窗口，窗口，对话框"></a>主窗口，窗口，对话框</h2><p>一句话先讲结论：  </p>
<blockquote>
<p><strong>选错基类，你的窗口就“长”得完全不像你想要的——菜单栏、工具栏、状态栏、模态&#x2F;非模态、任务栏图标……都会跟着变。</strong></p>
</blockquote>
<p>下面把三种基类在 Qt 里的定位和差异一次说清，方便你“对号入座”。</p>
<hr>
<h3 id="1-QMainWindow（“程序主窗口”）"><a href="#1-QMainWindow（“程序主窗口”）" class="headerlink" title="1. QMainWindow（“程序主窗口”）"></a>1. QMainWindow（“<strong>程序主窗口</strong>”）</h3><table>
<thead>
<tr>
<th>特征</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>典型的大程序主界面（IDE、浏览器、Office）。</td>
</tr>
<tr>
<td><strong>独占功能</strong></td>
<td>预留了 <strong>MenuBar、ToolBar、DockWidget、StatusBar</strong> 的停靠区域；自带布局管理器 <code>centralWidget()</code>。</td>
</tr>
<tr>
<td><strong>外观</strong></td>
<td>有标题栏、最小化&#x2F;最大化按钮、任务栏图标、可停靠工具栏。</td>
</tr>
<tr>
<td><strong>继承链</strong></td>
<td><code>QMainWindow → QWidget → QObject</code>（没有 <code>QDialog</code> 的模态机制）。</td>
</tr>
<tr>
<td><strong>不能做的事</strong></td>
<td>不能变成模态（exec），也不能当内嵌子控件。</td>
</tr>
</tbody></table>
<p>示例：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow &#123; … &#125;;</span><br><span class="line"><span class="built_in">setCentralWidget</span>(<span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>));   <span class="comment">// 必须设置中心控件</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-QWidget（“最普通的矩形区域”）"><a href="#2-QWidget（“最普通的矩形区域”）" class="headerlink" title="2. QWidget（“最普通的矩形区域”）"></a>2. QWidget（“<strong>最普通的矩形区域</strong>”）</h3><table>
<thead>
<tr>
<th>特征</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>任何轻量级矩形区：子控件、无边框浮动窗口、内嵌面板等。</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>只有最基础的窗口标志（可开关标题栏、边框）。无菜单&#x2F;工具栏概念。</td>
</tr>
<tr>
<td><strong>可塑性</strong></td>
<td>可以 <code>setWindowFlags(Qt::Window)</code> 变成顶层窗口，也可以 <code>new QWidget(parent)</code> 当子控件。</td>
</tr>
<tr>
<td><strong>模态</strong></td>
<td>默认无模态；想模态需手动 <code>setWindowModality()</code> + <code>show()</code>，但效果不如 QDialog 好。</td>
</tr>
</tbody></table>
<p>示例：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Panel</span> : <span class="keyword">public</span> QWidget &#123; … &#125;;</span><br><span class="line"><span class="built_in">setWindowFlags</span>(Qt::Window | Qt::FramelessWindowHint);  <span class="comment">// 变成无边框浮动窗口</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-QDialog（“对话框”）"><a href="#3-QDialog（“对话框”）" class="headerlink" title="3. QDialog（“对话框”）"></a>3. QDialog（“<strong>对话框</strong>”）</h3><table>
<thead>
<tr>
<th>特征</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>模态&#x2F;非模态对话框、设置面板、消息框。</td>
</tr>
<tr>
<td><strong>独占功能</strong></td>
<td>支持 <code>exec()</code>（阻塞式模态返回 <code>int</code> 结果码）、<code>accept()</code>&#x2F;<code>reject()</code> 槽、默认按钮机制。</td>
</tr>
<tr>
<td><strong>外观</strong></td>
<td>有标题栏、可设置 <code>?</code> 帮助按钮、窗口可固定大小；无菜单&#x2F;工具栏区域。</td>
</tr>
<tr>
<td><strong>继承链</strong></td>
<td><code>QDialog → QWidget → QObject</code>（没有 QMainWindow 的停靠区域）。</td>
</tr>
</tbody></table>
<p>示例：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoginDlg</span> : <span class="keyword">public</span> QDialog &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">if</span> (<span class="built_in">check</span>()) QDialog::<span class="built_in">accept</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LoginDlg dlg;</span><br><span class="line"><span class="keyword">if</span> (dlg.<span class="built_in">exec</span>() == QDialog::Accepted) &#123; … &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-一张表总结"><a href="#4-一张表总结" class="headerlink" title="4. 一张表总结"></a>4. 一张表总结</h3><table>
<thead>
<tr>
<th>特性 &#x2F; 基类</th>
<th>QMainWindow</th>
<th>QWidget</th>
<th>QDialog</th>
</tr>
</thead>
<tbody><tr>
<td>菜单&#x2F;工具栏&#x2F;停靠区</td>
<td>✅ 内置</td>
<td>❌ 无</td>
<td>❌ 无</td>
</tr>
<tr>
<td>模态 <code>exec()</code></td>
<td>❌ 不支持</td>
<td>❌ 弱支持</td>
<td>✅ 强支持</td>
</tr>
<tr>
<td>任务栏图标</td>
<td>✅ 默认</td>
<td>✅（设为顶层时）</td>
<td>✅</td>
</tr>
<tr>
<td>典型场景</td>
<td>主程序窗口</td>
<td>子控件、无边框浮动窗</td>
<td>设置、登录、弹框</td>
</tr>
<tr>
<td>必须 centralWidget</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-选哪个？"><a href="#5-选哪个？" class="headerlink" title="5. 选哪个？"></a>5. 选哪个？</h3><ul>
<li><strong>写主程序</strong> → <code>QMainWindow</code>  </li>
<li><strong>写弹框&#x2F;设置窗口</strong> → <code>QDialog</code>  </li>
<li><strong>写内部面板、自定义控件、无边框浮动工具窗</strong> → <code>QWidget</code></li>
</ul>
<p>记住一句话：<strong>“需要菜单栏 dock 就用 QMainWindow，需要对话框就用 QDialog，其余全用 QWidget。”</strong></p>
<h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><p>好的，我们来详细、深入地讲解一下 Qt 的事件机制。理解事件机制是掌握 Qt 编程的核心之一，因为它贯穿于整个应用程序的交互和生命周期管理。</p>
<h3 id="一、核心思想：事件驱动编程"><a href="#一、核心思想：事件驱动编程" class="headerlink" title="一、核心思想：事件驱动编程"></a>一、核心思想：事件驱动编程</h3><p>Qt 是一个<strong>事件驱动</strong>的框架。这意味着：</p>
<ul>
<li>程序的执行流不是由预先定义的顺序决定的，而是由<strong>事件</strong>的发生来触发的。</li>
<li><strong>事件</strong>是对应用程序内部或外部发生的各种事情的描述。例如：用户点击鼠标、按下键盘、定时器超时、网络数据到达、窗口需要重绘等。</li>
<li>应用程序大部分时间都处于<strong>事件循环</strong>中，等待事件的发生，然后分发事件，调用相应的事件处理函数，处理完毕后继续等待下一个事件。</li>
</ul>
<hr>
<h3 id="二、核心组件与流程"><a href="#二、核心组件与流程" class="headerlink" title="二、核心组件与流程"></a>二、核心组件与流程</h3><p>Qt 事件机制主要由以下几个核心部分组成：</p>
<h4 id="1-事件-QEvent"><a href="#1-事件-QEvent" class="headerlink" title="1. 事件 (QEvent)"></a>1. 事件 (<code>QEvent</code>)</h4><ul>
<li><strong>是什么</strong>：所有事件的基类。它是一个轻量级的对象，包含了一个枚举类型的 <code>type()</code> 来标识事件类型（如 <code>QEvent::MouseButtonPress</code>, <code>QEvent::KeyPress</code>, <code>QEvent::Paint</code>等），以及一些额外的参数。</li>
<li><strong>来源</strong>：<ul>
<li><strong>自发事件</strong>：通常来自窗口系统（如 X11, Windows, macOS），由 <code>QApplication::notify()</code> 接收并转化为 Qt 事件。</li>
<li><strong>粘贴事件</strong>：由 Qt 应用程序自身产生并排队，例如 <code>QTimerEvent</code>, <code>QFutureWatcher</code> 完成时产生的事件，或者通过 <code>QCoreApplication::postEvent()</code> 发送的自定义事件。</li>
</ul>
</li>
</ul>
<h4 id="2-事件循环-QEventLoop"><a href="#2-事件循环-QEventLoop" class="headerlink" title="2. 事件循环 (QEventLoop)"></a>2. 事件循环 (<code>QEventLoop</code>)</h4><ul>
<li><strong>是什么</strong>：每个 Qt 应用程序的核心，可以看作是 <code>main()</code> 函数中的 <code>return app.exec();</code>。这行代码就启动了应用程序的主事件循环。</li>
<li><strong>做什么</strong>：事件循环不断地检查事件队列中是否有新事件。如果有，它就取出一个事件，将其转化为 <code>QEvent</code>，然后通过 <code>QCoreApplication::notify()</code> 将其发送给目标对象 (<code>QObject</code>)。</li>
<li><strong>层次结构</strong>：除了主事件循环，还可以创建局部事件循环（例如，显示一个模态对话框时，会启动一个局部事件循环来阻塞当前调用，但又不影响主循环）。</li>
</ul>
<p><strong>简化的循环伪代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (is_running) &#123;</span><br><span class="line">    <span class="comment">// 1. 检查事件队列，如果没有事件，则进入休眠状态以节省CPU</span></span><br><span class="line">    <span class="keyword">if</span> (!event_queue.<span class="built_in">hasEvent</span>()) &#123;</span><br><span class="line">        <span class="built_in">wait_for_more_events</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从队列中获取一个事件</span></span><br><span class="line">    Event event = event_queue.<span class="built_in">nextEvent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 分发事件：找到事件的接收者，并调用其event()方法</span></span><br><span class="line">    <span class="built_in">dispatch_event</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-事件接收与处理-QObject-event"><a href="#3-事件接收与处理-QObject-event" class="headerlink" title="3. 事件接收与处理 (QObject::event())"></a>3. 事件接收与处理 (<code>QObject::event()</code>)</h4><p>事件最终会被发送到特定的 <code>QObject</code>（或其子类，如 <code>QWidget</code>）。事件处理的入口是 <code>QObject::event(QEvent *e)</code> 虚函数。</p>
<p><strong>标准的事件处理流程如下：</strong></p>
<ol>
<li><p><strong><code>bool QObject::event(QEvent *e)</code></strong>：</p>
<ul>
<li>这是事件处理的总入口。它查看 <code>QEvent</code> 的类型 <code>e-&gt;type()</code>。</li>
<li>对于常见的事件类型（如键盘、鼠标），它会调用一个更方便的<strong>事件处理器</strong>。</li>
</ul>
</li>
<li><p><strong>特定事件处理器</strong>：</p>
<ul>
<li>这些是 <code>QObject</code> 或 <code>QWidget</code> 中定义的虚函数，专门处理特定类型的事件。</li>
<li><code>event()</code> 方法会根据事件类型调用相应的处理器。例如：<ul>
<li><code>e-&gt;type() == QEvent::KeyPress</code> -&gt; 调用 <code>keyPressEvent(QKeyEvent *e)</code></li>
<li><code>e-&gt;type() == QEvent::MouseButtonPress</code> -&gt; 调用 <code>mousePressEvent(QMouseEvent *e)</code></li>
<li><code>e-&gt;type() == QEvent::Paint</code> -&gt; 调用 <code>paintEvent(QPaintEvent *e)</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>默认实现</strong>：</p>
<ul>
<li>基类（如 <code>QWidget</code>）的事件处理器通常有一个默认的实现。例如，<code>QWidget::keyPressEvent()</code> 默认什么也不做。</li>
<li><strong>如果你想要处理某个事件，你应该在你的子类中重写对应的事件处理器，而不是 <code>event()</code> 函数</strong>。这是最常见的方式。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、事件传递的路径：深入-notify-和-event"><a href="#三、事件传递的路径：深入-notify-和-event" class="headerlink" title="三、事件传递的路径：深入 notify() 和 event()"></a>三、事件传递的路径：深入 <code>notify()</code> 和 <code>event()</code></h3><p>事件的完整旅程更加精细：</p>
<ol>
<li><p><code>QApplication::notify(receiver, event)</code>： 这是Qt事件链的<strong>最顶层</strong>。它负责将事件发送给特定的接收者对象。在某些非常特殊的情况下（例如需要全局监控所有事件），你可以子类化 <code>QApplication</code> 并重写这个函数，但这通常不推荐。</p>
</li>
<li><p><strong>事件过滤器</strong>：在 <code>notify()</code> 分发事件之前，会先检查接收者对象及其父对象是否安装了<strong>事件过滤器</strong>。这是事件机制中一个非常强大和有用的特性。</p>
<ul>
<li>一个对象可以监听另一个对象的事件。</li>
<li>如果事件过滤器返回 <code>true</code>，表示事件已被处理，不会再继续传递（即不会调用目标的 <code>event()</code> 函数）。</li>
<li>如果返回 <code>false</code>，事件会继续传递到目标对象的 <code>event()</code> 函数。</li>
</ul>
</li>
<li><p><code>QObject::event(QEvent *e)</code>： 如上所述，事件到达接收对象。</p>
</li>
<li><p><strong>特定事件处理器</strong>：<code>event()</code> 函数调用对应的特定事件处理器（如 <code>keyPressEvent</code>）。</p>
</li>
<li><p><strong>信号与槽</strong>：值得注意的是，有些事件处理器会<strong>发射信号</strong>。例如，<code>QAbstractButton</code> 的 <code>mousePressEvent()</code> 会处理鼠标点击，然后发射 <code>clicked()</code> 信号。这是事件机制与信号槽机制连接的地方。</p>
</li>
</ol>
<p><strong>事件传递路径总结：</strong><br><code>自发事件</code> -&gt; <code>QApplication::notify()</code> -&gt; <code>(事件过滤器)</code> -&gt; <code>接收者QObject::event()</code> -&gt; <code>接收者特定事件处理器(如keyPressEvent)</code> -&gt; <code>可能触发信号</code> -&gt; <code>连接到信号的槽函数</code></p>
<hr>
<h3 id="四、事件的类型与处理方式"><a href="#四、事件的类型与处理方式" class="headerlink" title="四、事件的类型与处理方式"></a>四、事件的类型与处理方式</h3><h4 id="1-同步-vs-异步事件"><a href="#1-同步-vs-异步事件" class="headerlink" title="1. 同步 vs. 异步事件"></a>1. 同步 vs. 异步事件</h4><ul>
<li><strong>同步事件</strong>：通过 <code>sendEvent()</code> 发送。事件会<strong>立即</strong>被处理，函数会阻塞直到事件处理完成。<code>sendEvent()</code> 是线程安全的。</li>
<li><strong>异步事件</strong>：通过 <code>postEvent()</code> 发送。事件被添加到接收者对象所在线程的事件队列中，等待事件循环稍后处理。函数调用立即返回。<code>postEvent()</code> 是线程安全的，常用于跨线程通信。</li>
</ul>
<h4 id="2-事件传播：Accept-和-Ignore"><a href="#2-事件传播：Accept-和-Ignore" class="headerlink" title="2. 事件传播：Accept 和 Ignore"></a>2. 事件传播：Accept 和 Ignore</h4><p>每个 <code>QEvent</code> 都有一个 <code>accept()</code> 和 <code>ignore()</code> 方法，以及一个 <code>isAccepted()</code> 标志。</p>
<ul>
<li>这个标志决定了事件在<strong>层次结构</strong>中是否继续传播。</li>
<li>默认情况下，事件是被接受的（<code>accept()</code>），意味着“这个事件我处理了，不用再给别人了”。</li>
<li>例如，在一个对话框中，你点击了一个按钮。按钮的 <code>mousePressEvent</code> 接受了该事件，处理了点击。事件就不会再传播给按钮的父组件（对话框）。如果你在按钮的事件处理器中调用 <code>ignore()</code>，那么事件会继续向上传递给它的父组件。</li>
</ul>
<p><strong>注意</strong>：这个机制主要用于一些特定的事件类型，如窗口关闭事件 (<code>QCloseEvent</code>)。</p>
<hr>
<h3 id="五、如何与事件机制交互"><a href="#五、如何与事件机制交互" class="headerlink" title="五、如何与事件机制交互"></a>五、如何与事件机制交互</h3><ol>
<li><p><strong>重写事件处理器</strong>：最常用、最推荐的方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWidget</span> : <span class="keyword">public</span> QWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *e)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;<span class="built_in">key</span>() == Qt::Key_Space) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Space pressed!&quot;</span>;</span><br><span class="line">            <span class="comment">// 处理了，事件到此为止</span></span><br><span class="line">            e-&gt;<span class="built_in">accept</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 让基类处理其他按键</span></span><br><span class="line">            QWidget::<span class="built_in">keyPressEvent</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *e)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        painter.<span class="built_in">drawText</span>(<span class="built_in">rect</span>(), <span class="string">&quot;Hello, Event!&quot;</span>);</span><br><span class="line">        <span class="comment">// paintEvent 必须总是被处理，通常不需要调用基类，但取决于需求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装事件过滤器</strong>：监听其他对象的事件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FilterObject</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">            QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Filtered key press:&quot;</span> &lt;&lt; keyEvent-&gt;<span class="built_in">key</span>();</span><br><span class="line">            <span class="comment">// return true; // 吃掉这个事件</span></span><br><span class="line">            <span class="comment">// return false; // 继续传递</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QObject::<span class="built_in">eventFilter</span>(watched, event); <span class="comment">// 让基类处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用的地方</span></span><br><span class="line">MyWidget widget;</span><br><span class="line">FilterObject filter;</span><br><span class="line">widget.<span class="built_in">installEventFilter</span>(&amp;filter); <span class="comment">// 让filter监听widget的事件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发送自定义事件</strong>：你可以子类化 <code>QEvent</code>，创建自己的事件类型，并使用 <code>postEvent()</code> 或 <code>sendEvent()</code> 来发送它们。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义自定义事件类型（必须大于 QEvent::User）</span></span><br><span class="line"><span class="type">const</span> QEvent::Type MyCustomEventType = <span class="built_in">static_cast</span>&lt;QEvent::Type&gt;(QEvent::User + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 子类化QEvent（可选，用于携带数据）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomEvent</span> : <span class="keyword">public</span> QEvent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CustomEvent</span>(<span class="type">const</span> QString &amp;data) : <span class="built_in">QEvent</span>(MyCustomEventType), <span class="built_in">m_data</span>(data) &#123;&#125;</span><br><span class="line">    <span class="function">QString <span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在接收者中重写 event() 函数来处理自定义事件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyWidget::event</span><span class="params">(QEvent *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == MyCustomEventType) &#123;</span><br><span class="line">        CustomEvent *ce = <span class="built_in">static_cast</span>&lt;CustomEvent *&gt;(e);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Custom event received:&quot;</span> &lt;&lt; ce-&gt;<span class="built_in">data</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 已处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(e); <span class="comment">// 让基类处理其他事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 在某个地方发送事件</span></span><br><span class="line">QCoreApplication::<span class="built_in">postEvent</span>(&amp;receiver_object, <span class="keyword">new</span> <span class="built_in">CustomEvent</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="六、事件机制与信号槽机制的关系"><a href="#六、事件机制与信号槽机制的关系" class="headerlink" title="六、事件机制与信号槽机制的关系"></a>六、事件机制与信号槽机制的关系</h3><p>这是一个常见的困惑点。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">事件机制</th>
<th align="left">信号槽机制</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>通信范围</strong></td>
<td align="left"><strong>纵向</strong>的，从父组件到子组件，或者通过事件过滤器。</td>
<td align="left"><strong>任意</strong>的，可以在任何QObject之间连接，关系是平行的。</td>
</tr>
<tr>
<td align="left"><strong>紧耦合度</strong></td>
<td align="left"><strong>紧耦合</strong>。发送者必须知道接收者是谁（<code>QObject*</code>）。</td>
<td align="left"><strong>松耦合</strong>。发送者不知道接收者是谁，只需要知道信号的签名。</td>
</tr>
<tr>
<td align="left"><strong>用途</strong></td>
<td align="left"><strong>底层交互</strong>：处理来自操作系统的原始事件（输入、绘制等）、对象内部状态管理、中断处理。</td>
<td align="left"><strong>高层逻辑</strong>：响应UI操作、在对象之间传递业务逻辑状态变化。</td>
</tr>
<tr>
<td align="left"><strong>效率</strong></td>
<td align="left">通常<strong>更高</strong>，因为是直接的函数调用。</td>
<td align="left">略有开销（查找连接、参数拷贝），但通常可以忽略不计。</td>
</tr>
</tbody></table>
<p><strong>联系</strong>：信号槽机制构建在事件机制之上。一个事件（如鼠标点击）最终可能触发一个信号（如 <code>clicked()</code>）。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Qt 的事件机制是一个强大且灵活的体系，其核心是 <strong>“事件循环 -&gt; 事件分发 -&gt; 事件处理”</strong> 模型。作为开发者，你最常做的是：</p>
<ol>
<li><strong>重写特定事件处理器</strong>（如 <code>paintEvent</code>, <code>keyPressEvent</code>) 来处理交互和绘制。</li>
<li>使用<strong>事件过滤器</strong>来监听或拦截其他对象的事件。</li>
<li>在需要时使用 <code>postEvent()</code> 进行<strong>线程间通信</strong>或发送自定义事件。</li>
</ol>
<p>理解这个机制，你就能更深入地掌控 Qt 应用程序的行为，编写出响应灵敏、效率高的程序。</p>
<h2 id="Qt中connect函数的用法详解"><a href="#Qt中connect函数的用法详解" class="headerlink" title="Qt中connect函数的用法详解"></a>Qt中connect函数的用法详解</h2><p>在Qt框架中，<code>connect</code>函数是实现信号与槽机制的核心，用于在对象之间建立通信连接。下面我将详细讲解其用法。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *signal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *receiver, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *method, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::ConnectionType type = Qt::AutoConnection</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol>
<li><strong>sender</strong>: 发出信号的对象指针</li>
<li><strong>signal</strong>: 信号的签名，使用SIGNAL()宏</li>
<li><strong>receiver</strong>: 接收信号的对象指针</li>
<li><strong>method</strong>: 槽函数的签名，使用SLOT()宏</li>
<li><strong>type</strong>: 连接类型，决定信号如何传递到槽</li>
</ol>
<h3 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h3><ul>
<li><code>Qt::AutoConnection</code> (默认): 自动选择直接或队列连接</li>
<li><code>Qt::DirectConnection</code>: 信号发出时立即调用槽</li>
<li><code>Qt::QueuedConnection</code>: 槽在接收者线程的事件循环中调用</li>
<li><code>Qt::BlockingQueuedConnection</code>: 类似队列连接，但发送者会阻塞直到槽执行完成</li>
<li><code>Qt::UniqueConnection</code>: 防止重复连接同一信号和槽</li>
</ul>
<h3 id="Qt4与Qt5语法对比"><a href="#Qt4与Qt5语法对比" class="headerlink" title="Qt4与Qt5语法对比"></a>Qt4与Qt5语法对比</h3><h3 id="Qt4传统语法"><a href="#Qt4传统语法" class="headerlink" title="Qt4传统语法"></a>Qt4传统语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统语法(不推荐在新项目中使用)</span></span><br><span class="line"><span class="built_in">connect</span>(button, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleButton</span>()));</span><br></pre></td></tr></table></figure>

<h3 id="Qt5新语法-推荐"><a href="#Qt5新语法-推荐" class="headerlink" title="Qt5新语法(推荐)"></a>Qt5新语法(推荐)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新语法 - 编译时检查</span></span><br><span class="line"><span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MyClass::handleButton);</span><br></pre></td></tr></table></figure>

<h3 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h3><h3 id="示例1-基本信号槽连接"><a href="#示例1-基本信号槽连接" class="headerlink" title="示例1: 基本信号槽连接"></a>示例1: 基本信号槽连接</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接按钮点击信号到槽函数</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::onButtonClicked);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::onButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Button clicked!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例2-使用Lambda表达式"><a href="#示例2-使用Lambda表达式" class="headerlink" title="示例2: 使用Lambda表达式"></a>示例2: 使用Lambda表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda表达式作为槽</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Button clicked from lambda!&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="示例3-带参数的信号槽"><a href="#示例3-带参数的信号槽" class="headerlink" title="示例3: 带参数的信号槽"></a>示例3: 带参数的信号槽</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号和槽都有参数</span></span><br><span class="line"><span class="built_in">connect</span>(slider, &amp;QSlider::valueChanged, spinBox, &amp;QSpinBox::setValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用Lambda处理参数</span></span><br><span class="line"><span class="built_in">connect</span>(slider, &amp;QSlider::valueChanged, [<span class="keyword">this</span>](<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Slider value:&quot;</span> &lt;&lt; value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="示例4-连接不同线程的对象"><a href="#示例4-连接不同线程的对象" class="headerlink" title="示例4: 连接不同线程的对象"></a>示例4: 连接不同线程的对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跨线程连接，使用队列连接方式</span></span><br><span class="line"><span class="built_in">connect</span>(worker, &amp;Worker::resultReady, <span class="keyword">this</span>, &amp;MainWindow::handleResult, Qt::QueuedConnection);</span><br></pre></td></tr></table></figure>

<h3 id="示例5-自动断开连接"><a href="#示例5-自动断开连接" class="headerlink" title="示例5: 自动断开连接"></a>示例5: 自动断开连接</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用QMetaObject::Connection管理连接</span></span><br><span class="line">QMetaObject::Connection connection = <span class="built_in">connect</span>(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要时断开连接</span></span><br><span class="line"><span class="built_in">disconnect</span>(connection);</span><br></pre></td></tr></table></figure>

<h3 id="新式语法优势"><a href="#新式语法优势" class="headerlink" title="新式语法优势"></a>新式语法优势</h3><ol>
<li><strong>编译时检查</strong>: 新语法在编译时检查信号和槽的存在性和兼容性</li>
<li><strong>类型安全</strong>: 提供更好的类型安全性</li>
<li><strong>支持重载</strong>: 可以明确指定使用哪个重载版本</li>
<li><strong>性能更好</strong>: 不需要运行时字符串查找</li>
</ol>
<h3 id="处理重载信号"><a href="#处理重载信号" class="headerlink" title="处理重载信号"></a>处理重载信号</h3><p>当信号有重载时，需要使用函数指针明确指定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 明确指定使用哪个重载版本</span></span><br><span class="line"><span class="built_in">connect</span>(button, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span>(QPushButton::*)(<span class="type">bool</span>)&gt;(&amp;QPushButton::clicked),</span><br><span class="line">        <span class="keyword">this</span>, &amp;MainWindow::handleButtonClicked);</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>确保发送者和接收者都是QObject的派生类</li>
<li>在接收者被删除前断开连接，或使用Qt::UniqueConnection</li>
<li>跨线程连接时注意线程安全性</li>
<li>使用新式语法时，槽函数不需要在类声明中使用slots关键字</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Qt的connect函数提供了灵活的对象间通信机制。推荐使用Qt5的新式语法，因为它提供了更好的类型安全性和编译时检查。根据不同的应用场景选择合适的连接类型，特别是在多线程编程中要注意线程安全性。</p>
<h2 id="QT-MVC框架"><a href="#QT-MVC框架" class="headerlink" title="QT MVC框架"></a>QT MVC框架</h2><p>Qt 中的 MVC（Model-View-Controller）框架更准确地被称为<strong>模型&#x2F;视图架构（Model&#x2F;View Architecture）</strong> 🎨。它将数据和其呈现方式分离，使得开发更加灵活和高效。这个架构主要包含三个核心组件：</p>
<ul>
<li><strong>模型 (Model)</strong>：负责管理数据。</li>
<li><strong>视图 (View)</strong>：负责显示数据。</li>
<li><strong>代理 (Delegate)</strong>：在 Qt 的模型&#x2F;视图架构中，传统的“控制器”功能很大程度上由<strong>代理 (Delegate)</strong> 和视图共同处理。代理主要负责渲染和编辑数据项。</li>
</ul>
<p>为了帮你快速把握 Qt MVC 的核心组成、职责和交互方式，我用一个表格来总结：</p>
<table>
<thead>
<tr>
<th align="left">组件 (Component)</th>
<th align="left">职责 (Responsibility)</th>
<th align="left">常用类 (Common Classes)</th>
<th align="left">交互方式 (Interaction)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>模型 (Model)</strong></td>
<td align="left">管理数据源、提供数据访问接口、通知视图数据变更</td>
<td align="left"><code>QAbstractItemModel</code>, <code>QStandardItemModel</code>, <code>QStringListModel</code></td>
<td align="left">通过信号(<code>dataChanged</code>)通知视图和代理</td>
</tr>
<tr>
<td align="left"><strong>视图 (View)</strong></td>
<td align="left">可视化展示模型数据、处理用户输入（选择、滚动等）</td>
<td align="left"><code>QListView</code>, <code>QTableView</code>, <code>QTreeView</code></td>
<td align="left">从模型获取数据；通过代理渲染和编辑；接收用户输入</td>
</tr>
<tr>
<td align="left"><strong>代理 (Delegate)</strong></td>
<td align="left">控制数据项的渲染方式和编辑器（创建和管理编辑器部件）</td>
<td align="left"><code>QAbstractItemDelegate</code>, <code>QStyledItemDelegate</code></td>
<td align="left">受视图委托进行绘制和编辑；直接与模型通信提交数据</td>
</tr>
</tbody></table>
<p>下面是使用 <code>QTableView</code> 和 <code>QStandardItemModel</code> 的一个简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数据模型 (Model) - 负责管理数据</span></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">4</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 4行3列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置水平表头标签</span></span><br><span class="line">    model.<span class="built_in">setHorizontalHeaderLabels</span>(&#123;<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;Department&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Zhang San&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;28&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;R&amp;D&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Li Si&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;32&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Marketing&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Wang Wu&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;24&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Intern&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">3</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Zhao Liu&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;45&quot;</span>));</span><br><span class="line">    model.<span class="built_in">setItem</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;Management&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建表格视图 (View) - 负责显示数据</span></span><br><span class="line">    QTableView tableView;</span><br><span class="line">    <span class="comment">// 为视图设置模型</span></span><br><span class="line">    tableView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line">    <span class="comment">// 设置一些视图属性以增强显示效果</span></span><br><span class="line">    tableView.<span class="built_in">resize</span>(<span class="number">500</span>, <span class="number">200</span>);</span><br><span class="line">    tableView.<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows); <span class="comment">// 整行选择</span></span><br><span class="line">    tableView.<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(QHeaderView::Stretch); <span class="comment">// 拉伸列宽</span></span><br><span class="line">    tableView.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🛠️ <strong>代码解释</strong>：</p>
<ul>
<li><strong>模型 (<code>QStandardItemModel</code>)</strong>：我们创建了一个 4 行 3 列的模型，并填充了数据和表头。<code>QStandardItemModel</code> 是一个通用的模型类，适用于简单的表格、列表和树形结构数据。</li>
<li><strong>视图 (<code>QTableView</code>)</strong>：我们将创建好的模型设置到视图中 (<code>tableView.setModel(&amp;model)</code>)。视图会自动从模型获取数据并显示出来。我们通过视图的一些方法设置了选择行为和列宽模式，这些只影响显示效果，不改变底层数据。</li>
<li><strong>隐式的代理</strong>：在这个例子中，我们没有显式地创建代理，<code>QTableView</code> 会使用默认的 <code>QStyledItemDelegate</code> 来处理每个单元格的绘制和编辑（你可以尝试在运行后双击单元格进行编辑）。</li>
</ul>
<h3 id="🔧-自定义代理-Custom-Delegate"><a href="#🔧-自定义代理-Custom-Delegate" class="headerlink" title="🔧 自定义代理 (Custom Delegate)"></a>🔧 自定义代理 (Custom Delegate)</h3><p>虽然 Qt 提供了默认的代理，但当你有特殊的数据显示或编辑需求时（比如在单元格中显示进度条、颜色选择器、自定义按钮等），就需要自定义代理。</p>
<p>下面是一个简单的自定义代理例子，它改变特定单元格的背景色：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HighlightDelegate</span> : <span class="keyword">public</span> QStyledItemDelegate</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HighlightDelegate</span>(QObject *parent = <span class="literal">nullptr</span>) : <span class="built_in">QStyledItemDelegate</span>(parent) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 paint 方法来自定义绘制</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionViewItem &amp;option, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果年龄大于30，高亮显示该行</span></span><br><span class="line">        <span class="keyword">if</span> (index.<span class="built_in">column</span>() == <span class="number">1</span>) &#123; <span class="comment">// 假设第二列是年龄</span></span><br><span class="line">            <span class="type">bool</span> ok;</span><br><span class="line">            <span class="type">int</span> age = index.<span class="built_in">data</span>(Qt::DisplayRole).<span class="built_in">toInt</span>(&amp;ok);</span><br><span class="line">            <span class="keyword">if</span> (ok &amp;&amp; age &gt; <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建一个高亮的背景画刷</span></span><br><span class="line">                painter-&gt;<span class="built_in">fillRect</span>(option.rect, <span class="built_in">QBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">200</span>, <span class="number">200</span>))); <span class="comment">// 浅红色背景</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用基类的 paint 方法完成默认的文本绘制等操作</span></span><br><span class="line">        QStyledItemDelegate::<span class="built_in">paint</span>(painter, option, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">4</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    model.<span class="built_in">setHorizontalHeaderLabels</span>(&#123;<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;Department&quot;</span>&#125;);</span><br><span class="line">    <span class="comment">// ... (填充数据同上一个例子，Li Si 32岁, Zhao Liu 45岁)</span></span><br><span class="line"></span><br><span class="line">    QTableView tableView;</span><br><span class="line">    tableView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建自定义代理并设置给视图</span></span><br><span class="line">    HighlightDelegate *delegate = <span class="keyword">new</span> <span class="built_in">HighlightDelegate</span>(&amp;tableView);</span><br><span class="line">    tableView.<span class="built_in">setItemDelegate</span>(delegate); <span class="comment">// 为整个视图设置代理</span></span><br><span class="line">    <span class="comment">// 也可以使用 setItemDelegateForRow, setItemDelegateForColumn 为特定行/列设置代理</span></span><br><span class="line"></span><br><span class="line">    tableView.<span class="built_in">resize</span>(<span class="number">500</span>, <span class="number">200</span>);</span><br><span class="line">    tableView.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🛠️ <strong>代码解释</strong>：</p>
<ul>
<li>我们创建了一个 <code>HighlightDelegate</code> 类，继承自 <code>QStyledItemDelegate</code>。</li>
<li>重写了 <code>paint</code> 方法。在这个方法里，我们判断如果当前单元格是第二列（年龄列）且年龄大于 30，就在绘制单元格背景时使用一个浅红色的画刷。</li>
<li>最后，我们还是调用基类的 <code>paint</code> 方法，让它来处理文本等标准内容的绘制。</li>
<li>在 <code>main</code> 函数中，我们创建了这个自定义代理的实例，并通过 <code>setItemDelegate</code> 方法将其设置给表格视图。</li>
</ul>
<h3 id="🔄-多个视图共享一个模型"><a href="#🔄-多个视图共享一个模型" class="headerlink" title="🔄 多个视图共享一个模型"></a>🔄 多个视图共享一个模型</h3><p>Qt MVC 的一个强大功能是<strong>多个视图可以共享同一个模型</strong>，保持数据的同步显示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数据和模型 (同上)</span></span><br><span class="line">    <span class="function">QStandardItemModel <span class="title">model</span><span class="params">(<span class="number">4</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    model.<span class="built_in">setHorizontalHeaderLabels</span>(&#123;<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;Department&quot;</span>&#125;);</span><br><span class="line">    <span class="comment">// ... (填充数据)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建三个不同的视图</span></span><br><span class="line">    QTableView tableView;</span><br><span class="line">    QListView listView;</span><br><span class="line">    QTreeView treeView;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为所有视图设置相同的模型</span></span><br><span class="line">    tableView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line">    listView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line">    treeView.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个分割窗口并添加三个视图</span></span><br><span class="line">    QSplitter *splitter = <span class="keyword">new</span> QSplitter;</span><br><span class="line">    splitter-&gt;<span class="built_in">addWidget</span>(&amp;tableView);</span><br><span class="line">    splitter-&gt;<span class="built_in">addWidget</span>(&amp;listView);</span><br><span class="line">    splitter-&gt;<span class="built_in">addWidget</span>(&amp;treeView);</span><br><span class="line">    splitter-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Multiple Views Sharing One Model&quot;</span>);</span><br><span class="line">    splitter-&gt;<span class="built_in">resize</span>(<span class="number">1000</span>, <span class="number">400</span>);</span><br><span class="line">    splitter-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置列表视图和树视图的根索引（如果需要的话）</span></span><br><span class="line">    <span class="comment">// listView.setRootIndex(model.index(0,0));</span></span><br><span class="line">    <span class="comment">// treeView.setRootIndex(model.index(0,0));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🛠️ <strong>代码解释</strong>：</p>
<ul>
<li>我们创建了三个不同类型的视图：<code>QTableView</code>, <code>QListView</code>, <code>QTreeView</code>。</li>
<li>它们都通过 <code>setModel()</code> 方法设置了<strong>同一个模型</strong> (<code>&amp;model</code>)。</li>
<li>当你通过任何一个视图修改数据时（例如在表格视图中编辑一个单元格），模型会发出数据变化的信号，其他两个视图会自动接收并更新显示，保持同步。</li>
<li>这个特性非常适合需要从不同角度观察和操作同一份数据的应用场景。</li>
</ul>
<h3 id="📝-总结与建议"><a href="#📝-总结与建议" class="headerlink" title="📝 总结与建议"></a>📝 总结与建议</h3><ul>
<li><strong>核心优势</strong>：Qt 的模型&#x2F;视图架构实现了<strong>数据与显示的分离</strong>，模型负责数据管理，视图负责展示，代理负责个性化的显示和编辑。这使得代码更清晰、更易维护和扩展，并且可以轻松实现多个视图同步。</li>
<li><strong>模型选择</strong>：对于简单数据，可以使用 <code>QStandardItemModel</code>。对于大型或特殊结构的数据源（如数据库、自定义数据结构），最好继承 <code>QAbstractItemModel</code> 或其子类（如 <code>QAbstractTableModel</code>）来自定义模型，以更好地控制数据访问和优化性能。</li>
<li><strong>代理运用</strong>：利用代理 (<code>Delegate</code>) 可以高度定制化数据的显示和编辑方式，这是增强视图表现力的关键。</li>
<li><strong>实践建议</strong>：在开发过程中，明确各组件职责。模型应专注于数据读写和业务逻辑，视图专注于用户交互和呈现，代理专注于特定数据项的视觉效果和编辑行为。</li>
</ul>
<p>希望这些解释和代码示例能帮助你更好地理解和运用 Qt 中的 MVC（模型&#x2F;视图）框架。</p>
<h2 id="Qt-QVariant-详解：万能的数据容器"><a href="#Qt-QVariant-详解：万能的数据容器" class="headerlink" title="Qt QVariant 详解：万能的数据容器"></a>Qt QVariant 详解：万能的数据容器</h2><p>在 Qt 框架中，<code>QVariant</code> 是一个非常重要且强大的类，它作为<strong>通用数据类型容器</strong>，可以存储和管理多种不同类型的数据。简单来说，<code>QVariant</code> 就像是一个”万能变量”，可以在运行时动态地保存、传递和转换各种类型的数据。</p>
<h3 id="📦-QVariant-的核心概念"><a href="#📦-QVariant-的核心概念" class="headerlink" title="📦 QVariant 的核心概念"></a>📦 QVariant 的核心概念</h3><h4 id="什么是-QVariant？"><a href="#什么是-QVariant？" class="headerlink" title="什么是 QVariant？"></a>什么是 QVariant？</h4><p><code>QVariant</code> 是 Qt 提供的一个<strong>类型擦除容器</strong>，它能够：</p>
<ul>
<li>存储 Qt 内置的大多数数据类型和自定义类型</li>
<li>在运行时动态地确定和转换存储的数据类型</li>
<li>提供类型安全的访问机制</li>
<li>作为通用的数据传递媒介</li>
</ul>
<h4 id="为什么需要-QVariant？"><a href="#为什么需要-QVariant？" class="headerlink" title="为什么需要 QVariant？"></a>为什么需要 QVariant？</h4><p>在 Qt 框架中，许多地方需要处理不确定类型的数据，例如：</p>
<ul>
<li>模型&#x2F;视图架构中的数据项</li>
<li>属性系统</li>
<li>信号槽参数传递</li>
<li>设置和配置存储</li>
</ul>
<h3 id="🧰-QVariant-的基本特性"><a href="#🧰-QVariant-的基本特性" class="headerlink" title="🧰 QVariant 的基本特性"></a>🧰 QVariant 的基本特性</h3><h4 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h4><p><code>QVariant</code> 支持几乎所有常见的 Qt 和 C++ 数据类型，包括：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>数据类型示例</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td><code>int</code>, <code>bool</code>, <code>double</code>, <code>float</code>, <code>QString</code></td>
</tr>
<tr>
<td>Qt 核心类型</td>
<td><code>QColor</code>, <code>QFont</code>, <code>QSize</code>, <code>QRect</code>, <code>QDateTime</code></td>
</tr>
<tr>
<td>容器类型</td>
<td><code>QList</code>, <code>QMap</code>, <code>QStringList</code></td>
</tr>
<tr>
<td>自定义类型</td>
<td>使用 <code>Q_DECLARE_METATYPE</code> 注册的类型</td>
</tr>
</tbody></table>
<h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><ol>
<li><strong>类型擦除</strong>：隐藏具体类型信息，提供统一接口</li>
<li><strong>类型安全</strong>：提供安全的类型转换和检查机制</li>
<li><strong>空值支持</strong>：可以表示空值或无效值</li>
<li><strong>复制语义</strong>：深拷贝存储的数据</li>
</ol>
<h3 id="💻-基本用法和代码示例"><a href="#💻-基本用法和代码示例" class="headerlink" title="💻 基本用法和代码示例"></a>💻 基本用法和代码示例</h3><h4 id="创建和赋值"><a href="#创建和赋值" class="headerlink" title="创建和赋值"></a>创建和赋值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColor&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">basicUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建各种类型的 QVariant</span></span><br><span class="line">    QVariant intVar = <span class="number">42</span>;                    <span class="comment">// int</span></span><br><span class="line">    QVariant boolVar = <span class="literal">true</span>;                 <span class="comment">// bool</span></span><br><span class="line">    QVariant stringVar = <span class="built_in">QString</span>(<span class="string">&quot;Hello&quot;</span>);   <span class="comment">// QString</span></span><br><span class="line">    QVariant colorVar = <span class="built_in">QColor</span>(Qt::red);     <span class="comment">// QColor</span></span><br><span class="line">    QVariant dateVar = QDateTime::<span class="built_in">currentDateTime</span>(); <span class="comment">// QDateTime</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用构造函数</span></span><br><span class="line">    <span class="function">QVariant <span class="title">doubleVar</span><span class="params">(<span class="number">3.14159</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 setValue() 方法</span></span><br><span class="line">    QVariant listVar;</span><br><span class="line">    listVar.<span class="built_in">setValue</span>(<span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; <span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">typeConversion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QVariant var = <span class="number">42</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查类型</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Type name:&quot;</span> &lt;&lt; var.<span class="built_in">typeName</span>(); <span class="comment">// 输出: int</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Can convert to double?&quot;</span> &lt;&lt; var.<span class="built_in">canConvert</span>&lt;<span class="type">double</span>&gt;(); <span class="comment">// true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 安全转换</span></span><br><span class="line">    <span class="keyword">if</span> (var.<span class="built_in">canConvert</span>&lt;<span class="type">int</span>&gt;()) &#123;</span><br><span class="line">        <span class="type">int</span> value = var.<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Integer value:&quot;</span> &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换到不同类型</span></span><br><span class="line">    <span class="type">double</span> doubleValue = var.<span class="built_in">toDouble</span>(); <span class="comment">// 42.0</span></span><br><span class="line">    QString stringValue = var.<span class="built_in">toString</span>(); <span class="comment">// &quot;42&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用模板函数进行转换</span></span><br><span class="line">    <span class="type">int</span> intValue = var.<span class="built_in">value</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (var.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Variant is valid&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    QVariant emptyVar;</span><br><span class="line">    <span class="keyword">if</span> (emptyVar.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Variant is null&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在-Qt-类中的实际应用"><a href="#在-Qt-类中的实际应用" class="headerlink" title="在 Qt 类中的实际应用"></a>在 Qt 类中的实际应用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSettings&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">practicalExamples</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 在设置/配置中的应用</span></span><br><span class="line">    <span class="function">QSettings <span class="title">settings</span><span class="params">(<span class="string">&quot;MyCompany&quot;</span>, <span class="string">&quot;MyApp&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存各种类型的数据</span></span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;fontSize&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;windowColor&quot;</span>, <span class="built_in">QColor</span>(Qt::blue));</span><br><span class="line">    settings.<span class="built_in">setValue</span>(<span class="string">&quot;lastLogin&quot;</span>, QDateTime::<span class="built_in">currentDateTime</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取数据（自动转换为适当的类型）</span></span><br><span class="line">    <span class="type">int</span> fontSize = settings.<span class="built_in">value</span>(<span class="string">&quot;fontSize&quot;</span>, <span class="number">10</span>).<span class="built_in">toInt</span>(); <span class="comment">// 默认值 10</span></span><br><span class="line">    QColor color = settings.<span class="built_in">value</span>(<span class="string">&quot;windowColor&quot;</span>).<span class="built_in">value</span>&lt;QColor&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 在模型/视图中的应用</span></span><br><span class="line">    QVariant displayData = <span class="built_in">QString</span>(<span class="string">&quot;Display Text&quot;</span>);</span><br><span class="line">    QVariant decorationData = <span class="built_in">QColor</span>(Qt::red);</span><br><span class="line">    QVariant tooltipData = <span class="built_in">QString</span>(<span class="string">&quot;This is a tooltip&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这些 QVariant 可以直接用于 QAbstractItemModel 的 data() 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🛠️-自定义类型支持"><a href="#🛠️-自定义类型支持" class="headerlink" title="🛠️ 自定义类型支持"></a>🛠️ 自定义类型支持</h3><p>要让自定义类型能够与 <code>QVariant</code> 一起工作，需要进行一些额外的步骤：</p>
<h4 id="注册自定义类型"><a href="#注册自定义类型" class="headerlink" title="注册自定义类型"></a>注册自定义类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMetaType&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    QString name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    QString email;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要提供相等运算符，但不是必须的</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name == other.name &amp;&amp; age == other.age &amp;&amp; email == other.email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册自定义类型（必须在所有使用之前）</span></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(Person)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">customTypeExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册类型（只需要一次，通常在应用程序初始化时）</span></span><br><span class="line">    <span class="built_in">qRegisterMetaType</span>&lt;Person&gt;(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建自定义类型实例</span></span><br><span class="line">    Person person;</span><br><span class="line">    person.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    person.age = <span class="number">30</span>;</span><br><span class="line">    person.email = <span class="string">&quot;alice@example.com&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储到 QVariant</span></span><br><span class="line">    QVariant var = QVariant::<span class="built_in">fromValue</span>(person);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 QVariant 中提取</span></span><br><span class="line">    <span class="keyword">if</span> (var.<span class="built_in">canConvert</span>&lt;Person&gt;()) &#123;</span><br><span class="line">        Person extractedPerson = var.<span class="built_in">value</span>&lt;Person&gt;();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; extractedPerson.name;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Age:&quot;</span> &lt;&lt; extractedPerson.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查类型</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Stored type:&quot;</span> &lt;&lt; var.<span class="built_in">typeName</span>(); <span class="comment">// 输出: Person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🔧-高级用法"><a href="#🔧-高级用法" class="headerlink" title="🔧 高级用法"></a>🔧 高级用法</h3><h4 id="使用-QVariantList-和-QVariantMap"><a href="#使用-QVariantList-和-QVariantMap" class="headerlink" title="使用 QVariantList 和 QVariantMap"></a>使用 QVariantList 和 QVariantMap</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">containerExamples</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// QVariantList（实际上是 QList&lt;QVariant&gt;）</span></span><br><span class="line">    QVariantList list;</span><br><span class="line">    list.<span class="built_in">append</span>(<span class="number">42</span>);</span><br><span class="line">    list.<span class="built_in">append</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    list.<span class="built_in">append</span>(<span class="built_in">QColor</span>(Qt::red));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 QVariantList</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> QVariant &amp;item : list) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Item:&quot;</span> &lt;&lt; item &lt;&lt; <span class="string">&quot;Type:&quot;</span> &lt;&lt; item.<span class="built_in">typeName</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// QVariantMap（实际上是 QMap&lt;QString, QVariant&gt;）</span></span><br><span class="line">    QVariantMap map;</span><br><span class="line">    map[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">    map[<span class="string">&quot;age&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    map[<span class="string">&quot;active&quot;</span>] = <span class="literal">true</span>;</span><br><span class="line">    map[<span class="string">&quot;lastLogin&quot;</span>] = QDateTime::<span class="built_in">currentDateTime</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问 QVariantMap</span></span><br><span class="line">    QString name = map[<span class="string">&quot;name&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">    <span class="type">int</span> age = map[<span class="string">&quot;age&quot;</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 QVariantMap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">key</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型转换和验证"><a href="#类型转换和验证" class="headerlink" title="类型转换和验证"></a>类型转换和验证</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">advancedConversion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QVariant var = <span class="string">&quot;3.14&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试转换，如果失败返回默认值</span></span><br><span class="line">    <span class="type">double</span> value = var.<span class="built_in">toDouble</span>(); <span class="comment">// 3.14</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带成功指示的转换</span></span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    <span class="type">int</span> intValue = var.<span class="built_in">toInt</span>(&amp;ok);</span><br><span class="line">    <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Conversion to int failed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 qvariant_cast（模板方式）</span></span><br><span class="line">    QString str = <span class="built_in">qvariant_cast</span>&lt;QString&gt;(var);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查特定类型</span></span><br><span class="line">    <span class="keyword">if</span> (var.<span class="built_in">typeId</span>() == QMetaType::QString) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;It&#x27;s a string!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="⚠️-注意事项和最佳实践"><a href="#⚠️-注意事项和最佳实践" class="headerlink" title="⚠️ 注意事项和最佳实践"></a>⚠️ 注意事项和最佳实践</h3><ol>
<li><p><strong>性能考虑</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免不必要的拷贝</span></span><br><span class="line"><span class="function"><span class="type">const</span> QVariant &amp;<span class="title">getData</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">static</span> QVariant data = <span class="number">42</span>; </span><br><span class="line">    <span class="keyword">return</span> data; <span class="comment">// 返回 const 引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型安全</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总是检查类型转换是否成功</span></span><br><span class="line">QVariant var = <span class="built_in">getSomeData</span>();</span><br><span class="line"><span class="keyword">if</span> (var.<span class="built_in">canConvert</span>&lt;MyType&gt;()) &#123;</span><br><span class="line">    MyType value = var.<span class="built_in">value</span>&lt;MyType&gt;();</span><br><span class="line">    <span class="comment">// 安全使用 value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>空值处理</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVariant possiblyNull = <span class="built_in">getPossiblyNullData</span>();</span><br><span class="line"><span class="keyword">if</span> (possiblyNull.<span class="built_in">isValid</span>() &amp;&amp; !possiblyNull.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">    <span class="comment">// 安全使用数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="🎯-总结"><a href="#🎯-总结" class="headerlink" title="🎯 总结"></a>🎯 总结</h3><p><code>QVariant</code> 是 Qt 框架中极其重要的一个类，它提供了：</p>
<ul>
<li><strong>类型灵活性</strong>：可以存储和管理多种不同类型的数据</li>
<li><strong>运行时类型信息</strong>：允许在运行时检查和转换类型</li>
<li><strong>通用接口</strong>：为不确定类型的数据提供统一的处理方式</li>
<li><strong>Qt 集成</strong>：深度集成到 Qt 的各个模块中</li>
</ul>
<p>通过 <code>QVariant</code>，Qt 实现了高度灵活的数据处理能力，特别是在模型&#x2F;视图架构、属性系统和设置存储等场景中发挥着关键作用。掌握 <code>QVariant</code> 的使用对于进行高效的 Qt 开发至关重要。</p>
<h1 id="Qt信号槽跨线程通信机制详解"><a href="#Qt信号槽跨线程通信机制详解" class="headerlink" title="Qt信号槽跨线程通信机制详解"></a>Qt信号槽跨线程通信机制详解</h1><p>Qt的信号和槽机制是其核心特性之一，特别是在多线程环境下，它提供了一种安全、有序的跨线程通信方式。</p>
<h2 id="基本机制概述"><a href="#基本机制概述" class="headerlink" title="基本机制概述"></a>基本机制概述</h2><h3 id="1-线程关联性（Thread-Affinity）"><a href="#1-线程关联性（Thread-Affinity）" class="headerlink" title="1. 线程关联性（Thread Affinity）"></a>1. 线程关联性（Thread Affinity）</h3><p>每个QObject实例都有一个”线程关联性” - 即它属于哪个线程。这个关联性决定了：</p>
<ul>
<li>对象的事件处理在哪个线程执行</li>
<li>信号的传递方式</li>
</ul>
<h3 id="2-连接类型（Connection-Types）"><a href="#2-连接类型（Connection-Types）" class="headerlink" title="2. 连接类型（Connection Types）"></a>2. 连接类型（Connection Types）</h3><p>Qt提供了5种信号槽连接方式：</p>
<ul>
<li><code>Qt::AutoConnection</code>（默认）：自动决定连接方式</li>
<li><code>Qt::DirectConnection</code>：直接调用，类似函数调用</li>
<li><code>Qt::QueuedConnection</code>：队列连接，用于跨线程通信</li>
<li><code>Qt::BlockingQueuedConnection</code>：阻塞式队列连接</li>
<li><code>Qt::UniqueConnection</code>：唯一连接，防止重复连接</li>
</ul>
<h2 id="队列连接（QueuedConnection）机制详解"><a href="#队列连接（QueuedConnection）机制详解" class="headerlink" title="队列连接（QueuedConnection）机制详解"></a>队列连接（QueuedConnection）机制详解</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>当信号和槽处于不同线程且使用<code>Qt::QueuedConnection</code>时：</p>
<ol>
<li><strong>信号发射</strong>：在发送者线程中发射信号</li>
<li><strong>事件封装</strong>：Qt将信号参数和接收者信息封装成一个<code>QMetaCallEvent</code>事件</li>
<li><strong>事件投递</strong>：将该事件投递到接收者所在线程的事件队列中</li>
<li><strong>事件处理</strong>：接收者线程的事件循环从队列中取出并处理该事件</li>
<li><strong>槽函数执行</strong>：在接收者线程中调用相应的槽函数</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在工作线程中执行耗时操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 耗时操作...</span></span><br><span class="line">        <span class="function">emit <span class="title">resultReady</span><span class="params">(result)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resultReady</span><span class="params">(<span class="type">const</span> QString &amp;result)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主线程中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    QThread workerThread;</span><br><span class="line">    Worker worker;</span><br><span class="line">    worker.<span class="built_in">moveToThread</span>(&amp;workerThread);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接信号槽 - 自动选择QueuedConnection</span></span><br><span class="line">    <span class="built_in">connect</span>(&amp;worker, &amp;Worker::resultReady, </span><br><span class="line">            <span class="keyword">this</span>, &amp;MainWindow::handleResult);</span><br><span class="line">    </span><br><span class="line">    workerThread.<span class="built_in">start</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程安全性与有序性保证"><a href="#线程安全性与有序性保证" class="headerlink" title="线程安全性与有序性保证"></a>线程安全性与有序性保证</h2><h3 id="1-线程安全性"><a href="#1-线程安全性" class="headerlink" title="1. 线程安全性"></a>1. 线程安全性</h3><ul>
<li><strong>事件队列线程安全</strong>：Qt使用互斥锁保护事件队列的访问</li>
<li><strong>原子操作</strong>：事件投递是原子性的，不会被打断</li>
<li><strong>内存屏障</strong>：确保内存访问的正确顺序</li>
</ul>
<h3 id="2-有序性保证"><a href="#2-有序性保证" class="headerlink" title="2. 有序性保证"></a>2. 有序性保证</h3><ul>
<li><strong>FIFO顺序</strong>：事件队列按照先进先出的顺序处理</li>
<li><strong>发送顺序保持</strong>：信号发射的顺序与槽函数执行的顺序一致</li>
<li><strong>线程内顺序</strong>：同一线程内的事件处理保持顺序性</li>
</ul>
<h3 id="3-底层实现机制"><a href="#3-底层实现机制" class="headerlink" title="3. 底层实现机制"></a>3. 底层实现机制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的投递过程（伪代码）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QMetaObject::activate</span><span class="params">(QObject *sender, <span class="type">int</span> signal_index, <span class="type">void</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查连接类型</span></span><br><span class="line">    <span class="keyword">if</span> (receiver-&gt;<span class="built_in">thread</span>() != sender-&gt;<span class="built_in">thread</span>()) &#123;</span><br><span class="line">        <span class="comment">// 创建事件并投递到接收者线程的事件队列</span></span><br><span class="line">        QMetaCallEvent *ev = <span class="keyword">new</span> <span class="built_in">QMetaCallEvent</span>(sender, signal_index, argv);</span><br><span class="line">        QCoreApplication::<span class="built_in">postEvent</span>(receiver, ev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接连接，立即调用</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动连接（AutoConnection）的智能选择"><a href="#自动连接（AutoConnection）的智能选择" class="headerlink" title="自动连接（AutoConnection）的智能选择"></a>自动连接（AutoConnection）的智能选择</h2><p>当使用默认的<code>Qt::AutoConnection</code>时，Qt会在信号发射时动态决定连接方式：</p>
<ol>
<li><strong>同线程</strong>：如果发送者和接收者在同一线程，使用<code>DirectConnection</code></li>
<li><strong>跨线程</strong>：如果发送者和接收者在不同线程，使用<code>QueuedConnection</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Qt内部的决策逻辑（简化）</span></span><br><span class="line"><span class="function">Qt::ConnectionType <span class="title">QObject::connectionType</span><span class="params">(<span class="type">const</span> QObject *receiver)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QThread::<span class="built_in">currentThread</span>() == receiver-&gt;<span class="built_in">thread</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Qt::DirectConnection;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Qt::QueuedConnection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><h3 id="1-后台任务处理"><a href="#1-后台任务处理" class="headerlink" title="1. 后台任务处理"></a>1. 后台任务处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作线程执行任务，主线程更新UI</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskController</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QThread *thread = <span class="keyword">new</span> QThread;</span><br><span class="line">        Worker *worker = <span class="keyword">new</span> Worker;</span><br><span class="line">        worker-&gt;<span class="built_in">moveToThread</span>(thread);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">connect</span>(thread, &amp;QThread::started, worker, &amp;Worker::doWork);</span><br><span class="line">        <span class="built_in">connect</span>(worker, &amp;Worker::resultReady, <span class="keyword">this</span>, &amp;TaskController::handleResult);</span><br><span class="line">        <span class="built_in">connect</span>(worker, &amp;Worker::finished, thread, &amp;QThread::quit);</span><br><span class="line">        <span class="built_in">connect</span>(worker, &amp;Worker::finished, worker, &amp;Worker::deleteLater);</span><br><span class="line">        <span class="built_in">connect</span>(thread, &amp;QThread::finished, thread, &amp;QThread::deleteLater);</span><br><span class="line">        </span><br><span class="line">        thread-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleResult</span><span class="params">(<span class="type">const</span> QString &amp;result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在主线程中安全更新UI</span></span><br><span class="line">        ui-&gt;resultLabel-&gt;<span class="built_in">setText</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-多生产者-单消费者模式"><a href="#2-多生产者-单消费者模式" class="headerlink" title="2. 多生产者-单消费者模式"></a>2. 多生产者-单消费者模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个工作线程向主线程发送数据</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataProcessor</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processFromMultipleThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            QThread *thread = <span class="keyword">new</span> QThread;</span><br><span class="line">            DataProducer *producer = <span class="keyword">new</span> DataProducer;</span><br><span class="line">            producer-&gt;<span class="built_in">moveToThread</span>(thread);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">connect</span>(thread, &amp;QThread::started, producer, &amp;DataProducer::produce);</span><br><span class="line">            <span class="built_in">connect</span>(producer, &amp;DataProducer::dataReady, </span><br><span class="line">                    <span class="keyword">this</span>, &amp;DataProcessor::processData, Qt::QueuedConnection);</span><br><span class="line">            </span><br><span class="line">            thread-&gt;<span class="built_in">start</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> QByteArray &amp;data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 所有数据都会按到达顺序在主线程中处理</span></span><br><span class="line">        <span class="comment">// 线程安全且有顺序保证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="性能考虑与最佳实践"><a href="#性能考虑与最佳实践" class="headerlink" title="性能考虑与最佳实践"></a>性能考虑与最佳实践</h2><h3 id="1-性能开销"><a href="#1-性能开销" class="headerlink" title="1. 性能开销"></a>1. 性能开销</h3><ul>
<li><strong>事件创建</strong>：每次信号发射都需要创建事件对象</li>
<li><strong>内存分配</strong>：参数需要拷贝到事件中</li>
<li><strong>线程切换</strong>：涉及线程间上下文切换</li>
</ul>
<h3 id="2-优化建议"><a href="#2-优化建议" class="headerlink" title="2. 优化建议"></a>2. 优化建议</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免频繁的小信号</span></span><br><span class="line"><span class="comment">// 不佳的做法：频繁发射小信号</span></span><br><span class="line"><span class="function">emit <span class="title">dataUpdated</span><span class="params">(singleValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的做法：批量处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">collectAndEmit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (batchData.<span class="built_in">size</span>() &gt;= BATCH_SIZE) &#123;</span><br><span class="line">        <span class="function">emit <span class="title">dataBatchReady</span><span class="params">(batchData)</span></span>;</span><br><span class="line">        batchData.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h3><ul>
<li><strong>死锁风险</strong>：<code>Qt::BlockingQueuedConnection</code>可能引起死锁</li>
<li><strong>对象生命周期</strong>：确保接收者对象在槽函数被调用时仍然存在</li>
<li><strong>参数类型</strong>：参数类型必须注册为Qt元类型（使用<code>qRegisterMetaType</code>）</li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>Qt的信号槽机制通过队列连接方式提供了强大的跨线程通信能力：</p>
<ol>
<li><strong>线程安全</strong>：通过事件队列和互斥锁保证</li>
<li><strong>有序性</strong>：FIFO事件处理保证执行顺序</li>
<li><strong>灵活性</strong>：自动选择最佳连接方式</li>
<li><strong>解耦合</strong>：发送者和接收者不需要知道对方的线程情况</li>
</ol>
<p>这种机制使得多线程编程更加简单和安全，是Qt框架的核心优势之一。</p>
<h1 id="Qt-Model-View-Delegate-框架详细说明"><a href="#Qt-Model-View-Delegate-框架详细说明" class="headerlink" title="Qt Model-View-Delegate 框架详细说明"></a>Qt Model-View-Delegate 框架详细说明</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Qt的Model-View架构是一种用于分离数据存储与数据展示的高级设计模式。该框架由三个核心组件组成：Model（数据模型）、View（视图）和Delegate（委托）。这种分离使得开发人员可以灵活地处理数据，同时保持用户界面的一致性。</p>
<h2 id="Model-数据模型"><a href="#Model-数据模型" class="headerlink" title="Model (数据模型)"></a>Model (数据模型)</h2><h3 id="Model-的类型"><a href="#Model-的类型" class="headerlink" title="Model 的类型"></a>Model 的类型</h3><h4 id="1-基础模型类"><a href="#1-基础模型类" class="headerlink" title="1. 基础模型类"></a>1. 基础模型类</h4><ul>
<li><strong>QAbstractItemModel</strong>: 所有模型的抽象基类，定义了模型必须实现的接口</li>
<li><strong>QAbstractListModel</strong>: 用于列表数据的抽象基类</li>
<li><strong>QAbstractTableModel</strong>: 用于表格数据的抽象基类</li>
</ul>
<h4 id="2-具体实现模型"><a href="#2-具体实现模型" class="headerlink" title="2. 具体实现模型"></a>2. 具体实现模型</h4><ul>
<li><strong>QStandardItemModel</strong>: 通用模型，可存储任意数据</li>
<li><strong>QStringListModel</strong>: 专门用于字符串列表的模型</li>
<li><strong>QFileSystemModel</strong>: 文件系统模型</li>
<li><strong>QSqlQueryModel</strong>, <strong>QSqlTableModel</strong>, <strong>QSqlRelationalTableModel</strong>: 数据库模型</li>
</ul>
<h3 id="Model-的核心方法"><a href="#Model-的核心方法" class="headerlink" title="Model 的核心方法"></a>Model 的核心方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须实现的基本方法</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">rowCount</span><span class="params">(<span class="type">const</span> QModelIndex &amp;parent = QModelIndex())</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">columnCount</span><span class="params">(<span class="type">const</span> QModelIndex &amp;parent = QModelIndex())</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QVariant <span class="title">data</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index, <span class="type">int</span> role = Qt::DisplayRole)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QVariant <span class="title">headerData</span><span class="params">(<span class="type">int</span> section, Qt::Orientation orientation, <span class="type">int</span> role = Qt::DisplayRole)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可编辑模型需要实现的方法</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">setData</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index, <span class="type">const</span> QVariant &amp;value, <span class="type">int</span> role = Qt::EditRole)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">setHeaderData</span><span class="params">(<span class="type">int</span> section, Qt::Orientation orientation, <span class="type">const</span> QVariant &amp;value, <span class="type">int</span> role = Qt::EditRole)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Qt::ItemFlags <span class="title">flags</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层次结构模型需要的方法</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QModelIndex <span class="title">index</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column, <span class="type">const</span> QModelIndex &amp;parent = QModelIndex())</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QModelIndex <span class="title">parent</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="数据角色-Data-Roles"><a href="#数据角色-Data-Roles" class="headerlink" title="数据角色 (Data Roles)"></a>数据角色 (Data Roles)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用数据角色</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ItemDataRole</span> &#123;</span><br><span class="line">    DisplayRole,        <span class="comment">// 显示文本</span></span><br><span class="line">    DecorationRole,     <span class="comment">// 图标装饰</span></span><br><span class="line">    EditRole,           <span class="comment">// 编辑文本</span></span><br><span class="line">    ToolTipRole,        <span class="comment">// 工具提示</span></span><br><span class="line">    StatusTipRole,      <span class="comment">// 状态栏提示</span></span><br><span class="line">    WhatsThisRole,      <span class="comment">// &quot;这是什么&quot;提示</span></span><br><span class="line">    SizeHintRole,       <span class="comment">// 大小提示</span></span><br><span class="line">    FontRole,           <span class="comment">// 字体</span></span><br><span class="line">    TextAlignmentRole,  <span class="comment">// 文本对齐</span></span><br><span class="line">    BackgroundRole,     <span class="comment">// 背景色</span></span><br><span class="line">    ForegroundRole,     <span class="comment">// 前景色</span></span><br><span class="line">    CheckStateRole,     <span class="comment">// 复选框状态</span></span><br><span class="line">    UserRole            <span class="comment">// 用户自定义角色起点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="自定义模型示例"><a href="#自定义模型示例" class="headerlink" title="自定义模型示例"></a>自定义模型示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomTableModel</span> : <span class="keyword">public</span> QAbstractTableModel</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CustomTableModel</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rowCount</span><span class="params">(<span class="type">const</span> QModelIndex &amp;parent = QModelIndex())</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">columnCount</span><span class="params">(<span class="type">const</span> QModelIndex &amp;parent = QModelIndex())</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QVariant <span class="title">data</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index, <span class="type">int</span> role = Qt::DisplayRole)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QVariant <span class="title">headerData</span><span class="params">(<span class="type">int</span> section, Qt::Orientation orientation, <span class="type">int</span> role = Qt::DisplayRole)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setData</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index, <span class="type">const</span> QVariant &amp;value, <span class="type">int</span> role = Qt::EditRole)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">Qt::ItemFlags <span class="title">flags</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addItem</span><span class="params">(<span class="type">const</span> QString &amp;name, <span class="type">const</span> QString &amp;value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeItem</span><span class="params">(<span class="type">int</span> row)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QList&lt;QPair&lt;QString, QString&gt;&gt; m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="View-视图"><a href="#View-视图" class="headerlink" title="View (视图)"></a>View (视图)</h2><h3 id="View-的类型"><a href="#View-的类型" class="headerlink" title="View 的类型"></a>View 的类型</h3><h4 id="1-基础视图类"><a href="#1-基础视图类" class="headerlink" title="1. 基础视图类"></a>1. 基础视图类</h4><ul>
<li><strong>QAbstractItemView</strong>: 所有视图的抽象基类</li>
<li><strong>QListView</strong>: 列表视图</li>
<li><strong>QTableView</strong>: 表格视图</li>
<li><strong>QTreeView</strong>: 树形视图</li>
<li><strong>QColumnView</strong>: 列视图</li>
<li><strong>QHeaderView</strong>: 表头视图</li>
</ul>
<h4 id="2-专用视图组件"><a href="#2-专用视图组件" class="headerlink" title="2. 专用视图组件"></a>2. 专用视图组件</h4><ul>
<li><strong>QListWidget</strong>, <strong>QTableWidget</strong>, <strong>QTreeWidget</strong>: 集成了默认模型的便捷类</li>
</ul>
<h3 id="View-的配置方法"><a href="#View-的配置方法" class="headerlink" title="View 的配置方法"></a>View 的配置方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置模型</span></span><br><span class="line">QTableView *tableView = <span class="keyword">new</span> QTableView;</span><br><span class="line">tableView-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择模式</span></span><br><span class="line">tableView-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection);</span><br><span class="line">tableView-&gt;<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示设置</span></span><br><span class="line">tableView-&gt;<span class="built_in">setShowGrid</span>(<span class="literal">true</span>);</span><br><span class="line">tableView-&gt;<span class="built_in">setGridStyle</span>(Qt::DotLine);</span><br><span class="line">tableView-&gt;<span class="built_in">setSortingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">tableView-&gt;<span class="built_in">setAlternatingRowColors</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整显示</span></span><br><span class="line">tableView-&gt;<span class="built_in">resizeColumnsToContents</span>();</span><br><span class="line">tableView-&gt;<span class="built_in">resizeRowsToContents</span>();</span><br><span class="line">tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setStretchLastSection</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="视图选择处理"><a href="#视图选择处理" class="headerlink" title="视图选择处理"></a>视图选择处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接选择信号</span></span><br><span class="line"><span class="built_in">connect</span>(tableView-&gt;<span class="built_in">selectionModel</span>(), &amp;QItemSelectionModel::selectionChanged,</span><br><span class="line">        <span class="keyword">this</span>, &amp;MyClass::handleSelectionChanged);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理选择变化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::handleSelectionChanged</span><span class="params">(<span class="type">const</span> QItemSelection &amp;selected, <span class="type">const</span> QItemSelection &amp;deselected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QModelIndexList indexes = selected.<span class="built_in">indexes</span>();</span><br><span class="line">    <span class="keyword">if</span> (!indexes.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        QModelIndex selectedIndex = indexes.<span class="built_in">first</span>();</span><br><span class="line">        <span class="comment">// 处理选中的项目</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Delegate-委托"><a href="#Delegate-委托" class="headerlink" title="Delegate (委托)"></a>Delegate (委托)</h2><h3 id="Delegate-的类型"><a href="#Delegate-的类型" class="headerlink" title="Delegate 的类型"></a>Delegate 的类型</h3><ul>
<li><strong>QAbstractItemDelegate</strong>: 所有委托的抽象基类</li>
<li><strong>QStyledItemDelegate</strong>: 现代风格委托（推荐使用）</li>
<li><strong>QItemDelegate</strong>: 传统风格委托</li>
</ul>
<h3 id="Delegate-的核心方法"><a href="#Delegate-的核心方法" class="headerlink" title="Delegate 的核心方法"></a>Delegate 的核心方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须实现的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionViewItem &amp;option, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QSize <span class="title">sizeHint</span><span class="params">(<span class="type">const</span> QStyleOptionViewItem &amp;option, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可编辑项目需要实现的方法</span></span><br><span class="line"><span class="function">QWidget *<span class="title">createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setEditorData</span><span class="params">(QWidget *editor, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setModelData</span><span class="params">(QWidget *editor, QAbstractItemModel *model, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateEditorGeometry</span><span class="params">(QWidget *editor, <span class="type">const</span> QStyleOptionViewItem &amp;option, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="自定义委托示例"><a href="#自定义委托示例" class="headerlink" title="自定义委托示例"></a>自定义委托示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomDelegate</span> : <span class="keyword">public</span> QStyledItemDelegate</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CustomDelegate</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionViewItem &amp;option, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QSize <span class="title">sizeHint</span><span class="params">(<span class="type">const</span> QStyleOptionViewItem &amp;option, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">QWidget *<span class="title">createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setEditorData</span><span class="params">(QWidget *editor, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setModelData</span><span class="params">(QWidget *editor, QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="委托使用示例"><a href="#委托使用示例" class="headerlink" title="委托使用示例"></a>委托使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为特定列设置委托</span></span><br><span class="line">QTableView *tableView = <span class="keyword">new</span> QTableView;</span><br><span class="line">tableView-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为第一列设置自定义委托</span></span><br><span class="line">tableView-&gt;<span class="built_in">setItemDelegateForColumn</span>(<span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">CustomDelegate</span>(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者为整个视图设置委托</span></span><br><span class="line">tableView-&gt;<span class="built_in">setItemDelegate</span>(<span class="keyword">new</span> <span class="built_in">CustomDelegate</span>(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>

<h2 id="协同工作机制"><a href="#协同工作机制" class="headerlink" title="协同工作机制"></a>协同工作机制</h2><h3 id="1-数据流：Model-→-View"><a href="#1-数据流：Model-→-View" class="headerlink" title="1. 数据流：Model → View"></a>1. 数据流：Model → View</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View请求数据时</span></span><br><span class="line"><span class="function">QVariant <span class="title">CustomModel::data</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index, <span class="type">int</span> role)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!index.<span class="built_in">isValid</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QVariant</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (role == Qt::DisplayRole) &#123;</span><br><span class="line">        <span class="comment">// 返回显示数据</span></span><br><span class="line">        <span class="keyword">return</span> m_data[index.<span class="built_in">row</span>()].first;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (role == Qt::UserRole) &#123;</span><br><span class="line">        <span class="comment">// 返回自定义数据</span></span><br><span class="line">        <span class="keyword">return</span> m_data[index.<span class="built_in">row</span>()].second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QVariant</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-数据编辑：View-→-Model"><a href="#2-数据编辑：View-→-Model" class="headerlink" title="2. 数据编辑：View → Model"></a>2. 数据编辑：View → Model</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过委托编辑数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CustomDelegate::setModelData</span><span class="params">(QWidget *editor, QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QLineEdit *lineEdit = <span class="built_in">qobject_cast</span>&lt;QLineEdit*&gt;(editor);</span><br><span class="line">    <span class="keyword">if</span> (lineEdit) &#123;</span><br><span class="line">        model-&gt;<span class="built_in">setData</span>(index, lineEdit-&gt;<span class="built_in">text</span>(), Qt::EditRole);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-模型更新通知"><a href="#3-模型更新通知" class="headerlink" title="3. 模型更新通知"></a>3. 模型更新通知</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模型数据变化时发出信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CustomModel::addItem</span><span class="params">(<span class="type">const</span> QString &amp;name, <span class="type">const</span> QString &amp;value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">beginInsertRows</span>(<span class="built_in">QModelIndex</span>(), m_data.<span class="built_in">size</span>(), m_data.<span class="built_in">size</span>());</span><br><span class="line">    m_data.<span class="built_in">append</span>(<span class="built_in">QPair</span>&lt;QString, QString&gt;(name, value));</span><br><span class="line">    <span class="built_in">endInsertRows</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者使用dataChanged信号更新现有数据</span></span><br><span class="line">    <span class="comment">// QModelIndex topLeft = createIndex(0, 0);</span></span><br><span class="line">    <span class="comment">// QModelIndex bottomRight = createIndex(m_data.size()-1, 0);</span></span><br><span class="line">    <span class="comment">// emit dataChanged(topLeft, bottomRight);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-完整协作示例"><a href="#4-完整协作示例" class="headerlink" title="4. 完整协作示例"></a>4. 完整协作示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建模型</span></span><br><span class="line">CustomTableModel *model = <span class="keyword">new</span> <span class="built_in">CustomTableModel</span>(<span class="keyword">this</span>);</span><br><span class="line">model-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;Item 1&quot;</span>, <span class="string">&quot;Value 1&quot;</span>);</span><br><span class="line">model-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;Item 2&quot;</span>, <span class="string">&quot;Value 2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建视图</span></span><br><span class="line">QTableView *tableView = <span class="keyword">new</span> QTableView;</span><br><span class="line">tableView-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置委托</span></span><br><span class="line">tableView-&gt;<span class="built_in">setItemDelegateForColumn</span>(<span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">CustomDelegate</span>(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理选择</span></span><br><span class="line"><span class="built_in">connect</span>(tableView-&gt;<span class="built_in">selectionModel</span>(), &amp;QItemSelectionModel::selectionChanged,</span><br><span class="line">        [=](<span class="type">const</span> QItemSelection &amp;selected, <span class="type">const</span> QItemSelection &amp;deselected) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!selected.<span class="built_in">indexes</span>().<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        QModelIndex index = selected.<span class="built_in">indexes</span>().<span class="built_in">first</span>();</span><br><span class="line">        QString data = model-&gt;<span class="built_in">data</span>(index, Qt::UserRole).<span class="built_in">toString</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Selected item data:&quot;</span> &lt;&lt; data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应模型变化</span></span><br><span class="line"><span class="built_in">connect</span>(model, &amp;CustomTableModel::dataChanged,</span><br><span class="line">        [=](<span class="type">const</span> QModelIndex &amp;topLeft, <span class="type">const</span> QModelIndex &amp;bottomRight) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Data changed from row&quot;</span> &lt;&lt; topLeft.<span class="built_in">row</span>() &lt;&lt; <span class="string">&quot;to&quot;</span> &lt;&lt; bottomRight.<span class="built_in">row</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="1-代理模型-Proxy-Models"><a href="#1-代理模型-Proxy-Models" class="headerlink" title="1. 代理模型 (Proxy Models)"></a>1. 代理模型 (Proxy Models)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序过滤代理</span></span><br><span class="line">QSortFilterProxyModel *proxyModel = <span class="keyword">new</span> QSortFilterProxyModel;</span><br><span class="line">proxyModel-&gt;<span class="built_in">setSourceModel</span>(sourceModel);</span><br><span class="line">proxyModel-&gt;<span class="built_in">setFilterRegularExpression</span>(<span class="built_in">QRegularExpression</span>(<span class="string">&quot;^A&quot;</span>));</span><br><span class="line">proxyModel-&gt;<span class="built_in">setSortCaseSensitivity</span>(Qt::CaseInsensitive);</span><br><span class="line">tableView-&gt;<span class="built_in">setModel</span>(proxyModel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义代理模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomProxyModel</span> : <span class="keyword">public</span> QSortFilterProxyModel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">filterAcceptsRow</span><span class="params">(<span class="type">int</span> sourceRow, <span class="type">const</span> QModelIndex &amp;sourceParent)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lessThan</span><span class="params">(<span class="type">const</span> QModelIndex &amp;left, <span class="type">const</span> QModelIndex &amp;right)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-拖放支持"><a href="#2-拖放支持" class="headerlink" title="2. 拖放支持"></a>2. 拖放支持</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在模型中启用拖放</span></span><br><span class="line"><span class="function">Qt::ItemFlags <span class="title">CustomModel::flags</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Qt::ItemFlags defaultFlags = QAbstractTableModel::<span class="built_in">flags</span>(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index.<span class="built_in">isValid</span>())</span><br><span class="line">        <span class="keyword">return</span> defaultFlags | Qt::ItemIsDragEnabled | Qt::ItemIsDropEnabled;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> defaultFlags | Qt::ItemIsDropEnabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现拖放方法</span></span><br><span class="line"><span class="function">Qt::DropActions <span class="title">CustomModel::supportedDropActions</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qt::CopyAction | Qt::MoveAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-视图选项配置"><a href="#3-视图选项配置" class="headerlink" title="3. 视图选项配置"></a>3. 视图选项配置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置视图行为</span></span><br><span class="line">tableView-&gt;<span class="built_in">setEditTriggers</span>(QAbstractItemView::DoubleClicked | </span><br><span class="line">                          QAbstractItemView::EditKeyPressed);</span><br><span class="line">tableView-&gt;<span class="built_in">setTabKeyNavigation</span>(<span class="literal">true</span>);</span><br><span class="line">tableView-&gt;<span class="built_in">setDragEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">tableView-&gt;<span class="built_in">setDragDropMode</span>(QAbstractItemView::InternalMove);</span><br><span class="line">tableView-&gt;<span class="built_in">setDefaultDropAction</span>(Qt::MoveAction);</span><br></pre></td></tr></table></figure>

<h2 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h2><ol>
<li><strong>实现合适的<code>data()</code>方法</strong>：只返回请求的角色数据，避免不必要的计算</li>
<li><strong>使用批量操作</strong>：对于大量数据更新，使用<code>beginResetModel()</code>&#x2F;<code>endResetModel()</code>或<code>beginInsertRows()</code>&#x2F;<code>endInsertRows()</code></li>
<li><strong>合理使用代理模型</strong>：避免在代理模型中进行复杂计算</li>
<li><strong>实现<code>sort()</code>方法</strong>：对于自定义模型，实现高效的排序算法</li>
<li><strong>使用<code>fetchMore()</code>和<code>canFetchMore()</code></strong>：对于大型数据集，实现增量加载</li>
</ol>
<p>这种架构提供了极大的灵活性，允许开发者创建高度定制化的数据展示和编辑界面，同时保持代码的组织性和可维护性。</p>
<h1 id="事件过滤器的作用"><a href="#事件过滤器的作用" class="headerlink" title="事件过滤器的作用"></a>事件过滤器的作用</h1><p>事件过滤器允许一个对象（称为<strong>过滤器对象</strong>）监视甚至拦截发送到另一个对象（称为<strong>目标对象</strong>）的事件。这意味着，在事件到达目标对象之前，你可以先“检查”并决定是否要“处理”它，或者让它继续传递。在 Qt 中使用事件过滤器可以让你在一个对象中拦截并处理另一个对象的事件，这为事件处理提供了很大的灵活性。下面我会为你介绍如何定义和使用事件过滤器。</p>
<ul>
<li><strong>拦截事件</strong>：例如，对话框拦截按键事件，阻止其他组件接收。</li>
<li><strong>批量处理</strong>：父容器统一处理所有子控件的事件，无需为每个子控件单独编写逻辑。</li>
<li><strong>全局监控</strong>：应用程序级别的事件监控，如全局快捷键、日志记录。</li>
</ul>
<h3 id="📝-定义与使用事件过滤器"><a href="#📝-定义与使用事件过滤器" class="headerlink" title="📝 定义与使用事件过滤器"></a>📝 定义与使用事件过滤器</h3><p>使用事件过滤器主要分为两步：</p>
<ol>
<li><p><strong>定义过滤器对象并重写 <code>eventFilter</code> 函数</strong><br>你需要创建一个继承自 <code>QObject</code> 的类（或者使用已有的 <code>QObject</code> 子类），并重写其 <code>eventFilter</code> 函数。</p>
</li>
<li><p><strong>给目标对象安装事件过滤器</strong><br>在你希望监视的对象上，调用 <code>installEventFilter</code> 方法，并传入第一步中准备好的过滤器对象。</p>
</li>
</ol>
<h4 id="1-为单个控件设置事件过滤器（常用）"><a href="#1-为单个控件设置事件过滤器（常用）" class="headerlink" title="1. 为单个控件设置事件过滤器（常用）"></a>1. 为单个控件设置事件过滤器（常用）</h4><p>如果你想为特定的控件（例如一个按钮、文本框）设置事件过滤器：</p>
<p><strong>定义过滤器并重写 <code>eventFilter</code> 函数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEventFilter</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyEventFilter</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span> : QObject(parent) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) <span class="comment">// 示例：过滤键盘按下事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent*&gt;(event);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Key pressed in&quot;</span> &lt;&lt; obj-&gt;<span class="built_in">objectName</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; keyEvent-&gt;<span class="built_in">key</span>();</span><br><span class="line">            <span class="comment">// return true;  // 如果拦截事件，阻止其继续传递</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于其他事件，继续传递</span></span><br><span class="line">        <span class="keyword">return</span> QObject::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>安装事件过滤器</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设在某处有一个 QLineEdit 对象</span></span><br><span class="line">QLineEdit *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">lineEdit-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;MyLineEdit&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建过滤器对象并安装</span></span><br><span class="line">MyEventFilter *filter = <span class="keyword">new</span> <span class="built_in">MyEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line">lineEdit-&gt;<span class="built_in">installEventFilter</span>(filter);</span><br></pre></td></tr></table></figure>

<p><strong>在现有类（如主窗口）中直接处理</strong>：<br>你也可以在现有的类（例如 <code>MainWindow</code>）中直接重写 <code>eventFilter</code> 方法，并为自己或子控件安装过滤器 (<code>installEventFilter(this)</code>)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：在主窗口中过滤子控件的事件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == ui-&gt;textEdit &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">        QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent*&gt;(event);</span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Return || keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Enter) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;回车键被拦截&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 拦截回车键事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QMainWindow::<span class="built_in">eventFilter</span>(obj, event); <span class="comment">// 其他事件交给父类处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构造函数中安装</span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) : <span class="built_in">QMainWindow</span>(parent), <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>); <span class="comment">// 为textEdit安装过滤器，使用this（MainWindow）作为过滤器对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-为父容器设置事件过滤器（批量处理）"><a href="#2-为父容器设置事件过滤器（批量处理）" class="headerlink" title="2. 为父容器设置事件过滤器（批量处理）"></a>2. 为父容器设置事件过滤器（批量处理）</h4><p>如果你想批量处理某个容器内所有子控件的事件，可以在父容器上安装事件过滤器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContainerWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ContainerWidget</span>(QWidget *parent = <span class="literal">nullptr</span>) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一些子控件...</span></span><br><span class="line">        <span class="built_in">installEventFilter</span>(<span class="keyword">this</span>); <span class="comment">// 为容器自身安装过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 通过判断 obj 是否是子控件来处理事件</span></span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;<span class="built_in">parent</span>() == <span class="keyword">this</span> &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;子控件被点击:&quot;</span> &lt;&lt; obj-&gt;<span class="built_in">objectName</span>();</span><br><span class="line">            <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-全局事件过滤器"><a href="#3-全局事件过滤器" class="headerlink" title="3. 全局事件过滤器"></a>3. 全局事件过滤器</h4><p>你还可以为整个应用程序安装全局事件过滤器，以监控所有事件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GlobalEventFilter</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">            QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent*&gt;(event);</span><br><span class="line">            <span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_F1) &#123;</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;全局 F1 按键被按下&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QObject::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    GlobalEventFilter globalFilter;</span><br><span class="line">    app.<span class="built_in">installEventFilter</span>(&amp;globalFilter); <span class="comment">// 给应用安装全局过滤器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ 注意事项</h3><ol>
<li><strong>事件传播</strong>：<code>eventFilter</code> 函数的返回值很重要。<ul>
<li><code>return true</code>：表示事件已被处理，<strong>不再</strong>传递给目标对象。</li>
<li><code>return false</code>：表示事件<strong>继续</strong>传递给目标对象或其后续过滤器。</li>
</ul>
</li>
<li><strong>执行顺序</strong>：如果一个对象安装了<strong>多个</strong>事件过滤器，那么<strong>最后安装的过滤器会最先执行</strong>。</li>
<li><strong>线程亲和性</strong>：事件过滤器对象和目标对象必须处于<strong>同一线程</strong>，否则过滤器将无效。</li>
<li><strong>内存管理</strong>：<ul>
<li>确保过滤器对象的生命周期<strong>长于</strong>目标对象，以避免悬空指针。通常将过滤器的父对象设置为目标对象或其父对象，利用 Qt 的对象树机制进行内存管理。</li>
<li>如果在事件过滤器中<strong>删除</strong>了接收事件的对象，务必让 <code>eventFilter</code> 函数返回 <code>true</code>，否则 Qt 可能还会尝试向已删除的对象发送事件，导致程序崩溃。</li>
</ul>
</li>
<li><strong>性能考量</strong>：全局事件过滤器会对<strong>每个事件</strong>进行检查，应谨慎使用以避免性能问题。</li>
</ol>
<h3 id="💡-应用场景"><a href="#💡-应用场景" class="headerlink" title="💡 应用场景"></a>💡 应用场景</h3><p>事件过滤器在处理这些场景时非常有用：</p>
<ul>
<li><strong>自定义控件行为</strong>：例如，在 QLineEdit 中按回车键执行特定操作而非默认行为。</li>
<li><strong>验证输入</strong>：在焦点离开输入框（<code>QEvent::FocusOut</code>）时验证内容有效性。</li>
<li><strong>批量操作</strong>：统一禁用或修改一组控件的鼠标滚轮事件。</li>
<li><strong>实现全局快捷键</strong>：捕获应用程序级别的特定按键组合。</li>
<li><strong>监控用户活动</strong>：记录用户与界面交互的日志。</li>
</ul>
<h3 id="📊-三种事件过滤器对比"><a href="#📊-三种事件过滤器对比" class="headerlink" title="📊 三种事件过滤器对比"></a>📊 三种事件过滤器对比</h3><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">作用范围</th>
<th align="left">性能影响</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>单个控件过滤器</strong></td>
<td align="left">特定控件及其子控件</td>
<td align="left">低</td>
<td align="left">精细化控制单个控件事件</td>
</tr>
<tr>
<td align="left"><strong>父容器过滤器</strong></td>
<td align="left">容器及其所有子控件</td>
<td align="left">中</td>
<td align="left">批量处理同类子控件事件</td>
</tr>
<tr>
<td align="left"><strong>全局过滤器</strong></td>
<td align="left">全应用所有控件</td>
<td align="left">高</td>
<td align="left">全局监控、系统级事件处理</td>
</tr>
</tbody></table>
<h3 id="🌰-简单示例"><a href="#🌰-简单示例" class="headerlink" title="🌰 简单示例"></a>🌰 简单示例</h3><p>假设你想阻止一个 QLineEdit 控件接收回车键事件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在包含该QLineEdit的窗口类（如MainWindow）的构造函数中：</span></span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在该窗口类中重写eventFilter函数：</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == ui-&gt;lineEdit &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">        QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent*&gt;(event);</span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Return || keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Enter) &#123;</span><br><span class="line">            <span class="comment">// 拦截回车键</span></span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;回车键被过滤&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 事件已处理，不再传递</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他事件继续传递</span></span><br><span class="line">    <span class="keyword">return</span> QMainWindow::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，Qt 的事件过滤器是一个强大且灵活的工具，通过重写 <code>eventFilter</code> 方法和使用 <code>installEventFilter</code> 安装，你可以有效地拦截和处理事件。使用时只需注意事件传播、过滤器顺序和内存管理等细节即可。</p>
<h1 id="Qt-ScrollBar-详细说明"><a href="#Qt-ScrollBar-详细说明" class="headerlink" title="Qt ScrollBar 详细说明"></a>Qt ScrollBar 详细说明</h1><p><code>QScrollBar</code> 是 Qt 中用于提供滚动功能的控件，它允许用户查看超出可视区域的内容。在 <code>QListWidget</code>、<code>QTableView</code> 等可滚动控件中，ScrollBar 是自动创建和管理的。</p>
<h2 id="ScrollBar-基本概念"><a href="#ScrollBar-基本概念" class="headerlink" title="ScrollBar 基本概念"></a>ScrollBar 基本概念</h2><h3 id="1-什么是-ScrollBar？"><a href="#1-什么是-ScrollBar？" class="headerlink" title="1. 什么是 ScrollBar？"></a>1. 什么是 ScrollBar？</h3><p>ScrollBar（滚动条）是一个图形用户界面元素，用于：</p>
<ul>
<li>指示当前在内容中的位置</li>
<li>允许用户通过拖动、点击箭头或点击轨道来导航内容</li>
<li>显示内容的相对大小和当前位置</li>
</ul>
<h3 id="2-ScrollBar-的组成部分"><a href="#2-ScrollBar-的组成部分" class="headerlink" title="2. ScrollBar 的组成部分"></a>2. ScrollBar 的组成部分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[▲] [=================■================] [▼]</span><br><span class="line"> ↑         ↑                 ↑           ↑</span><br><span class="line">向上按钮   轨道          滑块(拇指)     向下按钮</span><br></pre></td></tr></table></figure>

<h3 id="3-ScrollBar-的类型"><a href="#3-ScrollBar-的类型" class="headerlink" title="3. ScrollBar 的类型"></a>3. ScrollBar 的类型</h3><ul>
<li><strong>垂直滚动条</strong> (<code>Qt::Vertical</code>) - 用于上下滚动</li>
<li><strong>水平滚动条</strong> (<code>Qt::Horizontal</code>) - 用于左右滚动</li>
</ul>
<h2 id="在你的代码中使用-ScrollBar"><a href="#在你的代码中使用-ScrollBar" class="headerlink" title="在你的代码中使用 ScrollBar"></a>在你的代码中使用 ScrollBar</h2><h3 id="1-获取和设置-ScrollBar"><a href="#1-获取和设置-ScrollBar" class="headerlink" title="1. 获取和设置 ScrollBar"></a>1. 获取和设置 ScrollBar</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取垂直滚动条</span></span><br><span class="line">QScrollBar *verticalScrollBar = <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取水平滚动条  </span></span><br><span class="line">QScrollBar *horizontalScrollBar = <span class="keyword">this</span>-&gt;<span class="built_in">horizontalScrollBar</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置滚动条策略</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAsNeeded); <span class="comment">// 需要时显示</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOn); <span class="comment">// 总是显示</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff); <span class="comment">// 总是隐藏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置滚动条样式</span></span><br><span class="line">verticalScrollBar-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QScrollBar:vertical &#123;&quot;</span></span><br><span class="line">                                 <span class="string">&quot;    border: none;&quot;</span></span><br><span class="line">                                 <span class="string">&quot;    background: #f0f0f0;&quot;</span></span><br><span class="line">                                 <span class="string">&quot;    width: 10px;&quot;</span></span><br><span class="line">                                 <span class="string">&quot;    margin: 0px 0px 0px 0px;&quot;</span></span><br><span class="line">                                 <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">                                 <span class="string">&quot;QScrollBar::handle:vertical &#123;&quot;</span></span><br><span class="line">                                 <span class="string">&quot;    background: #c0c0c0;&quot;</span></span><br><span class="line">                                 <span class="string">&quot;    min-height: 20px;&quot;</span></span><br><span class="line">                                 <span class="string">&quot;    border-radius: 5px;&quot;</span></span><br><span class="line">                                 <span class="string">&quot;&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-ScrollBar-的重要属性和方法"><a href="#2-ScrollBar-的重要属性和方法" class="headerlink" title="2. ScrollBar 的重要属性和方法"></a>2. ScrollBar 的重要属性和方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取和设置当前值</span></span><br><span class="line"><span class="type">int</span> currentValue = verticalScrollBar-&gt;<span class="built_in">value</span>(); <span class="comment">// 获取当前值</span></span><br><span class="line">verticalScrollBar-&gt;<span class="built_in">setValue</span>(<span class="number">100</span>); <span class="comment">// 设置当前位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取范围信息</span></span><br><span class="line"><span class="type">int</span> minimum = verticalScrollBar-&gt;<span class="built_in">minimum</span>(); <span class="comment">// 最小值（通常为0）</span></span><br><span class="line"><span class="type">int</span> maximum = verticalScrollBar-&gt;<span class="built_in">maximum</span>(); <span class="comment">// 最大值（内容高度 - 可视高度）</span></span><br><span class="line"><span class="type">int</span> pageStep = verticalScrollBar-&gt;<span class="built_in">pageStep</span>(); <span class="comment">// 页面步长（可视区域高度）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置范围</span></span><br><span class="line">verticalScrollBar-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, totalHeight - visibleHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接值改变信号</span></span><br><span class="line"><span class="built_in">connect</span>(verticalScrollBar, &amp;QScrollBar::valueChanged, [](<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Scroll position changed to:&quot;</span> &lt;&lt; value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接滚动范围改变信号</span></span><br><span class="line"><span class="built_in">connect</span>(verticalScrollBar, &amp;QScrollBar::rangeChanged, [](<span class="type">int</span> min, <span class="type">int</span> max) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Scroll range changed. Min:&quot;</span> &lt;&lt; min &lt;&lt; <span class="string">&quot;Max:&quot;</span> &lt;&lt; max;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="修复你的代码"><a href="#修复你的代码" class="headerlink" title="修复你的代码"></a>修复你的代码</h2><p>你的代码中有几个问题需要修复：</p>
<h3 id="1-滚轮事件处理问题"><a href="#1-滚轮事件处理问题" class="headerlink" title="1. 滚轮事件处理问题"></a>1. 滚轮事件处理问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (watched == <span class="keyword">this</span>-&gt;<span class="built_in">viewport</span>() &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::Wheel) &#123;</span><br><span class="line">    QWheelEvent *wheelEvent = <span class="built_in">static_cast</span>&lt;QWheelEvent*&gt;(event);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现代Qt版本推荐使用pixelDelta而不是angleDelta</span></span><br><span class="line">    <span class="keyword">if</span> (!wheelEvent-&gt;<span class="built_in">pixelDelta</span>().<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        <span class="comment">// 使用像素精度的滚动</span></span><br><span class="line">        QPoint pixelDelta = wheelEvent-&gt;<span class="built_in">pixelDelta</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">setValue</span>(</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">value</span>() - pixelDelta.<span class="built_in">y</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wheelEvent-&gt;<span class="built_in">angleDelta</span>().<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        <span class="comment">// 使用角度精度的滚动（传统鼠标）</span></span><br><span class="line">        QPoint angleDelta = wheelEvent-&gt;<span class="built_in">angleDelta</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">setValue</span>(</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">value</span>() - angleDelta.<span class="built_in">y</span>() / <span class="number">8</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否滚动到底部</span></span><br><span class="line">    QScrollBar *scrollBar = <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>();</span><br><span class="line">    <span class="type">bool</span> atBottom = (scrollBar-&gt;<span class="built_in">value</span>() &gt;= scrollBar-&gt;<span class="built_in">maximum</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (atBottom) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Reached bottom, loading more chat users&quot;</span>;</span><br><span class="line">        <span class="function">emit <span class="title">sig_loading_chat_user</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 阻止默认滚动行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-改进的滚动检测逻辑"><a href="#2-改进的滚动检测逻辑" class="headerlink" title="2. 改进的滚动检测逻辑"></a>2. 改进的滚动检测逻辑</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个成员变量来跟踪加载状态，防止重复加载</span></span><br><span class="line"><span class="type">bool</span> isLoading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事件过滤器中</span></span><br><span class="line"><span class="keyword">if</span> (watched == <span class="keyword">this</span>-&gt;<span class="built_in">viewport</span>() &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::Wheel) &#123;</span><br><span class="line">    QWheelEvent *wheelEvent = <span class="built_in">static_cast</span>&lt;QWheelEvent*&gt;(event);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理滚动</span></span><br><span class="line">    QPoint delta;</span><br><span class="line">    <span class="keyword">if</span> (!wheelEvent-&gt;<span class="built_in">pixelDelta</span>().<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">        delta = wheelEvent-&gt;<span class="built_in">pixelDelta</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delta = wheelEvent-&gt;<span class="built_in">angleDelta</span>() / <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> newValue = <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">value</span>() - delta.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>()-&gt;<span class="built_in">setValue</span>(newValue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否接近底部（添加一些阈值防止过于敏感）</span></span><br><span class="line">    QScrollBar *scrollBar = <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>();</span><br><span class="line">    <span class="type">int</span> threshold = <span class="number">50</span>; <span class="comment">// 距离底部50像素时触发加载</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> nearBottom = (scrollBar-&gt;<span class="built_in">value</span>() &gt;= scrollBar-&gt;<span class="built_in">maximum</span>() - threshold);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nearBottom &amp;&amp; !isLoading) &#123;</span><br><span class="line">        isLoading = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Near bottom, loading more chat users&quot;</span>;</span><br><span class="line">        <span class="function">emit <span class="title">sig_loading_chat_user</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以使用QTimer稍后重置isLoading，或者在有新数据加载完成后重置</span></span><br><span class="line">        QTimer::<span class="built_in">singleShot</span>(<span class="number">1000</span>, <span class="keyword">this</span>, [<span class="keyword">this</span>]() &#123; isLoading = <span class="literal">false</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-完整的改进版本"><a href="#3-完整的改进版本" class="headerlink" title="3. 完整的改进版本"></a>3. 完整的改进版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ChatUserList::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 鼠标悬浮显示/隐藏滚动条</span></span><br><span class="line">    <span class="keyword">if</span> (watched == <span class="keyword">this</span>-&gt;<span class="built_in">viewport</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::Enter) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAsNeeded);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::Leave) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 鼠标滚轮事件</span></span><br><span class="line">    <span class="keyword">if</span> (watched == <span class="keyword">this</span>-&gt;<span class="built_in">viewport</span>() &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::Wheel) &#123;</span><br><span class="line">        QWheelEvent *wheelEvent = <span class="built_in">static_cast</span>&lt;QWheelEvent*&gt;(event);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理滚动</span></span><br><span class="line">        <span class="type">int</span> deltaY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!wheelEvent-&gt;<span class="built_in">pixelDelta</span>().<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">            deltaY = wheelEvent-&gt;<span class="built_in">pixelDelta</span>().<span class="built_in">y</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wheelEvent-&gt;<span class="built_in">angleDelta</span>().<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">            deltaY = wheelEvent-&gt;<span class="built_in">angleDelta</span>().<span class="built_in">y</span>() / <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (deltaY != <span class="number">0</span>) &#123;</span><br><span class="line">            QScrollBar *scrollBar = <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>();</span><br><span class="line">            <span class="type">int</span> newValue = scrollBar-&gt;<span class="built_in">value</span>() - deltaY;</span><br><span class="line">            scrollBar-&gt;<span class="built_in">setValue</span>(newValue);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查是否接近底部</span></span><br><span class="line">            <span class="type">static</span> <span class="type">bool</span> isLoading = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> threshold = <span class="number">50</span>; <span class="comment">// 距离底部50像素时触发</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (scrollBar-&gt;<span class="built_in">value</span>() &gt;= scrollBar-&gt;<span class="built_in">maximum</span>() - threshold &amp;&amp; !isLoading) &#123;</span><br><span class="line">                isLoading = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Loading more chat users&quot;</span>;</span><br><span class="line">                <span class="function">emit <span class="title">sig_loading_chat_user</span><span class="params">()</span></span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 1秒后重置加载状态</span></span><br><span class="line">                QTimer::<span class="built_in">singleShot</span>(<span class="number">1000</span>, <span class="keyword">this</span>, [&amp;isLoading]() &#123; isLoading = <span class="literal">false</span>; &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 阻止默认滚动行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> QListWidget::<span class="built_in">eventFilter</span>(watched, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义-ScrollBar-行为示例"><a href="#自定义-ScrollBar-行为示例" class="headerlink" title="自定义 ScrollBar 行为示例"></a>自定义 ScrollBar 行为示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义平滑滚动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatUserList::smoothScrollTo</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QScrollBar *scrollBar = <span class="keyword">this</span>-&gt;<span class="built_in">verticalScrollBar</span>();</span><br><span class="line">    <span class="type">int</span> currentValue = scrollBar-&gt;<span class="built_in">value</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建动画</span></span><br><span class="line">    QPropertyAnimation *animation = <span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(scrollBar, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    animation-&gt;<span class="built_in">setDuration</span>(<span class="number">300</span>); <span class="comment">// 300毫秒动画</span></span><br><span class="line">    animation-&gt;<span class="built_in">setStartValue</span>(currentValue);</span><br><span class="line">    animation-&gt;<span class="built_in">setEndValue</span>(value);</span><br><span class="line">    animation-&gt;<span class="built_in">setEasingCurve</span>(QEasingCurve::OutCubic); <span class="comment">// 平滑的缓动曲线</span></span><br><span class="line">    animation-&gt;<span class="built_in">start</span>(QPropertyAnimation::DeleteWhenStopped);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要的地方调用</span></span><br><span class="line"><span class="built_in">smoothScrollTo</span>(targetPosition);</span><br></pre></td></tr></table></figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong>QScrollBar</strong> 是 Qt 中管理滚动功能的控件</li>
<li>可以通过 <code>verticalScrollBar()</code> 和 <code>horizontalScrollBar()</code> 方法访问</li>
<li>重要属性：<code>value</code>（当前位置）、<code>minimum</code>&#x2F;<code>maximum</code>（范围）、<code>pageStep</code>（页面大小）</li>
<li>在你的代码中，需要正确处理滚轮事件并检查是否滚动到底部</li>
<li>添加阈值和加载状态跟踪可以防止重复加载问题</li>
<li>可以考虑使用动画实现更平滑的滚动效果</li>
</ol>
<p>通过正确使用 ScrollBar，你可以创建出用户体验良好的可滚动界面。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://brinjaul521.github.io">贺腾</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://brinjaul521.github.io/2025/09/17/Qt%E6%80%9D%E8%B7%AF/">https://brinjaul521.github.io/2025/09/17/Qt%E6%80%9D%E8%B7%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://brinjaul521.github.io" target="_blank">贺腾的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Qt%E5%BC%80%E5%8F%91/">Qt开发</a></div><div class="post-share"><div class="social-share" data-image="/img/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/17/%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86/" title="网站管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">网站管理</div></div><div class="info-2"><div class="info-item-1">一句话结论“源码”和“生成的网页”是两件东西，要分开管：  源码（markdown、主题、配置）→ 用 git push 推到 源码仓库（可选，但强烈建议）。   生成的静态文件（public 目录）→ 用 hexo d 推到 GitHub Pages 仓库（brinjaul521.github.io）。  所以标准流程是： 12345678# 1. 保存源码git add .git commit -m &quot;post: xxx&quot;git push origin main      # 推到源码仓库（如 Hexo-blog-source）# 2. 生成并发布网页hexo clean &amp;&amp; hexo ghexo d                    # 自动把 public 目录推送到 brinjaul521.github.io   常见疑问   疑问 回答    我只想要网页上线，源码要不要备份？ 最好备份，否则换电脑&#x2F;误删就哭吧。   能不能直接把源码推到 brinjaul521.github.io？ 不能，GitHub Pages ...</div></div></div></a><a class="pagination-related" href="/2025/09/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="网络编程笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">网络编程笔记</div></div><div class="info-2"><div class="info-item-1">网络编程笔记网络编程核心概念与流程详解 Socket 是什么？Socket（套接字） 是网络通信的 端点，类似于现实中的“电话”。它是操作系统提供的一种 抽象接口，允许程序通过 IP 地址 + 端口号（Port） 与其他设备进行通信。    作用：Socket 是网络数据传输的通道，负责 发送数据 和 接收数据。 类比： 电话：Socket 相当于一部手机，IP 地址相当于电话号码，端口号相当于分机号。 邮局：IP 地址是城市地址，端口号是具体收件人的门牌号。     为什么要创建 Socket？ 唯一标识通信端点：    每个 Socket 绑定一个 IP + 端口，确保数据能准确发送到目标程序。 例如：Web 服务器通常绑定 80 端口，客户端通过 IP:80 访问它。   管理通信协议：    Socket 支持不同的协议（如 TCP 可靠传输、UDP 快速但不可靠）。   操作系统资源管理：    Socket 是操作系统管理的资源，创建 Socket 相当于向系统申请通信能力。     Socket 的工作流程（以 TCP 为例）1. 服务端流程步骤 1：创建 Sock...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">贺腾</div><div class="author-info-description">我等的不是海边</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/brinjaul521/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/brinjaul521/" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1061391142@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">记录一下学习路线，顺便找个工作</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Qt%E5%BC%80%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">Qt开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A0%91%E7%BA%A7%E8%81%94%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">对象树级联问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E7%8E%B0%E5%9C%BA%E6%8E%92%E6%9F%A5-2-%E6%AD%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">🔍 现场排查 2 步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E7%A1%AE%E8%AE%A4%E6%89%93%E5%8D%B0%E7%9A%84%E5%AE%9E%E4%BE%8B-%E4%BD%A0%E7%9C%9F%E6%AD%A3-show-%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">① 确认打印的实例 &#x3D;&#x3D; 你真正 show() 的实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E7%A1%AE%E8%AE%A4%E6%B2%A1%E6%9C%89%E8%A2%AB%E7%AB%8B%E5%8D%B3%E9%9A%90%E8%97%8F"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">② 确认没有被立即隐藏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E2%80%9C%E9%9A%90%E5%BD%A2%E2%80%9D%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">✅ 最常见的“隐形”错误示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%BB%93%E8%AE%BA"><span class="toc-number">1.1.3.</span> <span class="toc-text">一句话结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.2.</span> <span class="toc-text">模态对话框设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E6%8C%87%E9%92%88%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.3.</span> <span class="toc-text">弱指针与智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 代码行为分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%8F%98%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 引用计数变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 安全性分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%97%A0%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">✅ 无循环引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E5%BC%B1%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">✅ 弱指针的安全访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E6%B3%A8%E6%84%8F%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">⚠️ 注意前提条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E7%AA%97%E5%8F%A3%EF%BC%8C%E7%AA%97%E5%8F%A3%EF%BC%8C%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">1.4.</span> <span class="toc-text">主窗口，窗口，对话框</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-QMainWindow%EF%BC%88%E2%80%9C%E7%A8%8B%E5%BA%8F%E4%B8%BB%E7%AA%97%E5%8F%A3%E2%80%9D%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. QMainWindow（“程序主窗口”）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-QWidget%EF%BC%88%E2%80%9C%E6%9C%80%E6%99%AE%E9%80%9A%E7%9A%84%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E2%80%9D%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. QWidget（“最普通的矩形区域”）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-QDialog%EF%BC%88%E2%80%9C%E5%AF%B9%E8%AF%9D%E6%A1%86%E2%80%9D%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. QDialog（“对话框”）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%80%E5%BC%A0%E8%A1%A8%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. 一张表总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%80%89%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="toc-number">1.4.5.</span> <span class="toc-text">5. 选哪个？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">事件机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">一、核心思想：事件驱动编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">二、核心组件与流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%8B%E4%BB%B6-QEvent"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1. 事件 (QEvent)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-QEventLoop"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">2. 事件循环 (QEventLoop)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E6%94%B6%E4%B8%8E%E5%A4%84%E7%90%86-QObject-event"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">3. 事件接收与处理 (QObject::event())</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%9A%E6%B7%B1%E5%85%A5-notify-%E5%92%8C-event"><span class="toc-number">1.5.3.</span> <span class="toc-text">三、事件传递的路径：深入 notify() 和 event()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">四、事件的类型与处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%8C%E6%AD%A5-vs-%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">1. 同步 vs. 异步事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%EF%BC%9AAccept-%E5%92%8C-Ignore"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">2. 事件传播：Accept 和 Ignore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%A6%82%E4%BD%95%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E4%BA%A4%E4%BA%92"><span class="toc-number">1.5.5.</span> <span class="toc-text">五、如何与事件机制交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BF%A1%E5%8F%B7%E6%A7%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.6.</span> <span class="toc-text">六、事件机制与信号槽机制的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt%E4%B8%ADconnect%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.6.</span> <span class="toc-text">Qt中connect函数的用法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">1.6.2.</span> <span class="toc-text">参数说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">连接类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Qt4%E4%B8%8EQt5%E8%AF%AD%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.4.</span> <span class="toc-text">Qt4与Qt5语法对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Qt4%E4%BC%A0%E7%BB%9F%E8%AF%AD%E6%B3%95"><span class="toc-number">1.6.5.</span> <span class="toc-text">Qt4传统语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Qt5%E6%96%B0%E8%AF%AD%E6%B3%95-%E6%8E%A8%E8%8D%90"><span class="toc-number">1.6.6.</span> <span class="toc-text">Qt5新语法(推荐)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.7.</span> <span class="toc-text">实际应用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1-%E5%9F%BA%E6%9C%AC%E4%BF%A1%E5%8F%B7%E6%A7%BD%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.6.8.</span> <span class="toc-text">示例1: 基本信号槽连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2-%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.6.9.</span> <span class="toc-text">示例2: 使用Lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B3-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%A7%BD"><span class="toc-number">1.6.10.</span> <span class="toc-text">示例3: 带参数的信号槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B4-%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.11.</span> <span class="toc-text">示例4: 连接不同线程的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B5-%E8%87%AA%E5%8A%A8%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.6.12.</span> <span class="toc-text">示例5: 自动断开连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BC%8F%E8%AF%AD%E6%B3%95%E4%BC%98%E5%8A%BF"><span class="toc-number">1.6.13.</span> <span class="toc-text">新式语法优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%87%8D%E8%BD%BD%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.6.14.</span> <span class="toc-text">处理重载信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.6.15.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.6.16.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QT-MVC%E6%A1%86%E6%9E%B6"><span class="toc-number">1.7.</span> <span class="toc-text">QT MVC框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%90%86-Custom-Delegate"><span class="toc-number">1.7.1.</span> <span class="toc-text">🔧 自定义代理 (Custom Delegate)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%84-%E5%A4%9A%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text">🔄 多个视图共享一个模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9D-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.7.3.</span> <span class="toc-text">📝 总结与建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt-QVariant-%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%B8%87%E8%83%BD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">Qt QVariant 详解：万能的数据容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A6-QVariant-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">📦 QVariant 的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-QVariant%EF%BC%9F"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">什么是 QVariant？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-QVariant%EF%BC%9F"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">为什么需要 QVariant？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%B0-QVariant-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">1.8.2.</span> <span class="toc-text">🧰 QVariant 的基本特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">支持的数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">核心功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%BB-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.3.</span> <span class="toc-text">💻 基本用法和代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">创建和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">类型检查和转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-Qt-%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">在 Qt 类中的实际应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9B%A0%EF%B8%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81"><span class="toc-number">1.8.4.</span> <span class="toc-text">🛠️ 自定义类型支持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">注册自定义类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A7-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">1.8.5.</span> <span class="toc-text">🔧 高级用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-QVariantList-%E5%92%8C-QVariantMap"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">使用 QVariantList 和 QVariantMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E9%AA%8C%E8%AF%81"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">类型转换和验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.8.6.</span> <span class="toc-text">⚠️ 注意事项和最佳实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.7.</span> <span class="toc-text">🎯 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Qt%E4%BF%A1%E5%8F%B7%E6%A7%BD%E8%B7%A8%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">Qt信号槽跨线程通信机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">基本机制概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%85%B3%E8%81%94%E6%80%A7%EF%BC%88Thread-Affinity%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 线程关联性（Thread Affinity）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B%EF%BC%88Connection-Types%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 连接类型（Connection Types）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E8%BF%9E%E6%8E%A5%EF%BC%88QueuedConnection%EF%BC%89%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.2.</span> <span class="toc-text">队列连接（QueuedConnection）机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">2.3.</span> <span class="toc-text">线程安全性与有序性保证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. 线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%89%E5%BA%8F%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. 有序性保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">3. 底层实现机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%EF%BC%88AutoConnection%EF%BC%89%E7%9A%84%E6%99%BA%E8%83%BD%E9%80%89%E6%8B%A9"><span class="toc-number">2.4.</span> <span class="toc-text">自动连接（AutoConnection）的智能选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.5.</span> <span class="toc-text">实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">2.5.1.</span> <span class="toc-text">1. 后台任务处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">2. 多生产者-单消费者模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.6.</span> <span class="toc-text">性能考虑与最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80"><span class="toc-number">2.6.1.</span> <span class="toc-text">1. 性能开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.6.2.</span> <span class="toc-text">2. 优化建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.6.3.</span> <span class="toc-text">3. 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">2.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Qt-Model-View-Delegate-%E6%A1%86%E6%9E%B6%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="toc-number">3.</span> <span class="toc-text">Qt Model-View-Delegate 框架详细说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Model-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">Model (数据模型)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Model-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">Model 的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E7%B1%BB"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">1. 基础模型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">2. 具体实现模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Model-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">Model 的核心方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A7%92%E8%89%B2-Data-Roles"><span class="toc-number">3.2.3.</span> <span class="toc-text">数据角色 (Data Roles)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.2.4.</span> <span class="toc-text">自定义模型示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View-%E8%A7%86%E5%9B%BE"><span class="toc-number">3.3.</span> <span class="toc-text">View (视图)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#View-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">View 的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E8%A7%86%E5%9B%BE%E7%B1%BB"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">1. 基础视图类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%93%E7%94%A8%E8%A7%86%E5%9B%BE%E7%BB%84%E4%BB%B6"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">2. 专用视图组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">View 的配置方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E9%80%89%E6%8B%A9%E5%A4%84%E7%90%86"><span class="toc-number">3.3.3.</span> <span class="toc-text">视图选择处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Delegate-%E5%A7%94%E6%89%98"><span class="toc-number">3.4.</span> <span class="toc-text">Delegate (委托)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Delegate-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">Delegate 的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delegate-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">Delegate 的核心方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A7%94%E6%89%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.4.3.</span> <span class="toc-text">自定义委托示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.4.4.</span> <span class="toc-text">委托使用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">协同工作机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%9AModel-%E2%86%92-View"><span class="toc-number">3.5.1.</span> <span class="toc-text">1. 数据流：Model → View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BC%96%E8%BE%91%EF%BC%9AView-%E2%86%92-Model"><span class="toc-number">3.5.2.</span> <span class="toc-text">2. 数据编辑：View → Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A8%A1%E5%9E%8B%E6%9B%B4%E6%96%B0%E9%80%9A%E7%9F%A5"><span class="toc-number">3.5.3.</span> <span class="toc-text">3. 模型更新通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%8C%E6%95%B4%E5%8D%8F%E4%BD%9C%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.5.4.</span> <span class="toc-text">4. 完整协作示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-number">3.6.</span> <span class="toc-text">高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B-Proxy-Models"><span class="toc-number">3.6.1.</span> <span class="toc-text">1. 代理模型 (Proxy Models)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8B%96%E6%94%BE%E6%94%AF%E6%8C%81"><span class="toc-number">3.6.2.</span> <span class="toc-text">2. 拖放支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%86%E5%9B%BE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">3.6.3.</span> <span class="toc-text">3. 视图选项配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.7.</span> <span class="toc-text">性能优化建议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">事件过滤器的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9D-%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">4.0.1.</span> <span class="toc-text">📝 定义与使用事件过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E5%8D%95%E4%B8%AA%E6%8E%A7%E4%BB%B6%E8%AE%BE%E7%BD%AE%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">1. 为单个控件设置事件过滤器（常用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E7%88%B6%E5%AE%B9%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%EF%BC%89"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">2. 为父容器设置事件过滤器（批量处理）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">4.0.1.3.</span> <span class="toc-text">3. 全局事件过滤器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.0.2.</span> <span class="toc-text">⚠️ 注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.0.3.</span> <span class="toc-text">💡 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8A-%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AF%B9%E6%AF%94"><span class="toc-number">4.0.4.</span> <span class="toc-text">📊 三种事件过滤器对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%B0-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.0.5.</span> <span class="toc-text">🌰 简单示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Qt-ScrollBar-%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="toc-number">5.</span> <span class="toc-text">Qt ScrollBar 详细说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ScrollBar-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">ScrollBar 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-ScrollBar%EF%BC%9F"><span class="toc-number">5.1.1.</span> <span class="toc-text">1. 什么是 ScrollBar？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ScrollBar-%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">5.1.2.</span> <span class="toc-text">2. ScrollBar 的组成部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ScrollBar-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.3.</span> <span class="toc-text">3. ScrollBar 的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8-ScrollBar"><span class="toc-number">5.2.</span> <span class="toc-text">在你的代码中使用 ScrollBar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE-ScrollBar"><span class="toc-number">5.2.1.</span> <span class="toc-text">1. 获取和设置 ScrollBar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ScrollBar-%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">2. ScrollBar 的重要属性和方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">5.3.</span> <span class="toc-text">修复你的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.1.</span> <span class="toc-text">1. 滚轮事件处理问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%94%B9%E8%BF%9B%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%A3%80%E6%B5%8B%E9%80%BB%E8%BE%91"><span class="toc-number">5.3.2.</span> <span class="toc-text">2. 改进的滚动检测逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%8C%E6%95%B4%E7%9A%84%E6%94%B9%E8%BF%9B%E7%89%88%E6%9C%AC"><span class="toc-number">5.3.3.</span> <span class="toc-text">3. 完整的改进版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-ScrollBar-%E8%A1%8C%E4%B8%BA%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.4.</span> <span class="toc-text">自定义 ScrollBar 行为示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/21/DeferredGS-%E5%92%8C-3DGS-DR%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/" title="DeferredGS 和 3DGS-DR技术对比"><img src="/2025/09/21/DeferredGS-%E5%92%8C-3DGS-DR%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/boy.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DeferredGS 和 3DGS-DR技术对比"/></a><div class="content"><a class="title" href="/2025/09/21/DeferredGS-%E5%92%8C-3DGS-DR%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/" title="DeferredGS 和 3DGS-DR技术对比">DeferredGS 和 3DGS-DR技术对比</a><time datetime="2025-09-21T12:54:26.000Z" title="发表于 2025-09-21 20:54:26">2025-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/" title="C++核心语言特性"><img src="/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/joker.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++核心语言特性"/></a><div class="content"><a class="title" href="/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/" title="C++核心语言特性">C++核心语言特性</a><time datetime="2025-09-20T13:09:58.000Z" title="发表于 2025-09-20 21:09:58">2025-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/3DGS-DR%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/" title="3DGS-DR部署及训练教程"><img src="/2025/09/19/3DGS-DR%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/pipeline.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3DGS-DR部署及训练教程"/></a><div class="content"><a class="title" href="/2025/09/19/3DGS-DR%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/" title="3DGS-DR部署及训练教程">3DGS-DR部署及训练教程</a><time datetime="2025-09-19T12:29:28.000Z" title="发表于 2025-09-19 20:29:28">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/" title="设计模式的原则"><img src="/2025/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/design.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式的原则"/></a><div class="content"><a class="title" href="/2025/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/" title="设计模式的原则">设计模式的原则</a><time datetime="2025-09-19T11:05:22.000Z" title="发表于 2025-09-19 19:05:22">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="简单工厂模式"><img src="/2025/09/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/asl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单工厂模式"/></a><div class="content"><a class="title" href="/2025/09/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="简单工厂模式">简单工厂模式</a><time datetime="2025-09-19T06:17:45.000Z" title="发表于 2025-09-19 14:17:45">2025-09-19</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 贺腾</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/bg-player.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>