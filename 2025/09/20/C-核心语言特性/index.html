<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++核心语言特性 | 贺腾的博客</title><meta name="author" content="贺腾"><meta name="copyright" content="贺腾"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++核⼼语⾔特性基础语法与概念  指针占用内存，为什么引用不一定占用内存这是一个非常经典、但又容易混淆的问题。我们来一步步拆解：   ✅ 一句话结论： 指针是一个变量，必须占用内存；而引用是别名，编译器在大多数情况下会把它优化为直接访问对象本身，因此不一定占用内存。   🔍 详细解释：1. 指针是一个变量 指针本身是一个独立的变量，存储的是另一个对象的地址。 既然它是一个变量，那它就必须占用内">
<meta property="og:type" content="article">
<meta property="og:title" content="C++核心语言特性">
<meta property="og:url" content="https://brinjaul521.github.io/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="贺腾的博客">
<meta property="og:description" content="C++核⼼语⾔特性基础语法与概念  指针占用内存，为什么引用不一定占用内存这是一个非常经典、但又容易混淆的问题。我们来一步步拆解：   ✅ 一句话结论： 指针是一个变量，必须占用内存；而引用是别名，编译器在大多数情况下会把它优化为直接访问对象本身，因此不一定占用内存。   🔍 详细解释：1. 指针是一个变量 指针本身是一个独立的变量，存储的是另一个对象的地址。 既然它是一个变量，那它就必须占用内">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://brinjaul521.github.io/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/joker.png">
<meta property="article:published_time" content="2025-09-20T13:09:58.000Z">
<meta property="article:modified_time" content="2025-09-20T13:16:10.012Z">
<meta property="article:author" content="贺腾">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://brinjaul521.github.io/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/joker.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++核心语言特性",
  "url": "https://brinjaul521.github.io/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/",
  "image": "https://brinjaul521.github.io/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/joker.png",
  "datePublished": "2025-09-20T13:09:58.000Z",
  "dateModified": "2025-09-20T13:16:10.012Z",
  "author": [
    {
      "@type": "Person",
      "name": "贺腾",
      "url": "https://brinjaul521.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://brinjaul521.github.io/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++核心语言特性',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta property="og:type" content="article">
<meta property="og:title" content="{{ title | default config.title }}">
<meta property="og:image" content="{{ url | append cover | default config.url | append '/img/default-cover.jpg' }}">
<meta property="og:description" content="{{ description | default excerpt | default config.description }}">
<meta property="og:url" content="{{ url }}">
<meta name="twitter:card" content="summary_large_image">
<meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/joker.png);"><nav id="nav"><span id="blog-info"><a href="/" title="贺腾的博客"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">贺腾的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">C++核心语言特性</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++核心语言特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-20T13:09:58.000Z" title="发表于 2025-09-20 21:09:58">2025-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-20T13:16:10.012Z" title="更新于 2025-09-20 21:16:10">2025-09-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C-核⼼语⾔特性"><a href="#C-核⼼语⾔特性" class="headerlink" title="C++核⼼语⾔特性"></a>C++核⼼语⾔特性</h1><h2 id="基础语法与概念"><a href="#基础语法与概念" class="headerlink" title="基础语法与概念"></a>基础语法与概念</h2><p><img src="/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/image-20250920201613022-1758370578583-7.png" alt="image-20250920201613022"></p>
<p><img src="/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/image-20250920202805895-1758371290083-9.png" alt="image-20250920202805895"></p>
<h3 id="指针占用内存，为什么引用不一定占用内存"><a href="#指针占用内存，为什么引用不一定占用内存" class="headerlink" title="指针占用内存，为什么引用不一定占用内存"></a>指针占用内存，为什么引用不一定占用内存</h3><p>这是一个非常经典、但又容易混淆的问题。我们来一步步拆解：</p>
<blockquote>
<hr>
<h3 id="✅-一句话结论："><a href="#✅-一句话结论：" class="headerlink" title="✅ 一句话结论："></a>✅ 一句话结论：</h3><blockquote>
<p><strong>指针是一个变量，必须占用内存；而引用是别名，编译器在大多数情况下会把它优化为直接访问对象本身，因此不一定占用内存。</strong></p>
</blockquote>
<hr>
<h3 id="🔍-详细解释："><a href="#🔍-详细解释：" class="headerlink" title="🔍 详细解释："></a>🔍 详细解释：</h3><h4 id="1-指针是一个变量"><a href="#1-指针是一个变量" class="headerlink" title="1. 指针是一个变量"></a>1. <strong>指针是一个变量</strong></h4><ul>
<li>指针本身是一个<strong>独立的变量</strong>，存储的是另一个对象的<strong>地址</strong>。</li>
<li>既然它是一个变量，那它就必须<strong>占用内存</strong>（通常是 4 字节或 8 字节，取决于平台）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;  <span class="comment">// p 是一个变量，占用内存，存储的是 a 的地址</span></span><br></pre></td></tr></table></figure>

<h4 id="2-引用是别名，不是变量"><a href="#2-引用是别名，不是变量" class="headerlink" title="2. 引用是别名，不是变量"></a>2. <strong>引用是别名，不是变量</strong></h4><ul>
<li>引用在语义上是<strong>某个对象的别名</strong>，编译器在编译阶段会把它<strong>解析为原始对象本身</strong>。</li>
<li>在<strong>大多数情况下</strong>，编译器会<strong>优化掉引用</strong>，不会为它分配额外内存。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = a;  <span class="comment">// r 是 a 的别名，编译器通常会直接替换成 a 本身</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🧠-举个例子（汇编层面）："><a href="#🧠-举个例子（汇编层面）：" class="headerlink" title="🧠 举个例子（汇编层面）："></a>🧠 举个例子（汇编层面）：</h3><h4 id="指针版本："><a href="#指针版本：" class="headerlink" title="指针版本："></a>指针版本：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line">*p = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>汇编（简化）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [a]</span><br><span class="line">lea edx, [a]</span><br><span class="line">mov [p], edx   ; 指针变量 p 占用内存，存储地址</span><br><span class="line">mov ecx, [p]</span><br><span class="line">mov [ecx], 20  ; 通过指针访问</span><br></pre></td></tr></table></figure>

<h4 id="引用版本："><a href="#引用版本：" class="headerlink" title="引用版本："></a>引用版本：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = a;</span><br><span class="line">r = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>汇编（简化）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [a], 20  // 直接操作 a，没有中间变量</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="⚠️-注意：引用可能占用内存的情况"><a href="#⚠️-注意：引用可能占用内存的情况" class="headerlink" title="⚠️ 注意：引用可能占用内存的情况"></a>⚠️ 注意：引用<strong>可能</strong>占用内存的情况</h3><p>虽然引用通常不占用内存，但在以下情况下<strong>可能会占用内存</strong>：</p>
<ol>
<li><p><strong>引用被存储在类中</strong>（作为成员变量）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span>&amp; ref;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>&amp; r) : <span class="built_in">ref</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时 <code>ref</code> 必须占用内存（通常是 4&#x2F;8 字节），因为它需要存储引用的对象地址。</p>
</li>
<li><p><strong>引用被捕获到 lambda 或 std::function 中</strong>：<br>编译器可能需要将引用包装成某种对象，间接导致内存分配。</p>
</li>
</ol>
<hr>
<h3 id="✅-总结一句话（再强调）："><a href="#✅-总结一句话（再强调）：" class="headerlink" title="✅ 总结一句话（再强调）："></a>✅ 总结一句话（再强调）：</h3><blockquote>
<p><strong>指针是变量，必须占内存；引用是别名，编译器通常优化为直接访问对象，不占内存，除非需要存储它。</strong></p>
</blockquote>
<hr>
<p>如果你想，我可以给你写个小程序，用 <code>sizeof</code> 和汇编来验证这一点。</p>
</blockquote>
<h3 id="指针到底占用多大内存"><a href="#指针到底占用多大内存" class="headerlink" title="指针到底占用多大内存"></a>指针到底占用多大内存</h3><blockquote>
<h3 id="指针占用内存大小由什么决定？"><a href="#指针占用内存大小由什么决定？" class="headerlink" title="指针占用内存大小由什么决定？"></a>指针占用内存大小由什么决定？</h3><p>指针占用的内存大小<strong>主要由操作系统和CPU架构决定</strong>，具体来说是<strong>地址总线的宽度</strong>。</p>
<ul>
<li><strong>32位系统</strong>：地址总线宽度为32位，指针占用<strong>4字节</strong>。</li>
<li><strong>64位系统</strong>：地址总线宽度为64位，指针占用<strong>8字节</strong>。</li>
</ul>
<h3 id="为什么64位机器上普通指针占用8个字节？"><a href="#为什么64位机器上普通指针占用8个字节？" class="headerlink" title="为什么64位机器上普通指针占用8个字节？"></a>为什么64位机器上普通指针占用8个字节？</h3><ul>
<li>64位机器的地址总线宽度为64位，可以寻址的内存空间为 (2^{64}) 字节。</li>
<li>为了表示这么庞大的地址空间，需要**8字节（64位）**的指针来存储地址。</li>
</ul>
<h3 id="为什么有的指针占用16个字节？"><a href="#为什么有的指针占用16个字节？" class="headerlink" title="为什么有的指针占用16个字节？"></a>为什么有的指针占用16个字节？</h3><p>在某些特殊情况下，指针可能会占用<strong>16字节</strong>，这通常与<strong>特定的应用场景、编译器实现或特殊的指针类型</strong>有关：</p>
<ul>
<li><strong>智能指针</strong>：如<code>std::shared_ptr</code>，它不仅仅是一个普通的指针，还包含一个指向控制块的指针，控制块里包含了引用计数等信息。因此，<code>std::shared_ptr</code>的总大小可能是<strong>16字节</strong>（两个指针的大小，一个指向对象，一个指向控制块）。</li>
<li><strong>多继承或虚继承</strong>：在复杂的继承体系中，指向对象的指针可能需要额外的信息来调整地址，以正确地访问对象的各个部分。这种调整可能需要额外的指针或信息，从而增加指针的大小。</li>
<li><strong>特定的内存布局或对齐要求</strong>：某些系统或编译器可能对指针的对齐有特别的要求，导致指针占用的空间增加。</li>
<li><strong>特殊的指针类型</strong>：如指向成员函数的指针，它们的大小可能与普通的对象指针不同，可能为<strong>16字节</strong>或更多，因为它们需要存储更多的信息来正确地调用函数。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>普通指针的大小</strong>主要由系统的地址总线宽度决定，64位系统上通常为<strong>8字节</strong>。</li>
<li><strong>特殊指针类型</strong>（如智能指针、指向成员函数的指针等）可能会因为额外的功能或信息而占用更多的内存，如<strong>16字节</strong>。</li>
</ul>
</blockquote>
<h3 id="当一个函数的形参是指针变量，我在调用时传入引用，或者是一个函数的形参是引用，我在调用时传入指针，会有怎样的后果呢"><a href="#当一个函数的形参是指针变量，我在调用时传入引用，或者是一个函数的形参是引用，我在调用时传入指针，会有怎样的后果呢" class="headerlink" title="当一个函数的形参是指针变量，我在调用时传入引用，或者是一个函数的形参是引用，我在调用时传入指针，会有怎样的后果呢"></a>当一个函数的形参是指针变量，我在调用时传入引用，或者是一个函数的形参是引用，我在调用时传入指针，会有怎样的后果呢</h3><blockquote>
<p>这是<strong>类型不匹配</strong>的问题，<strong>编译器会直接报错</strong>，不会让你“试试看后果”。<br>C++ 对“指针”和“引用”是两种完全不同的类别，<strong>不能隐式互换</strong>。<br>下面把两种错误场景拆开给你看：</p>
<hr>
<ol>
<li>形参是指针，你却传引用</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* p)</span></span>;   <span class="comment">// 要指针</span></span><br><span class="line"><span class="type">int</span>  x = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">foo</span>(x);             <span class="comment">// ❌ 编译错误：cannot convert ‘int’ to ‘int*’</span></span><br></pre></td></tr></table></figure>

<p>编译器信息（GCC）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: invalid conversion from ‘int’ to ‘int*’ [-fpermissive]</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：引用 <code>x</code> 本质是对象本身，类型是 <code>int</code>，与 <code>int*</code> 毫不兼容，没有自动转换。</p>
<hr>
<ol start="2">
<li>形参是引用，你却传指针</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">int</span>&amp; r)</span></span>;   <span class="comment">// 要引用</span></span><br><span class="line"><span class="type">int</span>  x = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">bar</span>(&amp;x);            <span class="comment">// ❌ 编译错误：cannot convert ‘int*’ to ‘int&amp;’</span></span><br></pre></td></tr></table></figure>

<p>编译器信息（GCC）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int*’</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：<code>&amp;x</code> 得到的是 <code>int*</code>，而函数要的是 <code>int&amp;</code>，类型不匹配；且指针值是右值，不能绑定到非 const 引用。</p>
<hr>
<p>✅ 正确写法</p>
<table>
<thead>
<tr>
<th>形参类型</th>
<th>调用时给什么</th>
</tr>
</thead>
<tbody><tr>
<td><code>int*</code></td>
<td>传 <code>&amp;x</code> 或同类型指针变量</td>
</tr>
<tr>
<td><code>int&amp;</code></td>
<td>传 <code>x</code> 本身（对象）</td>
</tr>
</tbody></table>
<hr>
<p>一句话总结<br><strong>指针与引用在语法层面互不兼容，传错即编译失败；想“混用”必须手动解址或取址，并保证类型完全匹配。</strong></p>
</blockquote>
<h3 id="类内static和类外static有什么区别"><a href="#类内static和类外static有什么区别" class="headerlink" title="类内static和类外static有什么区别"></a>类内static和类外static有什么区别</h3><blockquote>
<p>一句话先答  </p>
<ul>
<li><strong>类内 static</strong>：属于<strong>类</strong>而不属于某个对象，<strong>只在这一份类定义里共享</strong>。  </li>
<li><strong>类外 static</strong>：属于<strong>当前翻译单元（.cpp 文件）<strong>的</strong>内部链接</strong>，<strong>别的源文件看不见</strong>。</li>
</ul>
<p>下面把“生命周期、存储位置、链接属性、访问方式”逐项拆开对比，一看就懂。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>类内 static 成员</th>
<th>类外 static（全局&#x2F;函数内）</th>
</tr>
</thead>
<tbody><tr>
<td>所属实体</td>
<td>类本身</td>
<td>当前源文件（翻译单元）</td>
</tr>
<tr>
<td>存储期</td>
<td>静态&#x2F;程序整个运行期</td>
<td>同上</td>
</tr>
<tr>
<td>物理位置</td>
<td>数据段（.bss&#x2F;.data）</td>
<td>同上</td>
</tr>
<tr>
<td>链接属性</td>
<td>外部链接（符号名带类作用域）</td>
<td>内部链接（符号对外不可见）</td>
</tr>
<tr>
<td>能否跨文件访问</td>
<td>可以（通过类名::成员，且需要类外定义）</td>
<td>不可以（其他 .cpp 看不到）</td>
</tr>
<tr>
<td>是否需要类外定义</td>
<td>必须（在 .cpp 里再写一次定义，除非 C++17 内联变量）</td>
<td>不需要（本身就是定义）</td>
</tr>
<tr>
<td>典型用途</td>
<td>计数实例、类级常量、单例指针等</td>
<td>当前文件私有的全局变量&#x2F;函数</td>
</tr>
<tr>
<td>示例</td>
<td><code>class A&#123; static int cnt; &#125;;</code></td>
<td><code>static int g_cnt;</code> 或 <code>static void helper()&#123;&#125;</code></td>
</tr>
</tbody></table>
<p>再补两句容易踩坑的  </p>
<ol>
<li>类内 static <strong>不是</strong>“每个对象一份”，而是<strong>整个程序只有一份</strong>。  </li>
<li>类外 static 与匿名 namespace 效果类似，都是“内部链接”，但符号名仍占空间；C++ 项目里更推荐用匿名 namespace 代替老式的文件级 static。</li>
</ol>
<p>记住口诀：<br><strong>“类内 static 给类用，类外 static 给文件用。”</strong></p>
</blockquote>
<h2 id="关键字深度理解"><a href="#关键字深度理解" class="headerlink" title="关键字深度理解"></a>关键字深度理解</h2><blockquote>
<p>static关键字<br>局部静态变量：⽣命周期延⻓、只初始化⼀次<br>全局静态变量：⽂件作⽤域、内部链接性<br>静态成员变量：类共享、存储在数据段<br>静态成员函数：不能访问⾮静态成员、没有this指针<br>应⽤场景：单例模式、计数器、⼯⼚函数</p>
<p>const关键字<br>const变量：编译期常量、运⾏期常量<br>const指针：const int *p vs int * const p vs const int * const p<br>const成员函数：不修改对象状态、可被const对象调⽤<br>const对象：只能调⽤const成员函数<br>mutable关键字：在const成员函数中修改成员变量<br>const_cast：去除const属性（危险操作）</p>
<p>volatile关键字<br>编译器优化阻⽌：防⽌编译器优化掉变量访问<br>内存可⻅性：告诉编译器变量可能被外部修改<br>应⽤场景：硬件寄存器、信号处理、多线程共享变量<br>与atomic区别：volatile不保证原⼦性<br>与const关系：const volatile组合使⽤</p>
<p>virtual关键字<br>虚函数机制：动态绑定、运⾏时多态<br>虚函数表(vtable)：每个类⼀个vtable、虚函数指针数组<br>虚函数指针(vptr)：每个对象包含vptr、指向对应vtable<br>纯虚函数：&#x3D; 0声明、抽象基类、不能实例化<br>虚析构函数：基类指针删除派⽣类对象、防⽌内存泄漏<br>虚继承：解决菱形继承、共享基类实例</p>
<p>inline关键字<br>内联函数原理：编译时代码替换、减少函数调⽤开销<br>优点：性能提升、避免函数调⽤开销缺点：代码膨胀、编译时间增加、调试困难<br>内联失效：递归函数、虚函数、函数指针调⽤<br>编译器优化：现代编译器⾃动内联优化<br>最佳实践：⼩函数、频繁调⽤、不超过10⾏代码</p>
<p>explicit关键字<br>防⽌隐式转换：单参数构造函数、转换运算符<br>使⽤场景：避免意外的类型转换、提⾼代码安全性<br>explicit构造函数：必须显式调⽤构造函数<br>explicit转换运算符：C++11新特性<br>最佳实践：除⾮确实需要隐式转换，否则都加explicit</p>
</blockquote>
<p>好的，我们来详细展开讲解这些C++核心关键字和概念。这对于理解C++的底层机制和编写高质量代码至关重要。</p>
<hr>
<h3 id="1-static-关键字"><a href="#1-static-关键字" class="headerlink" title="1. static 关键字"></a>1. <code>static</code> 关键字</h3><p><code>static</code> 的含义是“静态的”，它在不同上下文中有不同的作用，但核心思想是<strong>与特定实例解耦，具有“唯一性”和“持久性”</strong>。</p>
<h4 id="a-局部静态变量-Local-Static-Variables"><a href="#a-局部静态变量-Local-Static-Variables" class="headerlink" title="a. 局部静态变量 (Local Static Variables)"></a>a. 局部静态变量 (Local Static Variables)</h4><ul>
<li><p><strong>生命周期延长</strong>： 普通局部变量在函数调用结束时被销毁。而局部静态变量的生命周期从第一次执行声明语句开始，直到整个程序结束。</p>
</li>
<li><p><strong>只初始化一次</strong>： 初始化语句（如 <code>static int x = 5;</code>）仅在第一次执行时进行，后续的函数调用会跳过初始化，直接使用之前的值。</p>
</li>
<li><p><strong>存储位置</strong>： 存储在全局数据区（数据段），而非栈区。</p>
</li>
<li><p><strong>应用场景</strong>： 用于在函数调用之间保持状态，比如计数器、第一次使用的延迟初始化（Meyers’ Singleton）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 只初始化一次</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">counter</span>(); <span class="comment">// 输出 1</span></span><br><span class="line">    <span class="built_in">counter</span>(); <span class="comment">// 输出 2</span></span><br><span class="line">    <span class="built_in">counter</span>(); <span class="comment">// 输出 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b-全局静态变量-函数-Global-Static-Variables-Functions"><a href="#b-全局静态变量-函数-Global-Static-Variables-Functions" class="headerlink" title="b. 全局静态变量&#x2F;函数 (Global Static Variables&#x2F;Functions)"></a>b. 全局静态变量&#x2F;函数 (Global Static Variables&#x2F;Functions)</h4><ul>
<li><p><strong>文件作用域 (File Scope)</strong>： 用 <code>static</code> 修饰的全局变量或函数，其链接性 (Linkage) 为<strong>内部链接性</strong>。</p>
</li>
<li><p><strong>内部链接性</strong>： 这意味着该变量&#x2F;函数仅在<strong>定义它的源文件（.cpp）内可见</strong>，其他源文件无法通过 <code>extern</code> 声明来访问它。这有效避免了命名冲突和意外的跨文件访问，是封装性的体现。</p>
</li>
<li><p><strong>与普通全局变量的区别</strong>： 普通全局变量是 <code>extern</code>（外部链接性）的，所有源文件可见，容易造成命名污染。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File1.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> localVar = <span class="number">42</span>; <span class="comment">// 只在 File1.cpp 中可见</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">localFunc</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 只在 File1.cpp 中可见</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> localVar; <span class="comment">// 错误！无法链接到 File1.cpp 的 localVar</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="c-静态成员变量-Static-Member-Variables"><a href="#c-静态成员变量-Static-Member-Variables" class="headerlink" title="c. 静态成员变量 (Static Member Variables)"></a>c. 静态成员变量 (Static Member Variables)</h4><ul>
<li><p><strong>类共享</strong>： 它不属于任何一个类的对象，而是属于整个类。所有该类的对象<strong>共享</strong>同一份静态成员变量。</p>
</li>
<li><p><strong>存储在数据段</strong>： 和全局变量一样，存储在程序的数据段。</p>
</li>
<li><p><strong>初始化</strong>： 必须在<strong>类外</strong>（通常在源文件.cpp中）进行单独的定义和初始化（编译器需要为其分配存储空间）。</p>
</li>
<li><p><strong>应用场景</strong>： 统计类创建的对象数量、类的配置参数、所有对象共享的缓存等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 声明</span></span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; count++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>; <span class="comment">// 定义并初始化（必须放在类外）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1, obj2;</span><br><span class="line">    std::cout &lt;&lt; MyClass::count; <span class="comment">// 输出 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="d-静态成员函数-Static-Member-Functions"><a href="#d-静态成员函数-Static-Member-Functions" class="headerlink" title="d. 静态成员函数 (Static Member Functions)"></a>d. 静态成员函数 (Static Member Functions)</h4><ul>
<li><p><strong>没有 <code>this</code> 指针</strong>： 因为它不属于任何特定对象，所以没有 <code>this</code> 指针。</p>
</li>
<li><p><strong>只能访问静态成员</strong>： 正因为没有 <code>this</code>，它无法直接访问类的普通成员变量和函数（这些都需要通过 <code>this</code> 指针来访问）。它只能访问其他的静态成员（变量或函数）。</p>
</li>
<li><p><strong>调用方式</strong>： 可以通过类名直接调用（<code>ClassName::StaticFunction()</code>），也可以通过对象调用（<code>obj.StaticFunction()</code>）。</p>
</li>
<li><p><strong>应用场景</strong>： 用于操作静态成员变量、创建工具函数、工厂函数（不依赖对象状态）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_value;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getStatic</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_value; &#125; <span class="comment">// OK</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 错误！无法访问非静态成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="应用场景总结"><a href="#应用场景总结" class="headerlink" title="应用场景总结"></a><strong>应用场景总结</strong></h4><ul>
<li><p><strong>单例模式 (Singleton)</strong>： 利用局部静态变量实现线程安全的单例（C++11后）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 保证只初始化一次</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除拷贝构造函数和赋值运算符</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 私有化构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>计数器</strong>： 如上文例子，统计对象数量。</p>
</li>
<li><p><strong>工厂函数</strong>： 静态成员函数可以根据输入参数创建并返回不同的对象。</p>
</li>
</ul>
<hr>
<h3 id="2-const-关键字"><a href="#2-const-关键字" class="headerlink" title="2. const 关键字"></a>2. <code>const</code> 关键字</h3><p><code>const</code> 的含义是“常量”，它告诉编译器和一个意图：<strong>这个对象或值不应该被修改</strong>。编译器会帮你 enforcing（强制执行）这个规则。</p>
<h4 id="a-const变量"><a href="#a-const变量" class="headerlink" title="a. const变量"></a>a. const变量</h4><ul>
<li><strong>编译期常量 (Compile-time Constant)</strong>： 值在编译期就知道（如 <code>const int size = 100;</code>），可以用来定义数组大小。它可能被编译器优化，直接用值替换。</li>
<li><strong>运行期常量 (Run-time Constant)</strong>： 值在运行时才能确定（如 <code>const int x = getValue();</code>），仍然是只读的。</li>
</ul>
<h4 id="b-const指针-区分原则：const-在-的左边还是右边"><a href="#b-const指针-区分原则：const-在-的左边还是右边" class="headerlink" title="b. const指针 - 区分原则：const 在 * 的左边还是右边"></a>b. const指针 - 区分原则：<code>const</code> 在 <code>*</code> 的左边还是右边</h4><ul>
<li><code>const int *p</code> (或 <code>int const *p</code>)： <strong>指向常量的指针 (Pointer to const)</strong>。<code>p</code> 指向的内存内容不可通过 <code>p</code> 修改，但 <code>p</code> 本身可以指向别的地址。<br><code>const int *p = &amp;a; *p = 10; // 错误！ p = &amp;b; // 正确</code></li>
<li><code>int * const p</code>： <strong>常量指针 (Const pointer)</strong>。<code>p</code> 本身（存储的地址）不可修改，但它指向的内存内容可以修改。<br><code>int * const p = &amp;a; p = &amp;b; // 错误！ *p = 10; // 正确</code></li>
<li><code>const int * const p</code>： <strong>指向常量的常量指针</strong>。<code>p</code> 本身和它指向的内容都不可修改。</li>
</ul>
<h4 id="c-const成员函数"><a href="#c-const成员函数" class="headerlink" title="c. const成员函数"></a>c. const成员函数</h4><ul>
<li><p><strong>不修改对象状态</strong>： 在成员函数声明的参数列表后加上 <code>const</code>，承诺这个函数不会修改调用它的对象的任何非静态成员变量（除非成员被 <code>mutable</code> 修饰）。</p>
</li>
<li><p><strong>可被const对象调用</strong>： const对象只能调用const成员函数，这是保证对象状态不被修改的关键机制。</p>
</li>
<li><p><strong>重载依据</strong>： <code>void func() const;</code> 和 <code>void func();</code> 可以构成重载。const对象调用const版本，非const对象调用非const版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> cache; <span class="comment">// 即使在const函数中也可被修改</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// const成员函数</span></span><br><span class="line">        <span class="comment">// value = 10; // 错误！不允许修改成员</span></span><br><span class="line">        cache = <span class="number">20</span>;      <span class="comment">// 正确，因为cache是mutable的</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="d-const对象"><a href="#d-const对象" class="headerlink" title="d. const对象"></a>d. const对象</h4><ul>
<li><code>const MyClass obj;</code></li>
<li>对象自创建后，其所有成员变量的值都不能再被修改。</li>
<li>只能调用该对象的const成员函数。</li>
</ul>
<h4 id="e-mutable-关键字"><a href="#e-mutable-关键字" class="headerlink" title="e. mutable 关键字"></a>e. mutable 关键字</h4><ul>
<li><strong>突破const限制</strong>： 用于修饰类的成员变量。被 <code>mutable</code> 修饰的变量，即使在 <code>const</code> 成员函数中，也可以被修改。</li>
<li><strong>应用场景</strong>： 用于一些不影响对象“逻辑状态”的成员，例如缓存（cache）、调试计数、互斥锁（mutex，因为加锁解锁操作本身就需要改变锁的状态）。</li>
</ul>
<h4 id="f-const-cast-运算符"><a href="#f-const-cast-运算符" class="headerlink" title="f. const_cast 运算符"></a>f. const_cast 运算符</h4><ul>
<li><p><strong>去除const属性</strong>： <code>const_cast&lt;Type&amp;&gt;(const_object)</code> 可以去除对象的const限定符。</p>
</li>
<li><p><strong>危险操作</strong>： 只能用在你<strong>确定</strong>一个原本不是const的对象被const引用指向了，而现在需要修改它时。如果原对象本身是const的，修改它是<strong>未定义行为 (Undefined Behavior)</strong>，通常会导致程序崩溃。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123; std::cout &lt;&lt; str; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *c = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// print(c); // 错误：无法将‘const char*’转换为‘char*’</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(c)); <span class="comment">// 危险！但如果字符串字面量是只读的，这可能崩溃。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-volatile-关键字"><a href="#3-volatile-关键字" class="headerlink" title="3. volatile 关键字"></a>3. <code>volatile</code> 关键字</h3><p><code>volatile</code> 的含义是“易变的”，它主要目的是<strong>阻止编译器进行激进的优化</strong>，因为变量可能会被程序本身之外的因素改变。</p>
<h4 id="a-编译器优化阻止"><a href="#a-编译器优化阻止" class="headerlink" title="a. 编译器优化阻止"></a>a. 编译器优化阻止</h4><ul>
<li>编译器优化通常会把频繁访问的变量值加载到寄存器中，后续访问直接读寄存器，以提高速度。</li>
<li>对于 <code>volatile</code> 变量，编译器每次必须<strong>从内存中重新读取它的值</strong>，而不是使用寄存器中的缓存。写操作也必须立即写回内存。</li>
</ul>
<h4 id="b-内存可见性"><a href="#b-内存可见性" class="headerlink" title="b. 内存可见性"></a>b. 内存可见性</h4><ul>
<li>告诉编译器，这个变量的值可能在任何时候被外部硬件、操作系统内核、或其他线程改变。因此，不能对它的访问做假设。</li>
</ul>
<h4 id="c-应用场景"><a href="#c-应用场景" class="headerlink" title="c. 应用场景"></a>c. 应用场景</h4><ol>
<li><strong>硬件寄存器</strong>： 映射到内存地址的硬件设备寄存器（如状态寄存器），其值由硬件设备改变。</li>
<li><strong>信号处理</strong>： 在信号处理函数中修改的全局变量。</li>
<li><strong>多线程共享变量 (传统方式，现已不推荐)</strong>： 在缺乏其他同步机制（如<code>std::atomic</code>或<code>mutex</code>）的老代码中，用于标记被多个线程共享的变量。<strong>注意：<code>volatile</code> 不能替代现代的线程同步工具！</strong></li>
</ol>
<h4 id="d-与-std-atomic-的区别"><a href="#d-与-std-atomic-的区别" class="headerlink" title="d. 与 std::atomic 的区别"></a>d. 与 <code>std::atomic</code> 的区别</h4><p>这是非常重要的区别！</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>volatile</code></th>
<th align="left"><code>std::atomic</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>原子性</strong></td>
<td align="left"><strong>不保证</strong></td>
<td align="left"><strong>保证</strong></td>
</tr>
<tr>
<td align="left"><strong>内存顺序</strong></td>
<td align="left"><strong>不保证</strong>（乱序执行可能发生）</td>
<td align="left">提供严格的内存顺序保证（如<code>memory_order_relaxed</code>等）</td>
</tr>
<tr>
<td align="left"><strong>主要目的</strong></td>
<td align="left">禁用编译器优化，保证每次访问内存</td>
<td align="left">提供多线程环境下的安全、无数据竞争的访问</td>
</tr>
</tbody></table>
<p><strong>简单说：<code>volatile</code> 解决的是“编译器不知道值会变”的问题，而 <code>atomic</code> 解决的是“CPU执行时可能发生数据竞争”的问题。</strong> 在现代C++多线程编程中，应该使用 <code>std::atomic</code> 来保护共享数据。</p>
<h4 id="e-与-const-的关系"><a href="#e-与-const-的关系" class="headerlink" title="e. 与 const 的关系"></a>e. 与 <code>const</code> 的关系</h4><p>可以组合使用：<code>const volatile int* p;</code><br>这表示 <code>p</code> 指向一个既是常量又是易变的内存位置。</p>
<ul>
<li><strong>程序不能通过 <code>p</code> 修改它</strong>（const）。</li>
<li><strong>但它的值可能被外部改变，所以编译器不能优化对其的访问</strong>（volatile）。</li>
<li><strong>场景</strong>： 指向一个只读硬件状态寄存器的指针。</li>
</ul>
<hr>
<h3 id="4-virtual-关键字"><a href="#4-virtual-关键字" class="headerlink" title="4. virtual 关键字"></a>4. <code>virtual</code> 关键字</h3><p><code>virtual</code> 用于实现 C++ 的<strong>动态多态（运行时多态）</strong>，是面向对象编程的核心。</p>
<h4 id="a-虚函数机制-Virtual-Functions"><a href="#a-虚函数机制-Virtual-Functions" class="headerlink" title="a. 虚函数机制 (Virtual Functions)"></a>a. 虚函数机制 (Virtual Functions)</h4><ul>
<li><strong>动态绑定 (Dynamic Binding)</strong> &#x2F; <strong>晚期绑定 (Late Binding)</strong>： 使用基类的指针或引用来调用一个虚函数时，程序会在<strong>运行时</strong>根据该指针或引用实际指向的对象的类型来决定调用哪个版本的函数（基类还是派生类的）。</li>
<li><strong>与静态绑定的区别</strong>： 非虚函数在编译期就根据指针&#x2F;引用的类型确定了要调用的函数。</li>
</ul>
<h4 id="b-虚函数表-vtable-和虚函数指针-vptr"><a href="#b-虚函数表-vtable-和虚函数指针-vptr" class="headerlink" title="b. 虚函数表 (vtable) 和虚函数指针 (vptr)"></a>b. 虚函数表 (vtable) 和虚函数指针 (vptr)</h4><p>这是实现多态的底层机制。</p>
<ul>
<li><strong>虚函数表 (vtable)</strong>： 编译器会为<strong>每一个包含虚函数的类</strong>生成一个虚函数表。它是一个函数指针数组，存放着这个类所有虚函数的地址。</li>
<li><strong>虚函数指针 (vptr)</strong>： 编译器会为<strong>每一个包含虚函数的类的对象</strong>隐式地添加一个指针成员（vptr）。在对象构造时，这个vptr会被设置为指向该对象所属类的vtable。</li>
<li><strong>调用过程</strong>： 当通过基类指针调用虚函数 <code>p-&gt;func()</code> 时，编译器会生成代码：<ol>
<li>通过 <code>p</code> 找到对象的 vptr。</li>
<li>通过 vptr 找到类的 vtable。</li>
<li>在 vtable 中找到 <code>func</code> 的地址。</li>
<li>调用该地址的函数。</li>
</ol>
</li>
</ul>
<h4 id="c-纯虚函数-Pure-Virtual-Functions-和抽象基类-Abstract-Base-Classes"><a href="#c-纯虚函数-Pure-Virtual-Functions-和抽象基类-Abstract-Base-Classes" class="headerlink" title="c. 纯虚函数 (Pure Virtual Functions) 和抽象基类 (Abstract Base Classes)"></a>c. 纯虚函数 (Pure Virtual Functions) 和抽象基类 (Abstract Base Classes)</h4><ul>
<li><strong>纯虚函数</strong>： 在声明末尾加上 <code>= 0</code>（如 <code>virtual void func() = 0;</code>）。该类<strong>抽象基类</strong>。</li>
<li><strong>抽象基类</strong>： 包含至少一个纯虚函数的类。它不能创建实例对象。它的作用是定义接口，强制其派生类去实现这些接口。</li>
</ul>
<h4 id="d-虚析构函数-Virtual-Destructors"><a href="#d-虚析构函数-Virtual-Destructors" class="headerlink" title="d. 虚析构函数 (Virtual Destructors)"></a>d. 虚析构函数 (Virtual Destructors)</h4><ul>
<li><p><strong>为什么重要</strong>： 如果基类的析构函数不是虚的，那么当你 <code>delete</code> 一个基类指针（该指针实际指向一个派生类对象）时，<strong>只会调用基类的析构函数</strong>，而不会调用派生类的析构函数，导致派生类的资源泄漏。</p>
</li>
<li><p><strong>规则</strong>： 如果一个类打算被继承（作为基类），那么它的析构函数<strong>必须</strong>声明为虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base dtor\n&quot;</span>; &#125; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived dtor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 输出： Derived dtor \n Base dtor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="e-虚继承-Virtual-Inheritance"><a href="#e-虚继承-Virtual-Inheritance" class="headerlink" title="e. 虚继承 (Virtual Inheritance)"></a>e. 虚继承 (Virtual Inheritance)</h4><ul>
<li><p><strong>解决问题</strong>： <strong>菱形继承（Diamond Problem）</strong> 导致的二义性和数据冗余。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"> / \</span><br><span class="line">B   C</span><br><span class="line"> \ /</span><br><span class="line">  D</span><br></pre></td></tr></table></figure>

<p>普通继承下，<code>D</code> 类会包含两份 <code>A</code> 类的成员。</p>
</li>
<li><p><strong>虚继承</strong>： 让 <code>B</code> 和 <code>C</code> 虚继承自 <code>A</code>（<code>class B : virtual public A</code>）。这样，在 <code>D</code> 中只会保留一份 <code>A</code> 的实例。<code>D</code> 负责直接初始化 <code>A</code>。</p>
</li>
</ul>
<hr>
<h3 id="5-inline-关键字"><a href="#5-inline-关键字" class="headerlink" title="5. inline 关键字"></a>5. <code>inline</code> 关键字</h3><p><code>inline</code> 是对编译器的<strong>建议</strong>，建议将函数调用展开为函数体本身的代码，以消除函数调用的开销。</p>
<h4 id="a-原理"><a href="#a-原理" class="headerlink" title="a. 原理"></a>a. 原理</h4><ul>
<li>编译器在编译时，尝试将 <code>inline</code> 函数的代码直接插入到每一个调用点，从而避免函数调用（参数压栈、跳转、返回等）的开销。</li>
<li><strong>最终是否内联，由编译器决定</strong>。<code>inline</code> 关键字只是一个强烈的暗示。</li>
</ul>
<h4 id="b-优点"><a href="#b-优点" class="headerlink" title="b. 优点"></a>b. 优点</h4><ul>
<li><strong>性能提升</strong>： 对于短小精悍、频繁调用的函数，消除函数调用开销能带来性能提升。</li>
</ul>
<h4 id="c-缺点"><a href="#c-缺点" class="headerlink" title="c. 缺点"></a>c. 缺点</h4><ul>
<li><strong>代码膨胀</strong>： 如果函数体很大且在多个地方被调用，内联会导致最终的可执行文件体积显著增大。这可能会降低指令缓存命中率，反而降低性能。</li>
<li><strong>编译时间增加</strong>： 头文件中定义的函数通常需要被内联，这意味着函数实现放在头文件中，任何包含该头文件的源文件修改都会导致该函数被重新编译。</li>
<li><strong>调试困难</strong>： 内联函数没有清晰的调用栈。</li>
</ul>
<h4 id="d-内联失效的情况（编译器通常不会内联）"><a href="#d-内联失效的情况（编译器通常不会内联）" class="headerlink" title="d. 内联失效的情况（编译器通常不会内联）"></a>d. 内联失效的情况（编译器通常不会内联）</h4><ul>
<li>递归函数</li>
<li>函数体内包含循环或复杂控制流（switch， goto）</li>
<li>通过函数指针调用的函数</li>
<li>虚函数（因为运行时才能确定调用哪个，无法在编译期展开）</li>
</ul>
<h4 id="e-现代编译器的优化"><a href="#e-现代编译器的优化" class="headerlink" title="e. 现代编译器的优化"></a>e. 现代编译器的优化</h4><p>现代编译器非常智能，即使没有 <code>inline</code> 关键字，也会自动对合适的函数进行内联优化。反之，即使你写了 <code>inline</code>，编译器也可能拒绝内联。</p>
<h4 id="f-最佳实践"><a href="#f-最佳实践" class="headerlink" title="f. 最佳实践"></a>f. 最佳实践</h4><ul>
<li>将小（如1-5行）、频繁调用、不复杂的函数声明为 <code>inline</code>。</li>
<li>通常将 <code>inline</code> 函数的<strong>定义</strong>直接放在头文件（.hpp）中。</li>
<li>优先使用类内定义的成员函数，它们默认是内联的候选。</li>
</ul>
<hr>
<h3 id="6-explicit-关键字"><a href="#6-explicit-关键字" class="headerlink" title="6. explicit 关键字"></a>6. <code>explicit</code> 关键字</h3><p><code>explicit</code> 用于修饰构造函数或转换函数，防止编译器进行<strong>隐式类型转换</strong>，要求代码必须是<strong>显式</strong>的。</p>
<h4 id="a-防止隐式转换"><a href="#a-防止隐式转换" class="headerlink" title="a. 防止隐式转换"></a>a. 防止隐式转换</h4><ul>
<li><p><strong>单参数构造函数</strong>： 过去，如果一个构造函数只需要一个参数，它就成为一个隐式转换函数。这可能导致意外的行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">int</span> size) &#123; ... &#125; <span class="comment">// 允许从int隐式转换为MyString</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayString</span><span class="params">(<span class="type">const</span> MyString&amp; s)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">displayString</span>(<span class="number">10</span>); <span class="comment">// 编译器会隐式调用 MyString(10)！这可能不是我们想要的。</span></span><br><span class="line">    <span class="built_in">displayString</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 错误，没有匹配的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上 <code>explicit</code> 后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyString</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayString</span><span class="params">(<span class="type">const</span> MyString&amp; s)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// displayString(10); // 错误！不允许隐式转换</span></span><br><span class="line">    <span class="built_in">displayString</span>(<span class="built_in">MyString</span>(<span class="number">10</span>)); <span class="comment">// 正确，必须显式转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换运算符 (C++11)</strong>： C++11 允许对转换运算符也使用 <code>explicit</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartBool</span> &#123;</span><br><span class="line">    <span class="type">bool</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// 显式转换为bool</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">SmartBool sb;</span><br><span class="line"><span class="comment">// if (sb) ...        // 正确：在if/while等语境下，上下文转换是允许的</span></span><br><span class="line"><span class="comment">// bool b = sb;       // 错误：需要显式转换</span></span><br><span class="line"><span class="comment">// int i = sb + 1;    // 错误：需要显式转换</span></span><br><span class="line"><span class="type">bool</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(sb); <span class="comment">// 正确：显式转换</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b-最佳实践"><a href="#b-最佳实践" class="headerlink" title="b. 最佳实践"></a>b. 最佳实践</h4><ul>
<li><strong>除非你有充分的理由需要隐式转换，否则应将单参数构造函数都声明为 <code>explicit</code></strong>。这可以提高代码的安全性、可读性和可维护性，避免难以察觉的bug。</li>
<li><code>std::vector</code> 的 <code>explicit vector(size_type count)</code> 就是一个经典例子，防止了 <code>void f(const vector&lt;int&gt;&amp; v); f(10);</code> 这种意外的调用（本意可能是创建一个包含10个元素的vector，但实际可能是想调用 <code>f(10)</code> ？这很可能是错误）。</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="new-delete操作符：new-operator、operator-new、placement-new区别"><a href="#new-delete操作符：new-operator、operator-new、placement-new区别" class="headerlink" title="new&#x2F;delete操作符：new operator、operator new、placement new区别"></a>new&#x2F;delete操作符：new operator、operator new、placement new区别</h3><blockquote>
<pre><code>把这三兄弟拆成 **“名字像、分工不同”** 的三层，一张表先看清：
</code></pre>
<table>
<thead>
<tr>
<th>名字</th>
<th>本质</th>
<th>谁提供的</th>
<th>干的事</th>
<th>会不会调构造函数</th>
</tr>
</thead>
<tbody><tr>
<td><code>new operator</code>（俗称 <strong>new 表达式</strong>）</td>
<td>语言内置表达式</td>
<td>编译器</td>
<td>①调 <code>operator new</code> 分配内存 ②调构造函数</td>
<td>✅</td>
</tr>
<tr>
<td><code>operator new</code></td>
<td>可重载函数</td>
<td>标准库&#x2F;你自己</td>
<td>只分配<strong>原始未初始化</strong>内存，像 <code>malloc</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>placement new</code></td>
<td><code>operator new</code> 的重载版本</td>
<td>标准库</td>
<td><strong>在已有一块内存</strong>上“构造”对象，不分配</td>
<td>✅（只干构造）</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-new-operator-——-我们天天写的-T-p-new-T"><a href="#1-new-operator-——-我们天天写的-T-p-new-T" class="headerlink" title="1. new operator —— 我们天天写的 T* p = new T;"></a>1. <code>new operator</code> —— 我们天天写的 <code>T* p = new T;</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo* p = <span class="keyword">new</span> <span class="built_in">Foo</span>(<span class="number">123</span>);   <span class="comment">// 编译器展开成两步：</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* raw = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Foo));  <span class="comment">// ① 分配</span></span><br><span class="line">Foo*  p   = <span class="built_in">static_cast</span>&lt;Foo*&gt;(raw);</span><br><span class="line"><span class="keyword">new</span>(p) <span class="built_in">Foo</span>(<span class="number">123</span>);                        <span class="comment">// ② 构造（调用 placement new）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>你不能阻止它调构造函数，也无法改变这两步顺序。  </li>
<li>想只换“分配方式”——重载 <code>operator new</code>；<br>想连“构造方式”也干预——自己写 <code>placement new</code> 并手动两步。</li>
</ul>
<hr>
<h3 id="2-operator-new-——-纯粹的“内存分配器”"><a href="#2-operator-new-——-纯粹的“内存分配器”" class="headerlink" title="2. operator new —— 纯粹的“内存分配器”"></a>2. <code>operator new</code> —— 纯粹的“内存分配器”</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* raw = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Foo)); <span class="comment">// 仅得到一块原始 bytes</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值是 <code>void*</code>，<strong>不会</strong>调构造函数。  </li>
<li>可全局重载，也可给类单独重载：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> n)</span></span>;  <span class="comment">// 只影响 Foo 的 new 表达式</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>对应释放函数是 <code>operator delete</code>，同理只释放内存，不析构。</li>
</ul>
<hr>
<h3 id="3-placement-new-——-“定点构造”神器"><a href="#3-placement-new-——-“定点构造”神器" class="headerlink" title="3. placement new —— “定点构造”神器"></a>3. <code>placement new</code> —— “定点构造”神器</h3><p>标准库提供的重载之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span>          <span class="comment">// 必须头文件</span></span></span><br><span class="line"><span class="type">char</span> buf[<span class="built_in">sizeof</span>(Foo)];  <span class="comment">// 栈上/共享内存/池里已有一块内存</span></span><br><span class="line">Foo* p = <span class="built_in">new</span> (buf) <span class="built_in">Foo</span>(<span class="number">42</span>);  <span class="comment">// 只在 buf 上调用构造函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>不分配</strong>、<strong>不释放</strong>，只返回那块地址并调构造函数。  </li>
<li>对象用完必须<strong>手动调用析构</strong>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;~<span class="built_in">Foo</span>();              <span class="comment">// 析构</span></span><br><span class="line"><span class="comment">// 内存归你管，后续再用或释放都自己决定</span></span><br></pre></td></tr></table></figure>

<ul>
<li>名字 “placement” 就是“放置”之意——“把对象放到我指定的地方”。</li>
</ul>
<hr>
<h3 id="一张图总结流程"><a href="#一张图总结流程" class="headerlink" title="一张图总结流程"></a>一张图总结流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Foo(123) 表达式</span><br><span class="line">   ├─→ operator new(sizeof(Foo))      分配</span><br><span class="line">   └─→ placement new(ptr) Foo(123)   构造</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见误区提醒"><a href="#常见误区提醒" class="headerlink" title="常见误区提醒"></a>常见误区提醒</h3><ol>
<li><p><code>placement new</code> 出来的对象<strong>禁止</strong>直接用 <code>delete</code>！<br>会重复释放同一块内存 → UB。<br>正确：先显式析构，再自己处理那块内存。</p>
</li>
<li><p>数组版本也有对应物：<br><code>new Foo[n]</code> → <code>operator new[]</code> → <code>placement new[]</code>（少见，原理相同）。</p>
</li>
<li><p>全局重载 <code>operator new</code> 影响<strong>所有</strong> new 表达式，慎用；类作用域重载只影响该类。</p>
</li>
</ol>
<p>记住三句话：  </p>
<ul>
<li><strong>new 表达式</strong> &#x3D; 分配 + 构造，一步到位。  </li>
<li><strong>operator new</strong> &#x3D; 裸分配，可重载，不构造。  </li>
<li><strong>placement new</strong> &#x3D; 只构造，不分配，内存你说了算。</li>
</ul>
</blockquote>
<h3 id="智能指针：shared-ptr、unique-ptr、weak-ptr实现原理讲解一下"><a href="#智能指针：shared-ptr、unique-ptr、weak-ptr实现原理讲解一下" class="headerlink" title="智能指针：shared_ptr、unique_ptr、weak_ptr实现原理讲解一下"></a>智能指针：shared_ptr、unique_ptr、weak_ptr实现原理讲解一下</h3><p>把三种智能指针拆成“<strong>一条时间线 + 一张控制块图 + 三条代码路径</strong>”，就能一次性看懂它们的核心原理。</p>
<hr>
<p>一、共享所有权模型总览（64 位机器为例）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">     ┌----------------------┐</span><br><span class="line">     │   control block      │&lt;------┐</span><br><span class="line">     │----------------------│       │</span><br><span class="line">     │  shared_count  (atomic) │ 1   │  weak_ptr 也来</span><br><span class="line">     │  weak_count    (atomic) │ 1   │  指向同一块</span><br><span class="line">     │  deleter / allocator     │     │</span><br><span class="line">     │  virtual dtor  ptr       │     │</span><br><span class="line">     └----------------------┘       │</span><br><span class="line">              ▲                     │</span><br><span class="line">              │                     │</span><br><span class="line">shared_ptr --┘                     │</span><br><span class="line">              │                     │</span><br><span class="line">object  ---------------------------┘</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>control block</strong> 与对象可以<strong>分块</strong>（<code>make_shared</code> 会把它们拼成一整块，性能更好）。  </li>
<li>两个原子计数：<br>– <code>shared_count</code>：有多少个 <code>shared_ptr</code> 活着。<br>– <code>weak_count</code>：有多少个 <code>weak_ptr</code> 活着；当 <code>shared_count==0</code> 时对象析构，但 control block 要等 <code>weak_count==0</code> 才释放。</li>
</ul>
<hr>
<p>二、逐个拆解实现原理</p>
<ol>
<li><code>shared_ptr&lt;T&gt;</code> —— “引用计数的句柄”</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line">    T*        ptr;          <span class="comment">// 裸指针</span></span><br><span class="line">    ControlBlock* ctrl;     <span class="comment">// 指向控制块</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* p) &#123;</span><br><span class="line">        ptr  = p;</span><br><span class="line">        ctrl = <span class="keyword">new</span> ControlBlock&#123;p, <span class="number">1</span>, <span class="number">1</span>&#125;; <span class="comment">// 第一次 shared_count=1, weak_count=1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        ptr  = rhs.ptr;</span><br><span class="line">        ctrl = rhs.ctrl;</span><br><span class="line">        ctrl-&gt;shared_count.<span class="built_in">fetch_add</span>(<span class="number">1</span>, memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctrl-&gt;shared_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, memory_order_acq_rel) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 最后一次释放</span></span><br><span class="line">            <span class="keyword">delete</span> ptr;                 <span class="comment">// 先析构对象</span></span><br><span class="line">            <span class="keyword">if</span> (ctrl-&gt;weak_count.<span class="built_in">load</span>() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">delete</span> ctrl;            <span class="comment">// 没有 weak_ptr 了才释放控制块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝＝原子++，析构＝原子–；减到 0 才真正 <code>delete</code> 对象。  </li>
<li>线程安全：引用计数操作用 <code>atomic_fetch_add/sub</code>，但<strong>对象本身不互斥</strong>。</li>
</ul>
<ol start="2">
<li><code>weak_ptr&lt;T&gt;</code> —— “非拥有观察器”</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">weak_ptr</span> &#123;</span><br><span class="line">    T*        ptr;          <span class="comment">// 可能悬空</span></span><br><span class="line">    ControlBlock* ctrl;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">weak_ptr</span>(<span class="type">const</span> shared_ptr&amp; s) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        ptr  = s.ptr;</span><br><span class="line">        ctrl = s.ctrl;</span><br><span class="line">        ctrl-&gt;weak_count.<span class="built_in">fetch_add</span>(<span class="number">1</span>, memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">shared_ptr&lt;T&gt; <span class="title">lock</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> c = ctrl-&gt;shared_count.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctrl-&gt;shared_count.<span class="built_in">compare_exchange_weak</span>(c, c<span class="number">+1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(ptr, ctrl); <span class="comment">// 提升成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shared_ptr&lt;T&gt;&#123;&#125;;   <span class="comment">// 对象已析构，返回空</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">weak_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctrl-&gt;weak_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, memory_order_acq_rel) == <span class="number">1</span> &amp;&amp;</span><br><span class="line">            ctrl-&gt;shared_count.<span class="built_in">load</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">delete</span> ctrl;          <span class="comment">// 最后一个 weak_ptr 负责释放控制块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>weak_ptr</code> 只改 <code>weak_count</code>，<strong>不干扰对象生命周期</strong>。  </li>
<li><code>lock()</code> 用 CAS 把 <code>shared_count</code> 从 0 以上加 1，保证线程安全地“提升”成 <code>shared_ptr</code>。</li>
</ul>
<ol start="3">
<li><code>unique_ptr&lt;T,Deleter&gt;</code> —— “独占 + 可定制删除器”</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">D</span> = default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr &#123;</span><br><span class="line">    T* ptr;              <span class="comment">// 仅此一个指针，无控制块</span></span><br><span class="line">    [[no_unique_address]] D deleter;  <span class="comment">// 空类优化，不占空间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unique_ptr</span>(T* p = <span class="literal">nullptr</span>) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; u) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(u.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; u) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">reset</span>(u.<span class="built_in">release</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">unique_ptr</span>() &#123; <span class="keyword">if</span> (ptr) <span class="built_in">deleter</span>(ptr); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; T* tmp = ptr; ptr = <span class="literal">nullptr</span>; <span class="keyword">return</span> tmp; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        T* old = ptr;</span><br><span class="line">        ptr = p;</span><br><span class="line">        <span class="keyword">if</span> (old) <span class="built_in">deleter</span>(old);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 禁止拷贝</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>零开销</strong>：和裸指针一样大（<code>sizeof(unique_ptr&lt;T&gt;) == sizeof(T*)</code>）。  </li>
<li><strong>无原子操作</strong>，不可替代拷贝，只能 <code>move</code>，因此性能 &#x3D; 手工 <code>new/delete</code>。  </li>
<li>删除器类型可以是<strong>函数指针、lambda、函数对象</strong>，用 <code>[[no_unique_address]]</code> 空基优化，不额外占空间。</li>
</ul>
<hr>
<p>三、一张图秒记</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">生命周期\指针类型    unique_ptr      shared_ptr        weak_ptr</span><br><span class="line">对象存活期          独占            最后一个 shared   与对象无关</span><br><span class="line">控制块              无              有                共享同一块</span><br><span class="line">线程安全            不需要          引用计数原子      引用计数原子</span><br><span class="line">拷贝语义            move only       共享拷贝          不可提升，需 lock</span><br><span class="line">内存大小            sizeof(T*)      sizeof(T*)×2      sizeof(T*)×2</span><br></pre></td></tr></table></figure>

<hr>
<p>四、使用场景一句话</p>
<ul>
<li><strong>unique_ptr</strong>：独占资源，成本最低，首选。  </li>
<li><strong>shared_ptr</strong>：真·共享所有权（如多线程缓存节点、回调链）。  </li>
<li><strong>weak_ptr</strong>：打破环、缓存观察、避免悬空访问。</li>
</ul>
<p>记住这条链：<br><strong>“unique 优先，非共享不用 shared；shared 一用，weak 随时准备破环。”</strong></p>
<h3 id="内存泄漏：检测⽅法、防⽌策略、调试⼯具-Valgrind"><a href="#内存泄漏：检测⽅法、防⽌策略、调试⼯具-Valgrind" class="headerlink" title="内存泄漏：检测⽅法、防⽌策略、调试⼯具(Valgrind)"></a>内存泄漏：检测⽅法、防⽌策略、调试⼯具(Valgrind)</h3><p>下面给出一套“<strong>开发期→测试期→线上期</strong>”全链条的内存泄漏治理方案：<br>先讲<strong>检测思路</strong>→<strong>防止策略</strong>→<strong>实战调试工具（Valgrind 为例）</strong>，最后附一条“一键脚本”直接定位泄漏行号。</p>
<hr>
<p>一、检测方法：3 层过滤</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>手段</th>
<th>成本</th>
<th>是否能定位行号</th>
</tr>
</thead>
<tbody><tr>
<td>编译期</td>
<td>静态分析（clang-tidy &#x2F; cppcheck）</td>
<td>零运行开销</td>
<td>❌（只能给提示）</td>
</tr>
<tr>
<td>测试期</td>
<td>动态插桩（Valgrind &#x2F; ASan）</td>
<td>2~10× 降速</td>
<td>✅ 精确到行</td>
</tr>
<tr>
<td>线上期</td>
<td>采样 + 统计（jemalloc stats &#x2F; gperftools heap-profiler）</td>
<td>&lt;5% 损耗</td>
<td>✅ 近似栈</td>
</tr>
</tbody></table>
<hr>
<p>二、防止策略：代码层面 5 条铁规</p>
<ol>
<li><p><strong>RAII 全覆盖</strong><br>资源放在构造函数里获取，析构里释放；用 <code>std::unique_ptr</code>&#x2F;<code>std::vector</code> 代替裸 <code>new[]/malloc</code>。</p>
</li>
<li><p>** ownership 可视化**<br>函数签名里用 <code>std::unique_ptr&lt;T&gt;</code> 表示独占，<code>std::shared_ptr&lt;T&gt;</code> 表示共享，裸指针 <code>T*</code> 仅作非拥有观察。</p>
</li>
<li><p><strong>禁用危险接口</strong><br>全局加 <code>-Werror=deprecated-declarations</code>，把 <code>strdup/getline/malloc</code> 等 C 接口封装到 <code>std::string</code>&#x2F;<code>std::vector</code>。</p>
</li>
<li><p><strong>循环引用破环</strong><br>父子对象用 <code>weak_ptr</code> 回指；异步回调用 <code>weak_from_this()</code> + <code>lock()</code> 提升。</p>
</li>
<li><p><strong>单元测试必跑泄漏检查</strong><br>在 CI 里把测试可执行文件跑在 Valgrind&#x2F;ASan 下，阈值 &gt;0 字节即判失败。</p>
</li>
</ol>
<hr>
<p>三、调试工具：Valgrind 三行命令定位泄漏</p>
<ol>
<li><p><strong>安装</strong><br>Ubuntu: <code>sudo apt install valgrind</code><br>CentOS: <code>sudo yum install valgrind</code></p>
</li>
<li><p><strong>最常用模式</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valgrind --leak-check=full --show-leak-kinds=all --track-origins=<span class="built_in">yes</span> \</span><br><span class="line">         ./your_program arg1 arg2</span><br></pre></td></tr></table></figure>

<p>参数说明  </p>
<ul>
<li><code>--leak-check=full</code>：给出每次泄漏的完整栈。  </li>
<li><code>--track-origins=yes</code>：告诉你未初始化值是哪一行产生的。  </li>
<li><code>--show-leak-kinds=all</code>：区分 <code>definitely/indirectly/possibly/still reachable</code>。</li>
</ul>
</li>
<li><p><strong>结果解读示例</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">==1234== 40 bytes in 1 blocks are definitely lost in loss record 1 of 2</span><br><span class="line">==1234==    at 0x4C2BBAF: malloc (vg_replace_malloc.c:299)</span><br><span class="line">==1234==    by 0x4006ED: foo() (main.cpp:8)</span><br><span class="line">==1234==    by 0x40070E: main (main.cpp:13)</span><br></pre></td></tr></table></figure>

<p>关键词 <code>definitely lost</code> 表示<strong>确定泄漏</strong>；直接跳到 <code>main.cpp:8</code> 就能看见忘了 <code>delete</code> 的那一行。</p>
</li>
<li><p><strong>生成抑制文件（去掉系统库误报）</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valgrind --gen-suppressions=all --leak-check=full ./your_program 2&gt; valgrind.supp</span><br><span class="line"><span class="comment"># 以后跑</span></span><br><span class="line">valgrind --suppressions=valgrind.supp --leak-check=full ./your_program</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CI 集成阈值检查</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valgrind --error-exitcode=42 --leak-check=full ./your_program</span><br><span class="line"><span class="comment"># 只要泄漏 &gt;0 字节，Valgrind 返回 42，CI 直接红灯。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>四、一条“一键脚本”自动抓泄漏行号</p>
<p>把下面脚本扔进 <code>.github/workflows/valgrind.yml</code> 即可在 GitHub Actions 里跑：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">memcheck</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>, <span class="string">pull_request</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">valgrind:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">sudo</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">-y</span> <span class="string">valgrind</span> <span class="string">g++</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">g++</span> <span class="string">-g</span> <span class="string">-O0</span> <span class="string">main.cpp</span> <span class="string">-o</span> <span class="string">app</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">valgrind</span> <span class="string">--leak-check=full</span> <span class="string">--error-exitcode=1</span> <span class="string">./app</span></span><br></pre></td></tr></table></figure>

<hr>
<p>五、速查表：泄漏场景 vs 工具选择</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐工具</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>本地快速冒烟</td>
<td>AddressSanitizer（<code>-fsanitize=address</code>）</td>
<td>1.5× 速度，集成 GDB</td>
</tr>
<tr>
<td>单元测试阶段</td>
<td>Valgrind</td>
<td>最详细，能抓未初始化读写</td>
</tr>
<tr>
<td>压力测试&#x2F;长稳</td>
<td>gperftools heap-profiler + jemalloc</td>
<td>采样，损耗低</td>
</tr>
<tr>
<td>嵌入式&#x2F;交叉编译</td>
<td>Clang LeakSanitizer（无 Valgrind 时）</td>
<td>需要 gcc&#x2F;clang 5.0+</td>
</tr>
</tbody></table>
<hr>
<p>口诀记住：<br><strong>“代码里先 RAII，测试里跑 Valgrind，线上用采样 profiler；三步走完，泄漏归零。”</strong></p>
<h3 id="野指针与悬空指针：产⽣原因、危害、避免⽅法"><a href="#野指针与悬空指针：产⽣原因、危害、避免⽅法" class="headerlink" title="野指针与悬空指针：产⽣原因、危害、避免⽅法"></a>野指针与悬空指针：产⽣原因、危害、避免⽅法</h3><blockquote>
<p>好的，我们来深入探讨C++中两个非常棘手且危险的概念：<strong>野指针 (Wild Pointer)</strong> 和 <strong>悬空指针 (Dangling Pointer)</strong>。</p>
<p>它们都是指向无效内存地址的指针，是导致程序崩溃、数据损坏、以及难以调试的“未定义行为”的常见根源。</p>
<hr>
<h3 id="野指针-Wild-Pointer"><a href="#野指针-Wild-Pointer" class="headerlink" title="野指针 (Wild Pointer)"></a>野指针 (Wild Pointer)</h3><h4 id="1-产生原因"><a href="#1-产生原因" class="headerlink" title="1. 产生原因"></a>1. 产生原因</h4><p><strong>野指针指的是未被初始化或指向未知随机地址的指针。</strong> 它指向哪里是完全不确定的。</p>
<ul>
<li><p><strong>声明后未初始化</strong>： 这是最常见的原因。指针变量在声明时不会自动初始化为 <code>nullptr</code>，它的值是之前栈内存上的随机垃圾数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* wildPtr; <span class="comment">// 野指针！它的值是随机的，可能是0x12345678</span></span><br><span class="line">*wildPtr = <span class="number">10</span>; <span class="comment">// 灾难！向一个未知的内存地址写入数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指针变量本身在栈上，但未初始化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p; <span class="comment">// p在栈上，但其值（指向的地址）是未定义的垃圾值，是野指针。</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-危害"><a href="#2-危害" class="headerlink" title="2. 危害"></a>2. 危害</h4><ul>
<li><strong>未定义行为 (Undefined Behavior)</strong>： 对野指针进行解引用（读写操作）的行为是未定义的。</li>
<li><strong>程序崩溃</strong>： 如果指针指向的随机地址是操作系统保护的内存区域（如内核空间），会立即触发段错误（Segmentation Fault）或访问冲突（Access Violation），导致程序崩溃。</li>
<li><strong>数据损坏</strong>： 如果指针恰好指向程序可写的内存地址（如另一个变量所在的位置），写入操作会<strong>静默地覆盖</strong>那块内存的数据，导致程序行为异常，且这种bug极难追踪。</li>
</ul>
<h4 id="3-避免方法"><a href="#3-避免方法" class="headerlink" title="3. 避免方法"></a>3. 避免方法</h4><p><strong>核心思想：让所有指针在创建时都有一个明确的、有效的或可知的状态。</strong></p>
<ul>
<li><p><strong>声明时立即初始化</strong>：</p>
<ul>
<li>如果暂时不知道指向什么，立即初始化为 <code>nullptr</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="literal">nullptr</span>; <span class="comment">// 安全的做法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在指针生命周期结束后置空</strong>： 虽然作用有限，但在复杂逻辑中，<code>delete</code> 一个指针后立即将其置为 <code>nullptr</code> 是一个好习惯，可以防止意外地重复 <code>delete</code> 或误用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>; <span class="comment">// 现在ptr不是野指针，而是空指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用智能指针</strong>： <strong>这是现代C++最根本、最推荐的解决方案。</strong> <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 等智能指针在构造时会被自动初始化（要么指向有效对象，要么为 <code>nullptr</code>），在析构时会自动释放内存，并且释放后会自动置空，从根本上避免了野指针和悬空指针的产生。</p>
</li>
</ul>
<hr>
<h3 id="悬空指针-Dangling-Pointer"><a href="#悬空指针-Dangling-Pointer" class="headerlink" title="悬空指针 (Dangling Pointer)"></a>悬空指针 (Dangling Pointer)</h3><h4 id="1-产生原因-1"><a href="#1-产生原因-1" class="headerlink" title="1. 产生原因"></a>1. 产生原因</h4><p><strong>悬空指针指的是指针曾经指向一个有效的内存地址，但该内存后被释放或失效，而这个指针仍然保留着原来的地址。</strong> 它像一个“晃来晃去”的指针，指向一个“已死亡的”对象。</p>
<ul>
<li><p><strong>释放&#x2F;删除后未置空</strong>： 这是最典型的场景。使用 <code>delete</code>（对于C的 <code>free</code> 也一样）释放了堆内存，但指针变量本身依然存在并存储着那个已经失效的地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// 内存被释放，ptr现在变成了悬空指针</span></span><br><span class="line"><span class="comment">// ptr still holds the address that is no longer valid</span></span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 灾难！向已释放的内存写入数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指向局部变量（栈内存）</strong>： 函数返回后，其栈帧被销毁，所有局部变量失效。指向这些局部变量的指针在函数外部就变成了悬空指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">createInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;value; <span class="comment">// 错误！返回局部变量value的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* danglingPtr = <span class="built_in">createInt</span>(); <span class="comment">// danglingPtr是悬空指针</span></span><br><span class="line"><span class="comment">// value的生命周期已在createInt()返回时结束</span></span><br><span class="line">std::cout &lt;&lt; *danglingPtr; <span class="comment">// 未定义行为！读取已销毁的栈内存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多个指针指向同一资源，其中一个释放了资源</strong>： 如果有多个指针指向同一块动态分配的内存，通过其中一个指针 <code>delete</code> 了内存，其他所有指针都会立即变为悬空指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span>* ptr2 = ptr1; <span class="comment">// ptr1和ptr2指向同一块内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptr1; <span class="comment">// 内存被释放</span></span><br><span class="line">ptr1 = <span class="literal">nullptr</span>; <span class="comment">// ptr1被置空，是安全的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但ptr2对此一无所知，它现在是一个悬空指针！</span></span><br><span class="line">std::cout &lt;&lt; *ptr2; <span class="comment">// 未定义行为！</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-危害-1"><a href="#2-危害-1" class="headerlink" title="2. 危害"></a>2. 危害</h4><ul>
<li><strong>未定义行为</strong>： 与野指针相同，解引用悬空指针是未定义行为。</li>
<li><strong>程序崩溃</strong>： 访问已释放的内存很可能导致程序崩溃。</li>
<li><strong>数据损坏与安全漏洞</strong>： 危害比野指针更大，因为这块内存可能已经被内存分配器重新分配并存放了其他数据。对悬空指针的写入会破坏这些新数据，可能导致极其诡异的bug，甚至在特定条件下可能被利用形成安全漏洞（如Use-After-Free漏洞）。</li>
</ul>
<h4 id="3-避免方法-1"><a href="#3-避免方法-1" class="headerlink" title="3. 避免方法"></a>3. 避免方法</h4><p><strong>核心思想：确保指针的生命周期不超过其所指对象的内存生命周期。</strong></p>
<ul>
<li><strong>释放后立即置空</strong>： 这是一个“治标”的方法。<code>delete ptr;</code> 后紧跟 <code>ptr = nullptr;</code>。这样即使再次误用，对空指针解引用也会立即导致崩溃（这比破坏其他数据更容易调试）。但这无法解决多个指针指向同一资源的问题。</li>
<li><strong>严格控制指针的作用域</strong>： 让指针的寿命短于或等于其所指对象的寿命。例如，避免返回指向局部变量的指针或引用。</li>
<li><strong>使用智能指针</strong>： <strong>同样是现代C++最根本的解决方案。</strong><ul>
<li><strong><code>std::unique_ptr</code></strong>： 明确表达所有权的独占性。一块内存只由一个 <code>unique_ptr</code> 管理，不可能出现多个指针。当 <code>unique_ptr</code> 离开作用域，内存自动释放，并且所有指针信息都被清理。<strong>从根本上杜绝了多个指针的问题。</strong></li>
<li><strong><code>std::shared_ptr</code></strong>： 使用引用计数来管理共享所有权。只有当最后一个 <code>shared_ptr</code> 被销毁时，内存才会被释放。这完美解决了“多个指针指向同一资源”的悬空问题。</li>
</ul>
</li>
<li><strong>使用引用代替指针</strong>： 当你不需要“无指向”或“重指向”的能力时，优先使用引用。引用必须在创建时绑定到一个有效对象，且不能重新绑定，因此它天然不会出现悬空或野的状态（尽管通过某些奇技淫巧仍然可能创建出无效引用，但那不是常规用法）。</li>
</ul>
<hr>
<h3 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">野指针 (Wild Pointer)</th>
<th align="left">悬空指针 (Dangling Pointer)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left"><strong>未初始化</strong>的指针，值是<strong>随机</strong>的</td>
<td align="left"><strong>已初始化</strong>但指向<strong>已失效</strong>内存的指针</td>
</tr>
<tr>
<td align="left"><strong>产生时机</strong></td>
<td align="left"><strong>创建时</strong></td>
<td align="left"><strong>资源释放后</strong></td>
</tr>
<tr>
<td align="left"><strong>常见原因</strong></td>
<td align="left">声明后未初始化</td>
<td align="left">1. <code>delete/free</code> 后未置空<br>2. 指向已销毁的栈对象<br>3. 多个指针指向同一资源，其中一个释放</td>
</tr>
<tr>
<td align="left"><strong>危害</strong></td>
<td align="left">程序崩溃、数据损坏</td>
<td align="left">程序崩溃、数据损坏、<strong>安全漏洞</strong></td>
</tr>
<tr>
<td align="left"><strong>根本解决方法</strong></td>
<td align="left"><strong>声明时初始化为 <code>nullptr</code></strong></td>
<td align="left"><strong>使用智能指针管理资源生命周期</strong></td>
</tr>
</tbody></table>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>永远初始化指针</strong>： 声明指针时，要么赋予它有效的地址，要么立即赋值为 <code>nullptr</code>。</li>
<li><strong>释放后立即置空</strong>： 使用 <code>delete</code> 或 <code>free</code> 后，养成习惯将指针置空。</li>
<li><strong>优先使用引用</strong>： 如果不需要指针的灵活性，使用引用更安全。</li>
<li><strong>拥抱现代C++</strong>： <strong>尽可能地使用 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 来代替裸指针（raw pointer）管理资源所有权。</strong> 这是避免内存管理错误的最有效手段。将裸指针仅用于“观察”而非“拥有”资源的场景。</li>
</ol>
</blockquote>
<h3 id="字节对⻬：原理、pragma-pack、性能影响"><a href="#字节对⻬：原理、pragma-pack、性能影响" class="headerlink" title="字节对⻬：原理、pragma pack、性能影响"></a>字节对⻬：原理、pragma pack、性能影响</h3><p>字节对齐：原理、pragma pack、性能影响</p>
<hr>
<p>一、原理：硬件说了算</p>
<ol>
<li><p>对齐定义<br>数据类型 T 的地址必须是 <code>alignof(T)</code> 的倍数，否则：</p>
<ul>
<li>CPU 抛总线错误（ARM、RISC-V）  </li>
<li>或自动拆成多次内存访问 → 性能掉崖（x86 允许，但慢）。</li>
</ul>
</li>
<li><p>自然对齐  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char  → 1 字节  </span><br><span class="line">short → 2 字节  </span><br><span class="line">int   → 4 字节  </span><br><span class="line">long/double → 8 字节（64 位）  </span><br><span class="line">__m256i → 32 字节（AVX）</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体对齐规则（Itanium C++ ABI）<br>a. 成员各自对齐到 <code>min(自身对齐, 当前 pack 值)</code><br>b. 结构体总大小对齐到“<strong>最大对齐成员</strong>”的倍数（同样受 pack 裁剪）<br>c. 数组按元素对齐。</p>
</li>
</ol>
<hr>
<p>二、#pragma pack：手动改规则</p>
<p>语法  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, n)   <span class="comment">// 把当前对齐压栈，并设新对齐 = n（1,2,4,8,16）</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)       <span class="comment">// 恢复</span></span></span><br></pre></td></tr></table></figure>

<p>实例：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1)   <span class="comment">// 1 字节对齐 → 紧凑，无填充</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">char</span>  c;   <span class="comment">// 1</span></span><br><span class="line">    <span class="type">int</span>   i;   <span class="comment">// 4</span></span><br><span class="line">    <span class="type">short</span> s;   <span class="comment">// 2</span></span><br><span class="line">&#125;;             <span class="comment">// 总大小 = 7 字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认 4 字节对齐时：c(1)+pad(3)+i(4)+s(2)+pad(2) = 12 字节</span></span><br></pre></td></tr></table></figure>

<p>相同功能的标准化写法（C++11 起）  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> [[gnu::packed]] A &#123; ... &#125;;   <span class="comment">// GCC/Clang</span></span><br><span class="line">__declspec(<span class="built_in">align</span>(<span class="number">32</span>)) <span class="keyword">struct</span> <span class="title class_">B</span> &#123; ... &#125;; <span class="comment">// MSVC</span></span><br></pre></td></tr></table></figure>

<hr>
<p>三、性能影响：一张图看懂</p>
<table>
<thead>
<tr>
<th>对齐</th>
<th>内存占用</th>
<th>单次访存</th>
<th>SIMD 加载</th>
<th>缓存行污染</th>
<th>结论</th>
</tr>
</thead>
<tbody><tr>
<td>自然对齐</td>
<td>大（填充）</td>
<td>1 周期</td>
<td>直接 movaps</td>
<td>无</td>
<td>最快</td>
</tr>
<tr>
<td>pack(1)</td>
<td>最小</td>
<td>2~4 周期拆分</td>
<td>崩溃&#x2F;手动 movups</td>
<td>可能跨行</td>
<td>最省</td>
</tr>
<tr>
<td>pack(2)</td>
<td>中</td>
<td>短地址 OK</td>
<td>部分失败</td>
<td>中</td>
<td>折中</td>
</tr>
</tbody></table>
<ul>
<li><strong>x86</strong>：硬件容忍，但跨 cache-line 访问带宽减半。  </li>
<li><strong>ARM</strong>：未对齐触发 <code>SIGBUS</code>，必须 <code>__builtin_assume_aligned</code> 或手动拷贝。  </li>
<li><strong>SIMD</strong>：256&#x2F;512-bit 指令要求 32&#x2F;64 字节对齐，否则直接异常。</li>
</ul>
<hr>
<p>四、最佳实践口诀</p>
<ol>
<li>默认让编译器对齐；  </li>
<li>网络&#x2F;磁盘协议用 <code>#pragma pack(push, 1)</code> 立即还原；  </li>
<li>热路径结构体把大成员放前面，避免空洞；  </li>
<li>与 SIMD 交互时加 <code>alignas(32)</code> 并 <code>static_assert(alignof(T) == 32)</code>；  </li>
<li>嵌入式解压后转本地副本，别再全程 packed 跑。</li>
</ol>
<hr>
<p>五、一条命令看真实布局</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -fdump-lang-class -std=c++17 test.cpp      <span class="comment"># GCC 打印填充细节</span></span><br><span class="line">pahole -C YourStruct a.out                     <span class="comment"># 读 DWARF 显示大小与偏移</span></span><br></pre></td></tr></table></figure>

<p>输出示例  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    char  c;      /*     0     1 */</span><br><span class="line">    /* padding 3 */</span><br><span class="line">    int   i;      /*     4     4 */</span><br><span class="line">    short s;      /*     8     2 */</span><br><span class="line">    /* padding 2 */</span><br><span class="line">&#125;;                /* sizeof=12, align=4 */</span><br></pre></td></tr></table></figure>

<hr>
<p>记住：<strong>“pack 省空间，对齐换速度；网络包 pack，运算路径 align。”</strong></p>
<h2 id="面向对象高级特性"><a href="#面向对象高级特性" class="headerlink" title="面向对象高级特性"></a>面向对象高级特性</h2><pre><code>好的，我们来深入探讨 C++ 面向对象编程的高级特性。这些概念是构建复杂、可维护软件系统的基石。
</code></pre>
<hr>
<h3 id="1-继承-Inheritance"><a href="#1-继承-Inheritance" class="headerlink" title="1. 继承 (Inheritance)"></a>1. 继承 (Inheritance)</h3><p>继承是面向对象的核心特性，允许新的类（派生类 Derived Class）基于已有的类（基类 Base Class）来构建，继承其数据和行为，并可以进行扩展和特化。</p>
<h4 id="a-继承访问控制-public-protected-private"><a href="#a-继承访问控制-public-protected-private" class="headerlink" title="a. 继承访问控制 (public&#x2F;protected&#x2F;private)"></a>a. 继承访问控制 (public&#x2F;protected&#x2F;private)</h4><p>继承方式决定了<strong>基类成员在派生类中的最大访问权限</strong>以及<strong>派生类对象对基类成员的访问权限</strong>。</p>
<table>
<thead>
<tr>
<th align="left">继承方式</th>
<th align="left">基类<code>public</code>成员</th>
<th align="left">基类<code>protected</code>成员</th>
<th align="left">基类<code>private</code>成员</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>public 继承</strong></td>
<td align="left">Derived::<code>public</code></td>
<td align="left">Derived::<code>protected</code></td>
<td align="left"><strong>不可访问</strong></td>
</tr>
<tr>
<td align="left"><strong>protected 继承</strong></td>
<td align="left">Derived::<code>protected</code></td>
<td align="left">Derived::<code>protected</code></td>
<td align="left"><strong>不可访问</strong></td>
</tr>
<tr>
<td align="left"><strong>private 继承</strong></td>
<td align="left">Derived::<code>private</code></td>
<td align="left">Derived::<code>private</code></td>
<td align="left"><strong>不可访问</strong></td>
</tr>
</tbody></table>
<p><strong>核心要点：</strong></p>
<ol>
<li><p><strong><code>public</code> 继承 (is-a 关系)</strong>： 最常用。表示派生类是基类的一种特化类型。它遵循”is-a”关系（<code>Dog</code> is an <code>Animal</code>）。基类的公有接口也成为派生类的公有接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span></span>; &#125;; <span class="comment">// Dog is an Animal</span></span><br><span class="line">Dog d;</span><br><span class="line">d.<span class="built_in">breathe</span>(); <span class="comment">// OK, public继承后，breathe()在派生类中仍是public</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>protected</code> &#x2F; <code>private</code> 继承 (is-implemented-in-terms-of 关系)</strong>： 很少使用。它们不表示”is-a”关系，而是表示派生类<strong>是根据基类实现的</strong>（”is-implemented-in-terms-of”）。基类的公有和保护成员在派生类中都变成了 <code>protected</code> 或 <code>private</code>，<strong>对外部不可见</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="comment">// Car 不是一种 Engine，但它内部用了一个Engine来实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">private</span> Engine &#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">turnKey</span><span class="params">()</span> </span>&#123; <span class="built_in">start</span>(); &#125; &#125;;</span><br><span class="line">Car c;</span><br><span class="line">c.<span class="built_in">start</span>(); <span class="comment">// 错误！private继承后，start()在派生类中是private，外部无法调用</span></span><br></pre></td></tr></table></figure>

<p><strong>通常，组合（在一个类中包含另一个类的对象作为成员）比 <code>private</code>&#x2F;<code>protected</code> 继承更优先被使用</strong>，因为它耦合度更低。</p>
</li>
</ol>
<h4 id="b-虚继承-Virtual-Inheritance-与-菱形继承-Diamond-Problem"><a href="#b-虚继承-Virtual-Inheritance-与-菱形继承-Diamond-Problem" class="headerlink" title="b. 虚继承 (Virtual Inheritance) 与 菱形继承 (Diamond Problem)"></a>b. 虚继承 (Virtual Inheritance) 与 菱形继承 (Diamond Problem)</h4><ul>
<li><p><strong>问题背景（菱形继承）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> data; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line">D d;</span><br><span class="line"><span class="comment">// d.data = 10; // 错误！歧义：不清楚data是来自B路径的A还是C路径的A</span></span><br><span class="line">d.B::data = <span class="number">10</span>; <span class="comment">// 需要显式指定，解决了语法歧义，但...</span></span><br><span class="line">d.C::data = <span class="number">20</span>; <span class="comment">// ...但B::data和C::data是**两个不同的副本**！造成了数据冗余。</span></span><br></pre></td></tr></table></figure>

<p>这种情况下，<code>D</code> 对象中包含了两份 <code>A</code> 的成员。</p>
</li>
<li><p><strong>解决方案（虚继承）</strong>：<br>使用 <code>virtual</code> 关键字修饰继承关系，让 <code>B</code> 和 <code>C</code> <strong>虚继承</strong>自 <code>A</code>。这确保了在最终的派生类 <code>D</code> 中，<strong>只保留一份 <code>A</code> 的实例</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> data; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;; <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;; <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line">D d;</span><br><span class="line">d.data = <span class="number">10</span>; <span class="comment">// OK！没有歧义，只有一份data副本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现机制</strong>： 虚继承通过虚基类指针和虚基类表来实现，编译器会安排让 <code>B</code> 和 <code>C</code> 共享 <code>D</code> 中的同一块 <code>A</code> 子对象存储区域。<strong>最派生类（如 <code>D</code>）负责直接初始化虚基类 <code>A</code></strong>。</p>
</li>
</ul>
<hr>
<h3 id="2-多态-Polymorphism"><a href="#2-多态-Polymorphism" class="headerlink" title="2. 多态 (Polymorphism)"></a>2. 多态 (Polymorphism)</h3><p>多态意为“多种形态”，允许使用统一的接口操作不同的对象。</p>
<h4 id="a-静态多态-Static-Polymorphism-vs-动态多态-Dynamic-Polymorphism"><a href="#a-静态多态-Static-Polymorphism-vs-动态多态-Dynamic-Polymorphism" class="headerlink" title="a. 静态多态 (Static Polymorphism) vs 动态多态 (Dynamic Polymorphism)"></a>a. 静态多态 (Static Polymorphism) vs 动态多态 (Dynamic Polymorphism)</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">静态多态（编译时多态）</th>
<th align="left">动态多态（运行时多态）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现机制</strong></td>
<td align="left">函数重载 (Overloading)、模板 (Templates)</td>
<td align="left">虚函数 (Virtual Functions)、继承</td>
</tr>
<tr>
<td align="left"><strong>绑定时间</strong></td>
<td align="left"><strong>编译期</strong></td>
<td align="left"><strong>运行期</strong></td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">无额外运行时开销</td>
<td align="left">有间接调用开销（查虚函数表）</td>
</tr>
<tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">相对较低</td>
<td align="left">非常高，支持运行时动态绑定</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>静态多态（函数重载）</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> f)</span> </span>&#123; ... &#125; <span class="comment">// 编译时根据参数类型决定调用哪个</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态多态（虚函数）</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数，接口</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; ... &#125; <span class="comment">// 重写实现</span></span><br><span class="line">&#125;;</span><br><span class="line">Shape* s = <span class="keyword">new</span> Circle;</span><br><span class="line">s-&gt;<span class="built_in">draw</span>(); <span class="comment">// 运行时根据s实际指向的对象类型调用Circle::draw()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b-虚函数实现机制"><a href="#b-虚函数实现机制" class="headerlink" title="b. 虚函数实现机制"></a>b. 虚函数实现机制</h4><p>（此部分已在之前详述，此处简要回顾）</p>
<ul>
<li><strong>vtable (虚函数表)</strong>： 每个包含虚函数的类都有一个对应的 vtable。它是一个函数指针数组，存放该类所有虚函数的地址。</li>
<li><strong>vptr (虚函数指针)</strong>： 每个包含虚函数的类的对象内部都有一个隐藏的 vptr 成员，指向其类的 vtable。</li>
<li><strong>动态绑定过程</strong>： <code>obj-&gt;virtual_function()</code> 被编译器翻译为 <code>(*(obj-&gt;vptr[n]))()</code>，其中 <code>n</code> 是虚函数在表中的索引。这实现了运行时根据对象实际类型调用正确函数。</li>
</ul>
<hr>
<h3 id="3-友元-Friend"><a href="#3-友元-Friend" class="headerlink" title="3. 友元 (Friend)"></a>3. 友元 (Friend)</h3><p>友元机制打破了类的封装性，允许<strong>一个外部函数或另一个类</strong>访问本类的 <code>private</code> 和 <code>protected</code> 成员。</p>
<h4 id="a-友元函数-Friend-Function"><a href="#a-友元函数-Friend-Function" class="headerlink" title="a. 友元函数 (Friend Function)"></a>a. 友元函数 (Friend Function)</h4><p>一个非成员函数被授予访问类的私有成员的权限。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">int</span> w) : <span class="built_in">width</span>(w) &#123;&#125;</span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printWidth</span><span class="params">(<span class="type">const</span> Box&amp; box)</span></span>; <span class="comment">// 注意：它不是成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printWidth</span><span class="params">(<span class="type">const</span> Box&amp; box)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; box.width; <span class="comment">// OK，友元可以访问私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printWidth</span>(b); <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常见应用</strong>： 重载运算符（如 <code>&lt;&lt;</code>, <code>&gt;&gt;</code>），因为这些运算符通常需要作为非成员函数实现，但又需要访问类的私有数据。</p>
<h4 id="b-友元类-Friend-Class"><a href="#b-友元类-Friend-Class" class="headerlink" title="b. 友元类 (Friend Class)"></a>b. 友元类 (Friend Class)</h4><p>一个类被授予访问另一个类的私有成员的权限。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sensor</span> &#123;</span><br><span class="line">    <span class="type">int</span> rawData;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">DataProcessor</span>; <span class="comment">// DataProcessor是友元类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sensor</span>() : <span class="built_in">rawData</span>(<span class="number">100</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataProcessor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Sensor&amp; s)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s.rawData; <span class="comment">// OK，DataProcessor是Sensor的友元类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>： 友元关系是<strong>单向的</strong>（<code>DataProcessor</code> 可以访问 <code>Sensor</code>，但 <code>Sensor</code> 不能访问 <code>DataProcessor</code>）且<strong>不传递</strong>（<code>DataProcessor</code> 的友元不是 <code>Sensor</code> 的友元）。</p>
<h4 id="c-破坏封装性的权衡"><a href="#c-破坏封装性的权衡" class="headerlink" title="c. 破坏封装性的权衡"></a>c. 破坏封装性的权衡</h4><ul>
<li><strong>优点</strong>： 提供了必要的灵活性，在某些场景下（如运算符重载、紧密协作的类）可以简化设计，提高效率。</li>
<li><strong>缺点</strong>： <strong>破坏了封装性和信息隐藏</strong>，增加了类之间的耦合度。友元关系在继承层次中也是不可继承的。</li>
<li><strong>最佳实践</strong>： <strong>慎用友元</strong>。优先考虑通过公有接口来交互。只有在确实无法通过公有接口高效、简洁地实现功能时，才考虑使用友元。</li>
</ul>
<hr>
<h3 id="4-运算符重载-Operator-Overloading"><a href="#4-运算符重载-Operator-Overloading" class="headerlink" title="4. 运算符重载 (Operator Overloading)"></a>4. 运算符重载 (Operator Overloading)</h3><p>运算符重载允许为用户自定义的类型（类或枚举）赋予运算符（如 <code>+</code>, <code>-</code>, <code>==</code>, <code>&lt;&lt;</code> 等）新的含义，使代码更直观。</p>
<h4 id="a-规则"><a href="#a-规则" class="headerlink" title="a. 规则"></a>a. 规则</h4><ol>
<li>不能发明新运算符（如不能定义 <code>**</code> 来表示幂运算）。</li>
<li>不能改变运算符的优先级和结合性。</li>
<li>不能改变运算符的操作数个数（<code>++</code> 是单目，<code>+</code> 是双目）。</li>
<li>至少有一个操作数是用户自定义类型（不能重载 <code>int + int</code>）。</li>
<li><code>::</code>, <code>.*</code>, <code>.</code>, <code>?:</code> 这四个运算符不能被重载。</li>
</ol>
<h4 id="b-常见重载"><a href="#b-常见重载" class="headerlink" title="b. 常见重载"></a>b. 常见重载</h4><p>运算符重载可以定义为<strong>成员函数</strong>或<strong>非成员函数（通常是友元）</strong>。</p>
<ul>
<li><p><strong>作为成员函数</strong>： 运算符的左操作数必须是当前类的对象 (<code>this</code>)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector&amp; other) <span class="type">const</span> &#123; <span class="comment">// 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector</span>(x + other.x, y + other.y);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Vector v1, v2, v3;</span><br><span class="line">v3 = v1 + v2; <span class="comment">// 等价于 v3 = v1.operator+(v2);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>作为非成员友元函数</strong>： 当左操作数不是本类对象时（如 <code>cout &lt;&lt; myObject</code>），必须定义为非成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line">    <span class="comment">// ... 同上</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Vector&amp; v);</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Vector&amp; v) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os; <span class="comment">// 支持链式调用：cout &lt;&lt; v1 &lt;&lt; v2;</span></span><br><span class="line">&#125;</span><br><span class="line">Vector v;</span><br><span class="line">std::cout &lt;&lt; v; <span class="comment">// 调用 operator&lt;&lt;(cout, v);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>一些常用运算符的重载建议：</strong></p>
<ul>
<li><code>=</code> (赋值), <code>[]</code> (下标), <code>()</code> (函数调用), <code>-&gt;</code> (成员访问)： <strong>必须</strong>作为成员函数重载。</li>
<li><code>&lt;&lt;</code>, <code>&gt;&gt;</code> (流操作)： <strong>必须</strong>作为非成员函数重载，且通常是友元。</li>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code> 等： 通常作为非成员函数（以实现左右操作数对称性），或者成员函数。</li>
</ul>
<h4 id="c-拷贝构造函数-Copy-Constructor"><a href="#c-拷贝构造函数-Copy-Constructor" class="headerlink" title="c. 拷贝构造函数 (Copy Constructor)"></a>c. 拷贝构造函数 (Copy Constructor)</h4><p>它是一种特殊的构造函数，用于<strong>用一个已存在的对象来初始化一个新对象</strong>。编译器会为我们自动生成一个默认的拷贝构造函数（进行浅拷贝）。</p>
<p><strong>语法：</strong> <code>ClassName(const ClassName&amp; other);</code></p>
<p><strong>何时被调用？</strong></p>
<ol>
<li>用一个对象初始化另一个对象：<code>MyClass obj1; MyClass obj2 = obj1;</code></li>
<li>函数参数传递对象（按值传递）：<code>void func(MyClass obj);</code></li>
<li>函数返回对象（按值返回）（可能会被编译器优化掉）。</li>
</ol>
<p><strong>为什么需要自定义拷贝构造函数？</strong><br>当类中含有<strong>指针成员</strong>并管理着动态分配的内存时，默认的浅拷贝只会复制指针的值（地址），而不会复制指针所指向的内存。这会导致两个对象的指针成员指向同一块内存，从而引发<strong>双重释放</strong>和<strong>悬空指针</strong>问题。</p>
<p><strong>解决方案：实现自定义拷贝构造函数进行深拷贝。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;</span><br><span class="line">    <span class="type">size_t</span> m_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) : <span class="built_in">m_size</span>(other.m_size) &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[m_size + <span class="number">1</span>];       <span class="comment">// 1. 为新对象分配自己的内存</span></span><br><span class="line">        std::<span class="built_in">strcpy</span>(m_data, other.m_data);   <span class="comment">// 2. 拷贝数据，而不是指针地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 还需要自定义析构函数和赋值运算符重载 (operator=)</span></span><br><span class="line">    ~<span class="built_in">String</span>() &#123; <span class="keyword">delete</span>[] m_data; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>三法则 (Rule of Three)</strong>： 如果一个类需要自定义<strong>析构函数</strong>、<strong>拷贝构造函数</strong>或<strong>拷贝赋值运算符</strong>，那么它很可能需要同时定义这三个。现代C++中，更推荐使用<strong>五法则 (Rule of Five)</strong>，加上移动构造函数和移动赋值运算符。</p>
<h2 id="现代C-（C-11-14-17）引入的这些革命性特性"><a href="#现代C-（C-11-14-17）引入的这些革命性特性" class="headerlink" title="现代C++（C++11&#x2F;14&#x2F;17）引入的这些革命性特性"></a>现代C++（C++11&#x2F;14&#x2F;17）引入的这些革命性特性</h2><hr>
<h3 id="1-智能指针-Smart-Pointers"><a href="#1-智能指针-Smart-Pointers" class="headerlink" title="1. 智能指针 (Smart Pointers)"></a>1. 智能指针 (Smart Pointers)</h3><p>智能指针是RAII（Resource Acquisition Is Initialization）理念的典范应用，用于自动化、安全地管理动态分配的内存，从根本上避免内存泄漏和悬空指针。</p>
<p>C++11主要引入了三种智能指针，位于 <code>&lt;memory&gt;</code> 头文件中：</p>
<ol>
<li><strong><code>std::unique_ptr</code></strong>： 独占所有权的智能指针。同一时间只能有一个 <code>unique_ptr</code> 指向一个对象。当 <code>unique_ptr</code> 被销毁时，它所指向的对象也会被自动销毁。<strong>无法被复制</strong>，只能被移动（<code>std::move</code>）。</li>
<li><strong><code>std::shared_ptr</code></strong>： 共享所有权的智能指针。通过引用计数机制，记录有多少个 <code>shared_ptr</code> 指向同一个对象。当最后一个 <code>shared_ptr</code> 被销毁时，对象才会被销毁。<strong>可以被复制</strong>。</li>
<li><strong><code>std::weak_ptr</code></strong>： 弱引用的智能指针。它指向由 <code>shared_ptr</code> 管理的对象，但<strong>不增加引用计数</strong>。用于解决 <code>shared_ptr</code> 的循环引用问题。</li>
</ol>
<h4 id="make-shared-和-make-unique"><a href="#make-shared-和-make-unique" class="headerlink" title="make_shared 和 make_unique"></a><code>make_shared</code> 和 <code>make_unique</code></h4><p>这是创建智能指针的<strong>推荐方式</strong>。</p>
<ul>
<li><p><strong><code>std::make_shared&lt;T&gt;(args...)</code></strong> (C++11)： 构造一个 <code>T</code> 类型对象，并用 <code>args</code> 初始化它，然后返回一个指向此对象的 <code>std::shared_ptr&lt;T&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式：可能引发内存泄漏（如果分配对象和构造shared_ptr之间发生异常）</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> MyClass(<span class="number">10</span>, <span class="number">20</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐方式：异常安全且更高效（通常只需一次内存分配）</span></span><br><span class="line"><span class="keyword">auto</span> sp2 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>std::make_unique&lt;T&gt;(args...)</code></strong> (C++14)： 构造一个 <code>T</code> 类型对象，并用 <code>args</code> 初始化它，然后返回一个指向此对象的 <code>std::unique_ptr&lt;T&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11中没有make_unique，需要自己构造</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> MyClass(<span class="number">30</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14方式：异常安全，语法一致</span></span><br><span class="line"><span class="keyword">auto</span> up2 = std::<span class="built_in">make_unique</span>&lt;MyClass&gt;(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>优点：</strong></p>
<ol>
<li><strong>异常安全</strong>： 函数参数的计算顺序可能在不同编译器下不同。如果使用 <code>new</code>，可能在分配内存和将裸指针交给智能指针之间发生异常，导致内存泄漏。<code>make_*</code> 函数将这两步合并为一个原子操作，避免了这个问题。</li>
<li><strong>性能提升</strong>（对 <code>make_shared</code> 尤其明显）： <code>std::shared_ptr</code> 需要为控制块（存储引用计数等）和对象本身分配内存。使用 <code>new</code> 需要两次分配。而 <code>make_shared</code> 通常<strong>只进行一次内存分配</strong>，将对象和控制块放在连续的内存区域，提高了效率和局部性。</li>
</ol>
<hr>
<h3 id="2-移动语义-Move-Semantics"><a href="#2-移动语义-Move-Semantics" class="headerlink" title="2. 移动语义 (Move Semantics)"></a>2. 移动语义 (Move Semantics)</h3><p>移动语义是C++11最重要的特性之一，它允许资源的所有权转移，从而避免了不必要的深层拷贝，极大地提升了性能。</p>
<h4 id="a-右值引用-Rvalue-References"><a href="#a-右值引用-Rvalue-References" class="headerlink" title="a. 右值引用 (Rvalue References)"></a>a. 右值引用 (Rvalue References)</h4><ul>
<li><strong>语法</strong>： <code>Type&amp;&amp;</code>，例如 <code>int&amp;&amp;</code>。</li>
<li><strong>目的</strong>： 用于标识“可被移动”的对象（临时对象、即将销毁的对象）。</li>
<li><strong>左值 vs 右值</strong>：<ul>
<li><strong>左值 (lvalue)</strong>： 有持久状态、有名字、可以取地址的表达式。例如变量、函数名、返回左值引用的函数调用。</li>
<li><strong>右值 (rvalue)</strong>： 临时对象、字面量（字符串字面量除外）、返回非引用类型的函数调用。例如 <code>10</code>, <code>x + y</code>, <code>std::string(&quot;hello&quot;)</code>。</li>
</ul>
</li>
</ul>
<h4 id="b-std-move-语义"><a href="#b-std-move-语义" class="headerlink" title="b. std::move 语义"></a>b. <code>std::move</code> 语义</h4><ul>
<li><p><strong>作用</strong>： <code>std::move(obj)</code> 并不移动任何东西。它只是一个<strong>强制类型转换</strong>，将左值 <code>obj</code> <strong>无条件地转换为右值引用</strong>。这相当于告诉编译器：“这个对象不再需要了，你可以把它拥有的资源偷走（移动）”。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = std::<span class="built_in">move</span>(str1); <span class="comment">// 调用string的移动构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动后，str1处于“有效但未定义的状态”（通常为空）</span></span><br><span class="line">std::cout &lt;&lt; str1; <span class="comment">// 可能是空字符串，但不要做任何假设</span></span><br><span class="line">std::cout &lt;&lt; str2; <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="c-移动构造函数和移动赋值运算符"><a href="#c-移动构造函数和移动赋值运算符" class="headerlink" title="c. 移动构造函数和移动赋值运算符"></a>c. 移动构造函数和移动赋值运算符</h4><p>为了让自定义类型支持移动语义，需要定义移动操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyVector</span> &#123;</span><br><span class="line">    <span class="type">int</span>* m_data;</span><br><span class="line">    <span class="type">size_t</span> m_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyVector</span>(MyVector&amp;&amp; other) <span class="keyword">noexcept</span> <span class="comment">// noexcept很重要，标准库组件依赖它</span></span><br><span class="line">        : <span class="built_in">m_data</span>(other.m_data), <span class="built_in">m_size</span>(other.m_size) &#123; <span class="comment">// 窃取资源</span></span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>; <span class="comment">// 将源对象置于可析构状态</span></span><br><span class="line">        other.m_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MyVector&amp; <span class="keyword">operator</span>=(MyVector&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_data;        <span class="comment">// 释放自己的资源</span></span><br><span class="line">            m_data = other.m_data;  <span class="comment">// 窃取资源</span></span><br><span class="line">            m_size = other.m_size;</span><br><span class="line">            other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">            other.m_size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 拷贝构造、析构等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="d-完美转发-Perfect-Forwarding"><a href="#d-完美转发-Perfect-Forwarding" class="headerlink" title="d. 完美转发 (Perfect Forwarding)"></a>d. 完美转发 (Perfect Forwarding)</h4><ul>
<li><p><strong>问题</strong>： 如何在一个函数内部，将参数<strong>原封不动</strong>（保持其值类别：lvalue-ness &#x2F; rvalue-ness）地传递给另一个函数？</p>
</li>
<li><p><strong>解决方案</strong>： <code>std::forward&lt;T&gt;(arg)</code></p>
</li>
<li><p><strong>机制</strong>： 通常与<strong>通用引用（Universal Reference）</strong> <code>T&amp;&amp;</code> 结合使用在模板中。<code>std::forward</code> 是一个<strong>有条件</strong>的 <code>std::move</code>。如果传入的是一个左值，它返回左值引用；如果传入的是一个右值，它返回右值引用（相当于 <code>std::move</code>）。</p>
</li>
<li><p><strong>应用场景</strong>： 工厂函数、<code>emplace_back</code> 等可变参数模板的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123; <span class="comment">// 通用引用接收参数</span></span><br><span class="line">    <span class="comment">// 完美转发给T的构造函数，保持参数原有的值类别</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-Lambda-表达式-Lambda-Expressions"><a href="#3-Lambda-表达式-Lambda-Expressions" class="headerlink" title="3. Lambda 表达式 (Lambda Expressions)"></a>3. Lambda 表达式 (Lambda Expressions)</h3><p>Lambda表达式提供了一种定义匿名函数对象的简便方法，极大地增强了STL算法的表达能力。</p>
<h4 id="a-语法"><a href="#a-语法" class="headerlink" title="a. 语法"></a>a. 语法</h4><p><code>[capture-list] (parameters) -&gt; return-type &#123; body &#125;</code></p>
<ul>
<li><strong><code>capture-list</code> 捕获列表</strong>： 指定lambda体内如何访问外部变量。</li>
<li><strong><code>parameters</code> 参数列表</strong>： 和普通函数一样（可选，可省略为 <code>()</code>）。</li>
<li><strong><code>return-type</code> 返回类型</strong>： 可以省略，编译器会自动推导（如果函数体只是 <code>return</code> 语句）。</li>
<li><strong><code>body</code> 函数体</strong>： 和普通函数一样。</li>
</ul>
<h4 id="b-捕获列表-Capture-List"><a href="#b-捕获列表-Capture-List" class="headerlink" title="b. 捕获列表 (Capture List)"></a>b. 捕获列表 (Capture List)</h4><p>定义了lambda表达式如何从外围作用域“捕获”变量。</p>
<ul>
<li><strong><code>[]</code></strong>： 不捕获任何外部变量。</li>
<li><strong><code>[=]</code></strong>： 以<strong>值</strong>的方式捕获所有外部变量。</li>
<li><strong><code>[&amp;]</code></strong>： 以<strong>引用</strong>的方式捕获所有外部变量。</li>
<li><strong><code>[var]</code></strong>： 仅以值的方式捕获变量 <code>var</code>。</li>
<li><strong><code>[&amp;var]</code></strong>： 仅以引用的方式捕获变量 <code>var</code>。</li>
<li><strong><code>[=, &amp;var]</code></strong>： 默认以值捕获，但变量 <code>var</code> 以引用捕获。</li>
<li><strong><code>[&amp;, var]</code></strong>： 默认以引用捕获，但变量 <code>var</code> 以值捕获。</li>
<li><strong><code>[this]</code></strong>： 捕获当前的 <code>this</code> 指针，允许访问所在类的成员。</li>
</ul>
<p><strong>注意</strong>： 默认值捕获 <code>[=]</code> 可能会带来问题，因为它捕获的是<strong>lambda定义时</strong>的变量值，而不是调用时的。而默认引用捕获 <code>[&amp;]</code> 则可能导致悬空引用。</p>
<h4 id="c-应用场景-1"><a href="#c-应用场景-1" class="headerlink" title="c. 应用场景"></a>c. 应用场景</h4><p>主要用于需要传递函数对象的地方，尤其是STL算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> threshold = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用lambda表达式找出大于threshold的数</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">remove_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),</span><br><span class="line">                         [threshold](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &lt;= threshold; &#125;);</span><br><span class="line">v.<span class="built_in">erase</span>(it, v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用lambda表达式进行排序</span></span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;); <span class="comment">// 降序</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-auto-和-decltype-Type-Deduction"><a href="#4-auto-和-decltype-Type-Deduction" class="headerlink" title="4. auto 和 decltype (Type Deduction)"></a>4. <code>auto</code> 和 <code>decltype</code> (Type Deduction)</h3><h4 id="a-auto"><a href="#a-auto" class="headerlink" title="a. auto"></a>a. <code>auto</code></h4><ul>
<li><p><strong>作用</strong>： 让编译器在<strong>编译期</strong>根据初始化表达式自动推导变量类型。</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<ol>
<li><p><strong>简化冗长或复杂的类型名</strong>： 特别是迭代器和模板代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::vector&lt;<span class="type">int</span>&gt;&gt; myMap;</span><br><span class="line"><span class="comment">// 不用写冗长的迭代器类型</span></span><br><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型编程</strong>： 在不知道或不关心具体类型时。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123; ... &#125; <span class="comment">// 遍历map，pair的类型是std::pair&lt;const std::string, ...&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Lambda表达式</strong>： 存储lambda对象（因为每个lambda类型都是唯一的、匿名的）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p><strong>注意</strong>： <code>auto</code> 会忽略顶层的 <code>const</code> 和引用，如果需要，必须手动加上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> a = ci; <span class="comment">// a 是 int，而不是 const int</span></span><br><span class="line"><span class="keyword">auto</span>&amp; b = ci; <span class="comment">// b 是 const int&amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="b-decltype"><a href="#b-decltype" class="headerlink" title="b. decltype"></a>b. <code>decltype</code></h4><ul>
<li><p><strong>作用</strong>： 查询一个表达式（而非初始化值）的<strong>确切类型</strong>，包括顶层的 <code>const</code> 和引用。</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<ol>
<li><p><strong>声明返回类型依赖于参数类型的函数</strong>（常与尾置返回类型 <code>-&gt;</code> 一起使用）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123; <span class="comment">// C++11的用法，C++14可以省略-&gt;...</span></span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在编译期获取表达式的类型</strong>，用于变量声明或元编程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">10</span>; <span class="comment">// y 是 int 类型</span></span><br><span class="line"><span class="keyword">decltype</span>((x)) z = x; <span class="comment">// z 是 int&amp; 类型，因为 (x) 是一个左值表达式</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<hr>
<h3 id="5-constexpr-Constant-Expressions"><a href="#5-constexpr-Constant-Expressions" class="headerlink" title="5. constexpr (Constant Expressions)"></a>5. <code>constexpr</code> (Constant Expressions)</h3><p><code>constexpr</code> 指定编译器在<strong>编译期</strong>就计算并确定变量或函数的值。</p>
<h4 id="a-constexpr-变量"><a href="#a-constexpr-变量" class="headerlink" title="a. constexpr 变量"></a>a. <code>constexpr</code> 变量</h4><p>编译期常量，比 <code>const</code> 更严格。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> size = <span class="number">100</span>; <span class="comment">// 编译期常量</span></span><br><span class="line"><span class="type">int</span> arr[size]; <span class="comment">// OK，可以用作数组大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">100</span>; &#125;</span><br><span class="line"><span class="comment">// const int my_size = getSize(); // OK，运行期常量</span></span><br><span class="line"><span class="comment">// int arr2[my_size]; // 错误！my_size的值在编译期未知</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getSizeCexpr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">100</span>; &#125; <span class="comment">// C++11要求函数体只有一条return语句</span></span><br><span class="line"><span class="type">int</span> arr3[<span class="built_in">getSizeCexpr</span>()]; <span class="comment">// OK，编译期计算</span></span><br></pre></td></tr></table></figure>

<h4 id="b-constexpr-函数"><a href="#b-constexpr-函数" class="headerlink" title="b. constexpr 函数"></a>b. <code>constexpr</code> 函数</h4><p>如果其参数是编译期常量，则函数会在编译期计算并返回结果；否则，它就像一个普通函数一样在运行时被调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="comment">// C++14允许函数体内有循环等语句</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 编译时计算，结果120直接嵌入代码</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">factorial</span>(x); <span class="comment">// 运行时计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="c-模板元编程-Template-Metaprogramming"><a href="#c-模板元编程-Template-Metaprogramming" class="headerlink" title="c. 模板元编程 (Template Metaprogramming)"></a>c. 模板元编程 (Template Metaprogramming)</h4><p><code>constexpr</code> 极大地简化了编译期计算，在很多场景下可以替代复杂、晦涩的模板元编程（TMP）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的模板元编程计算阶乘</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> value = Factorial&lt;<span class="number">5</span>&gt;::value; <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用constexpr函数，直观多了！</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="type">int</span> value = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>： 这些新特性共同将C++推向了一个新时代，使得它既能保持底层硬件操作的能力和高性能，又能提供高级语言的开发效率和安全性。</p>
<h2 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h2><hr>
<h3 id="十关总测验（闭卷，限时-30-min-😄）"><a href="#十关总测验（闭卷，限时-30-min-😄）" class="headerlink" title="十关总测验（闭卷，限时 30 min 😄）"></a>十关总测验（闭卷，限时 30 min 😄）</h3><ol>
<li><p><strong>指针与引用</strong><br>写出一段代码：函数 <code>void foo(int*&amp; p)</code>，在 <code>main()</code> 里用 <code>int x = 10;</code> 调用它，使得 <code>p</code> 最后指向 <code>x</code> 并打印出 <code>11</code>。要求：不能出现 <code>*</code> 解引用运算符。</p>
</li>
<li><p><strong>类内 static</strong><br>如何让 <code>class A</code> 的 static 成员 <code>A::count</code> 在头文件里声明，却在 main.cpp 里才定义，且保证其他 cpp 文件可见？写出声明+定义两行代码。</p>
</li>
<li><p><strong>类外 static</strong><br>在 <code>a.cpp</code> 里写 <code>static int gs = 7;</code>，在 <code>b.cpp</code> 里再写同样一句，会出现链接错误吗？为什么？</p>
</li>
<li><p><strong>new&#x2F;delete 三部曲</strong><br>手动实现一个最简 <code>my_shared_ptr&lt;T&gt;</code> 的<strong>引用计数</strong>部分（只需构造、拷贝、析构、释放内存，不用 weak_count）。要求用 <code>new</code> 分配控制块，用 <code>delete</code> 释放，禁止用 <code>std::</code> 任何东西。</p>
</li>
<li><p><strong>placement new</strong><br>给定 <code>char buf[64];</code>，在 <code>buf+7</code> 地址上构造一个 <code>std::string(&quot;hi&quot;)</code>，然后安全析构。写出完整代码，并说明为什么不能用 <code>delete (std::string*)(buf+7)</code>。</p>
</li>
<li><p><strong>智能指针混用</strong><br>下面代码有严重问题，指出并给出两种修复方案：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([](<span class="type">int</span>* p)&#123; std::this_thread::sleep_for(<span class="number">1</span>s); std::cout &lt;&lt; *p; &#125;, sp.get())</span></span>;</span><br><span class="line">sp.<span class="built_in">reset</span>();          <span class="comment">// 主线程立即重置</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内存泄漏检测</strong><br>用 <strong>Valgrind</strong> 跑 <code>./a.out</code> 时，如何只输出“确定泄漏”且把泄漏字节数≥10 的情况设为 CI 失败？写一行完整命令。</p>
</li>
<li><p><strong>字节对齐计算</strong><br>64 位默认对齐下，给出 <code>sizeof(X)</code> 和 <code>alignof(X)</code>：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="type">char</span> c; <span class="type">__int128_t</span> v; <span class="type">double</span> d; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>#pragma pack 与 alignas 冲突</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 2)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) S &#123; <span class="type">int</span> a; <span class="type">double</span> b; &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>

<p>问：<code>sizeof(S)</code> 是多少？说明规则依据。</p>
</li>
<li><p><strong>综合场景</strong><br>写一个<strong>线程安全</strong>的懒汉单例 <code>class Singleton</code>，要求：  </p>
<ul>
<li>使用 <code>std::shared_ptr</code> 管理唯一实例；  </li>
<li>禁用拷贝构造、赋值；  </li>
<li>在第一次调用 <code>instance()</code> 时才创建；  </li>
<li>程序退出时自动释放，无内存泄漏。<br>只写关键 10 行代码即可。</li>
</ul>
</li>
</ol>
<h3 id="标准答案-评分细则"><a href="#标准答案-评分细则" class="headerlink" title="标准答案 + 评分细则"></a><strong>标准答案 + 评分细则</strong></h3><hr>
<ol>
<li><strong>指针与引用</strong>（10 分）<br><strong>要求</strong>：不出现 <code>*</code> 解引用，最后打印 11。<br><strong>标准答案</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>*&amp; p)</span> </span>&#123; ++p; &#125;   <span class="comment">// p 本身是指针的引用，++p 让指针前移 4 字节（int）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* q = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">foo</span>(q);          <span class="comment">// q 现在指向 arr[1]</span></span><br><span class="line">    std::cout &lt;&lt; *q; <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>得分点</strong>：  </p>
<ul>
<li>没有 <code>*</code> 解号（5 分）  </li>
<li>最终输出 11（5 分）</li>
</ul>
<hr>
<ol start="2">
<li><strong>类内 static 声明与定义</strong>（10 分）<br><strong>头文件</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>main.cpp</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> A::count = <span class="number">9</span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>

<p><strong>得分点</strong>：  </p>
<ul>
<li>头文件用 <code>static int count;</code>（3 分）  </li>
<li>cpp 用 <code>int A::count = 9;</code>（7 分）</li>
</ul>
<hr>
<ol start="3">
<li><strong>类外 static 重复定义</strong>（10 分）<br><strong>答案</strong>：<strong>不会链接错误</strong>，因为文件级 <code>static</code> 是<strong>内部链接</strong>，每个翻译单元拥有独立实体。<br><strong>得分点</strong>：</li>
</ol>
<ul>
<li>答“不会”（5 分）  </li>
<li>解释“内部链接&#x2F;作用域独立”（5 分）</li>
</ul>
<hr>
<ol start="4">
<li><strong>最简引用计数 my_shared_ptr</strong>（10 分）<br><strong>核心 6 行</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_shared_ptr</span> &#123;</span><br><span class="line">    T* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span>* cnt = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">my_shared_ptr</span>(T* p): <span class="built_in">ptr</span>(p), <span class="built_in">cnt</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    <span class="built_in">my_shared_ptr</span>(<span class="type">const</span> my_shared_ptr&amp; o): <span class="built_in">ptr</span>(o.ptr), <span class="built_in">cnt</span>(o.cnt) &#123; ++*cnt; &#125;</span><br><span class="line">    ~<span class="built_in">my_shared_ptr</span>() &#123; <span class="keyword">if</span> (--*cnt == <span class="number">0</span>) &#123; <span class="keyword">delete</span> ptr; <span class="keyword">delete</span> cnt; &#125; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>得分点</strong>：  </p>
<ul>
<li>控制块用 <code>new int(1)</code>（3 分）  </li>
<li>拷贝++（2 分）  </li>
<li>析构–并释放（5 分）</li>
</ul>
<hr>
<ol start="5">
<li><strong>placement new 构造与析构</strong>（10 分）<br><strong>标准代码</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alignas</span>(std::string) <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">std::string* p = <span class="built_in">new</span> (buf<span class="number">+7</span>) std::<span class="built_in">string</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">p-&gt;~std::<span class="built_in">string</span>();           <span class="comment">// 必须手动析构</span></span><br><span class="line"><span class="comment">// 禁止 delete p; —— 内存不是 new 来的</span></span><br></pre></td></tr></table></figure>

<p><strong>得分点</strong>：  </p>
<ul>
<li>正确使用 placement new（5 分）  </li>
<li>手动调用析构（5 分）</li>
</ul>
<hr>
<ol start="6">
<li><strong>shared_ptr 与线程生命周期</strong>（10 分）<br><strong>问题</strong>：主线程 <code>reset()</code> 后，子线程再解引用 <code>*p</code> → <strong>UB</strong>。<br><strong>两种修复</strong>：<br>a) 把 <code>shared_ptr</code> 按值捕获到 lambda，让线程拥有独立拷贝。<br>b) 使用 <code>weak_ptr</code> 并在线程内 <code>lock()</code> 提升。<br><strong>得分点</strong>：</li>
</ol>
<ul>
<li>指出 UB（5 分）  </li>
<li>给出任意一种修复（5 分）</li>
</ul>
<hr>
<ol start="7">
<li><strong>Valgrind CI 阈值</strong>（10 分）<br><strong>命令</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valgrind --leak-check=full --errors-for-leak-kinds=definite \</span><br><span class="line">         --error-exitcode=1 ./a.out</span><br></pre></td></tr></table></figure>

<p>（<code>--errors-for-leak-kinds=definite</code> 只把“确定泄漏”视为错误；泄漏字节数≥1 即返回 1）<br><strong>得分点</strong>：  </p>
<ul>
<li>写出 <code>--error-exitcode=1</code>（5 分）  </li>
<li>限定 <code>definite</code> 泄漏（5 分）</li>
</ul>
<hr>
<ol start="8">
<li><strong>对齐计算</strong>（10 分）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="type">char</span> c; <span class="type">__int128_t</span> v; <span class="type">double</span> d; &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>alignof(X)</code> &#x3D; 16（<code>__int128_t</code> 要求 16）  </li>
<li><code>sizeof(X)</code> &#x3D; 32（c:1 + pad15 + v:16 + d:8 + pad8 → 对齐到 16 边界）<br><strong>得分点</strong>：  </li>
<li><code>sizeof</code> 32（5 分）  </li>
<li><code>alignof</code> 16（5 分）</li>
</ul>
<hr>
<ol start="9">
<li><strong>pack 与 alignas 冲突</strong>（10 分）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 2)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) S &#123; <span class="type">int</span> a; <span class="type">double</span> b; &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>

<p><strong>规则</strong>：<code>alignas</code> <strong>不会</strong>被 <code>#pragma pack</code> 缩小；最终对齐取 <strong>max(pack, alignas)</strong>。  </p>
<ul>
<li>实际对齐 &#x3D; 16  </li>
<li>大小 &#x3D; 16（a:4 + pad4 + b:8 → 总 16，已 16 对齐）<br><strong>得分点</strong>：  </li>
<li>答 <code>16</code>（5 分）  </li>
<li>解释“alignas 优先级高”（5 分）</li>
</ul>
<hr>
<ol start="10">
<li><strong>线程安全 shared_ptr 单例</strong>（10 分）<br><strong>关键 10 行</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Singleton&gt;&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::shared_ptr&lt;Singleton&gt; inst&#123;</span><br><span class="line">            <span class="keyword">new</span> Singleton, [](Singleton* p)&#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>得分点</strong>：  </p>
<ul>
<li>静态局部 <code>shared_ptr</code>（4 分）  </li>
<li>禁用拷贝（2 分）  </li>
<li>返回引用避免重复拷贝（4 分）</li>
</ul>
<hr>
<p><strong>总分 100，自己算分吧！</strong><br>把错题发回来，我再给你补细节 😄</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://brinjaul521.github.io">贺腾</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://brinjaul521.github.io/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/">https://brinjaul521.github.io/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://brinjaul521.github.io" target="_blank">贺腾的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/joker.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/21/DeferredGS-%E5%92%8C-3DGS-DR%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/" title="DeferredGS 和 3DGS-DR技术对比"><img class="cover" src="/2025/09/21/DeferredGS-%E5%92%8C-3DGS-DR%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/boy.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">DeferredGS 和 3DGS-DR技术对比</div></div><div class="info-2"><div class="info-item-1">DeferredGS 和 3DGS-DR技术对比对比简介这两篇论文（DeferredGS 和 3DGS-DR）都致力于将延迟渲染（Deferred Shading） 技术引入 3D Gaussian Splatting (3DGS) 框架，以解决传统 3DGS 在处理高光反射（Specular Reflection） 时的核心问题。然而，它们在目标、技术实现、核心贡献和应用场景上存在显著差异。 以下是对两篇论文相同点与不同点的详细分析：  相同之处 (Key Similarities) 核心技术：延迟渲染 (Deferred Shading):  两篇论文都摒弃了 3DGS 原始的前向着色 (Forward Shading) 方式（即在每个 Gaussian 上计算颜色然后混合）。 都采用了两阶段渲染管线： 阶段 1 (Gaussian Splatting Pass): 将 Gaussian 的属性（位置、法线、材质参数等）光栅化到屏幕空间的缓冲（G-Buffer）中。 阶段 2 (Shading Pass): 在像素级别，利用 G-Buffer 中的信息（法线、材质等）和光照信...</div></div></div></a><a class="pagination-related" href="/2025/09/19/3DGS-DR%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/" title="3DGS-DR部署及训练教程"><img class="cover" src="/2025/09/19/3DGS-DR%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/pipeline.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">3DGS-DR部署及训练教程</div></div><div class="info-2"><div class="info-item-1">3DGS-DR部署及训练教程 项目介绍​	paper：3D Gaussian Splatting with Deferred Reflection ​	web:3D Gaussian Splatting with Deferred Reflection ​	github：https://github.com/gapszju/3DGS-DR.git ​	摘要：神经与高斯基辐射场方法的兴起在新视角合成领域取得了巨大成功。然而，镜面反射仍然是一个非平凡的问题，因为高频辐射场 notoriously 难以稳定且准确地拟合。我们提出了一种延迟着色方法，能够有效地利用高斯溅射渲染镜面反射。关键挑战来自于环境贴图反射模型，该模型需要精确的表面法线，同时其不连续的梯度又成为法线估计的瓶颈。我们利用延迟着色生成的逐像素反射梯度，在相邻高斯的优化过程之间架起桥梁，使得近乎正确的法线估计能够逐步传播，最终覆盖所有反射物体。我们的方法在合成高质量镜面反射效果方面显著优于现有最先进技术和同期工作，在合成场景与真实场景中均实现了峰值信噪比（PSNR）的持续提升，同时运行帧率几乎与原始高斯溅射相同。 项目部署...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/17/C-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="C++ 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-17</div><div class="info-item-2">C++ 面试题</div></div><div class="info-2"><div class="info-item-1">睿联面试linux swap分区什么作用​	在Linux中，swap分区（或swap文件）的作用是当系统的物理内存（RAM）不足时，将内存中不常用的数据暂时存储到硬盘上的swap空间中，从而释放物理内存供其他更紧急的任务使用。这个过程称为“交换出”（swapping out）。当需要再次访问这些数据时，再将其从swap分区读回内存，即“交换入”（swapping in）。swap空间可以被视为物理内存的扩展，但需要注意的是，硬盘的读写速度远低于内存，因此过度依赖swap会导致系统性能下降。	  扩展虚拟内存：当物理内存（RAM）不足时，系统可以将不常用的内存页面移动到Swap空间中，从而释放RAM供更紧急的任务使用 内存管理：即使系统有足够的物理内存，内核有时也会将长时间未活动的内存页面移动到Swap中 休眠支持：当系统进入休眠状态时，会将RAM中的内容保存到Swap空间中，以便恢复时使用 避免内存不足：防止系统因内存耗尽而意外终止关键进程  Linux文件有几种权限，分别是什么Linux文件的基本权限类型Linux系统中，每个文件和目录都有三种基本的权限类型，每种权限类型对应三...</div></div></div></a><a class="pagination-related" href="/2025/09/18/%E5%87%A0%E7%A7%8D%E9%94%81%E7%9A%84%E5%AF%B9%E6%AF%94/" title="几种锁的对比"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-18</div><div class="info-item-2">几种锁的对比</div></div><div class="info-2"><div class="info-item-1">几种锁的对比好的，那我来详细对比一下 std::lock_guard 和 std::unique_lock 这两种常用的锁管理方式，以及它们与直接使用锁的区别。 1. std::lock_guard 定义 ：std::lock_guard 是一个简单的锁管理器，用于管理互斥锁的锁定和解锁。它在构造时锁定互斥锁，在析构时自动释放锁。  特点 ：  自动管理 ：构造函数锁定锁，析构函数释放锁，确保锁的管理不会被遗忘。 不可移动、不可复制 ：std::lock_guard 对象不能被移动或复制，这意味着锁不能在不同的作用域之间传递。 简单易用 ：适用于简单的锁需求场景，不需要复杂的锁管理。 作用域绑定 ：锁的生命周期与 std::lock_guard 对象的作用域绑定，一旦超出作用域，锁自动释放。   示例 ： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;thread&gt;std::mutex mtx;void print_block(int n)...</div></div></div></a><a class="pagination-related" href="/2025/09/18/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/" title="生产者消费者模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-18</div><div class="info-item-2">生产者消费者模型</div></div><div class="info-2"><div class="info-item-1">生产者消费者模型我第一次写的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;thread&gt;#include&lt;mutex&gt;#include&lt;condition_variable&gt;std::queue&lt;int&gt; g_queue;std::mutex g_mutex;std::condition_variable g_cv;void producer() &#123;	for (int i = 0; i &lt;= 10000; i++) &#123;		std::unique_lock&lt;std::mutex&gt; lk(g_mutex);		g_queue.push(i);		std::cout &lt;&lt; &quot;producer:&quot; &lt;&lt; i &lt;&lt; std::en...</div></div></div></a><a class="pagination-related" href="/2025/09/18/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="策略模式"><img class="cover" src="/2025/09/18/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/strategy.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-18</div><div class="info-item-2">策略模式</div></div><div class="info-2"><div class="info-item-1">策略模式策略模式是什么策略模式（Strategy Pattern）是一种 行为型 设计模式，核心思想是：  把“一组可互相替换的算法”封装成独立类，让它们实现同一个接口，运行时按需切换，而不用修改客户端代码。   一、生活例子 10 秒懂  去机场有 3 种算法：地铁、大巴、打车。   算法各自封装成类（MetroStrategy、BusStrategy、TaxiStrategy）。   你手里只拿一张“去机场”的通用票（Context），想省钱就插地铁算法，想快就插打车算法——切换即插即用。   二、代码骨架（语言无关） 1234567891011121314151617181920                 ┌----------------┐                 │  Strategy接口  │◀----┐                 │ +algorithm()   │     │                 └----------------┘     │ 实现                        △               │ ...</div></div></div></a><a class="pagination-related" href="/2025/09/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="简单工厂模式"><img class="cover" src="/2025/09/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/asl.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-19</div><div class="info-item-2">简单工厂模式</div></div><div class="info-2"><div class="info-item-1">简单工厂模式讲解（C++实现）前期问题引入假设我们正在开发一个电子产品商店系统，需要创建不同类型的电子产品对象，如手机、平板电脑和笔记本电脑。在没有使用设计模式的情况下，我们可能会这样写代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 电子产品类型enum ProductType &#123;    PHONE,    TABLET,    LAPTOP&#125;;// 手机类class Phone &#123;public:    void showInfo() &#123;        cout &lt;&lt; &quot;这是一部手机&quot; &lt;&lt; endl;    &#125;&#125;;// 平板电脑类class Tablet &#1...</div></div></div></a><a class="pagination-related" href="/2025/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/" title="设计模式的原则"><img class="cover" src="/2025/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/design.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-19</div><div class="info-item-2">设计模式的原则</div></div><div class="info-2"><div class="info-item-1">设计模式的原则设计模式的原则是面向对象设计的指导思想，它们为我们提供了设计高质量、可维护、可扩展软件系统的基本准则。这些原则是设计模式背后的理论基础。 SOLID 原则SOLID 是五个重要设计原则的首字母缩写，由 Robert C. Martin 提出。 1. 单一职责原则 (Single Responsibility Principle - SRP)定义：一个类应该只有一个引起变化的原因。 解释：  每个类应该只负责一个特定的功能或职责 避免创建”万能类”，这样的类难以维护和测试 将不同的职责分离到不同的类中  示例： 1234567891011121314151617181920212223// 违反SRP的示例class Employee &#123;public:    void calculateSalary() &#123; /* 计算工资 */ &#125;    void saveToDatabase() &#123; /* 保存到数据库 */ &#125;    void generateReport() &#123; /* 生成报告 */ &#125;&#1...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">贺腾</div><div class="author-info-description">我等的不是海边</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/brinjaul521/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/brinjaul521/" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1061391142@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">记录一下学习路线，顺便找个工作</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%B8%E2%BC%BC%E8%AF%AD%E2%BE%94%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">C++核⼼语⾔特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基础语法与概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E7%94%A8%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">指针占用内存，为什么引用不一定占用内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">✅ 一句话结论：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">1.1.3.</span> <span class="toc-text">🔍 详细解释：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8C%87%E9%92%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1. 指针是一个变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E6%98%AF%E5%88%AB%E5%90%8D%EF%BC%8C%E4%B8%8D%E6%98%AF%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2. 引用是别名，不是变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%88%E6%B1%87%E7%BC%96%E5%B1%82%E9%9D%A2%EF%BC%89%EF%BC%9A"><span class="toc-number">1.1.4.</span> <span class="toc-text">🧠 举个例子（汇编层面）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%89%88%E6%9C%AC%EF%BC%9A"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">指针版本：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%89%88%E6%9C%AC%EF%BC%9A"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">引用版本：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%BC%95%E7%94%A8%E5%8F%AF%E8%83%BD%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.1.5.</span> <span class="toc-text">⚠️ 注意：引用可能占用内存的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%88%E5%86%8D%E5%BC%BA%E8%B0%83%EF%BC%89%EF%BC%9A"><span class="toc-number">1.1.6.</span> <span class="toc-text">✅ 总结一句话（再强调）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%88%B0%E5%BA%95%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%A4%A7%E5%86%85%E5%AD%98"><span class="toc-number">1.1.7.</span> <span class="toc-text">指针到底占用多大内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%94%B1%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A%EF%BC%9F"><span class="toc-number">1.1.8.</span> <span class="toc-text">指针占用内存大小由什么决定？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%8864%E4%BD%8D%E6%9C%BA%E5%99%A8%E4%B8%8A%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E5%8D%A0%E7%94%A88%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-number">1.1.9.</span> <span class="toc-text">为什么64位机器上普通指针占用8个字节？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E7%9A%84%E6%8C%87%E9%92%88%E5%8D%A0%E7%94%A816%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-number">1.1.10.</span> <span class="toc-text">为什么有的指针占用16个字节？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.11.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E6%98%AF%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%EF%BC%8C%E6%88%91%E5%9C%A8%E8%B0%83%E7%94%A8%E6%97%B6%E4%BC%A0%E5%85%A5%E5%BC%95%E7%94%A8%EF%BC%8C%E6%88%96%E8%80%85%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E6%98%AF%E5%BC%95%E7%94%A8%EF%BC%8C%E6%88%91%E5%9C%A8%E8%B0%83%E7%94%A8%E6%97%B6%E4%BC%A0%E5%85%A5%E6%8C%87%E9%92%88%EF%BC%8C%E4%BC%9A%E6%9C%89%E6%80%8E%E6%A0%B7%E7%9A%84%E5%90%8E%E6%9E%9C%E5%91%A2"><span class="toc-number">1.1.12.</span> <span class="toc-text">当一个函数的形参是指针变量，我在调用时传入引用，或者是一个函数的形参是引用，我在调用时传入指针，会有怎样的后果呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%86%85static%E5%92%8C%E7%B1%BB%E5%A4%96static%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.13.</span> <span class="toc-text">类内static和类外static有什么区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">关键字深度理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. static 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F-Local-Static-Variables"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">a. 局部静态变量 (Local Static Variables)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%85%A8%E5%B1%80%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F-%E5%87%BD%E6%95%B0-Global-Static-Variables-Functions"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">b. 全局静态变量&#x2F;函数 (Global Static Variables&#x2F;Functions)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-Static-Member-Variables"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">c. 静态成员变量 (Static Member Variables)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-Static-Member-Functions"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">d. 静态成员函数 (Static Member Functions)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">应用场景总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-const-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. const 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-const%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">a. const变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-const%E6%8C%87%E9%92%88-%E5%8C%BA%E5%88%86%E5%8E%9F%E5%88%99%EF%BC%9Aconst-%E5%9C%A8-%E7%9A%84%E5%B7%A6%E8%BE%B9%E8%BF%98%E6%98%AF%E5%8F%B3%E8%BE%B9"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">b. const指针 - 区分原则：const 在 * 的左边还是右边</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">c. const成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-const%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">d. const对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-mutable-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">e. mutable 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f-const-cast-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">f. const_cast 运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. volatile 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E9%98%BB%E6%AD%A2"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">a. 编译器优化阻止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">b. 内存可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">c. 应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E4%B8%8E-std-atomic-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">d. 与 std::atomic 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-%E4%B8%8E-const-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">e. 与 const 的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-virtual-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. virtual 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E8%99%9A%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6-Virtual-Functions"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">a. 虚函数机制 (Virtual Functions)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8-vtable-%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-vptr"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">b. 虚函数表 (vtable) 和虚函数指针 (vptr)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-Pure-Virtual-Functions-%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB-Abstract-Base-Classes"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">c. 纯虚函数 (Pure Virtual Functions) 和抽象基类 (Abstract Base Classes)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-Virtual-Destructors"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">d. 虚析构函数 (Virtual Destructors)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-%E8%99%9A%E7%BB%A7%E6%89%BF-Virtual-Inheritance"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">e. 虚继承 (Virtual Inheritance)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-inline-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. inline 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">a. 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">b. 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">c. 缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E5%86%85%E8%81%94%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%88%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%9A%E5%B8%B8%E4%B8%8D%E4%BC%9A%E5%86%85%E8%81%94%EF%BC%89"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">d. 内联失效的情况（编译器通常不会内联）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-%E7%8E%B0%E4%BB%A3%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">e. 现代编译器的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">f. 最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-explicit-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. explicit 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E9%98%B2%E6%AD%A2%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">a. 防止隐式转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">b. 最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new-delete%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%9Anew-operator%E3%80%81operator-new%E3%80%81placement-new%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.1.</span> <span class="toc-text">new&#x2F;delete操作符：new operator、operator new、placement new区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-new-operator-%E2%80%94%E2%80%94-%E6%88%91%E4%BB%AC%E5%A4%A9%E5%A4%A9%E5%86%99%E7%9A%84-T-p-new-T"><span class="toc-number">1.3.2.</span> <span class="toc-text">1. new operator —— 我们天天写的 T* p &#x3D; new T;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-operator-new-%E2%80%94%E2%80%94-%E7%BA%AF%E7%B2%B9%E7%9A%84%E2%80%9C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E2%80%9D"><span class="toc-number">1.3.3.</span> <span class="toc-text">2. operator new —— 纯粹的“内存分配器”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-placement-new-%E2%80%94%E2%80%94-%E2%80%9C%E5%AE%9A%E7%82%B9%E6%9E%84%E9%80%A0%E2%80%9D%E7%A5%9E%E5%99%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">3. placement new —— “定点构造”神器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%80%BB%E7%BB%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">一张图总结流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA%E6%8F%90%E9%86%92"><span class="toc-number">1.3.6.</span> <span class="toc-text">常见误区提醒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9Ashared-ptr%E3%80%81unique-ptr%E3%80%81weak-ptr%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8B"><span class="toc-number">1.3.7.</span> <span class="toc-text">智能指针：shared_ptr、unique_ptr、weak_ptr实现原理讲解一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9A%E6%A3%80%E6%B5%8B%E2%BD%85%E6%B3%95%E3%80%81%E9%98%B2%E2%BD%8C%E7%AD%96%E7%95%A5%E3%80%81%E8%B0%83%E8%AF%95%E2%BC%AF%E5%85%B7-Valgrind"><span class="toc-number">1.3.8.</span> <span class="toc-text">内存泄漏：检测⽅法、防⽌策略、调试⼯具(Valgrind)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%EF%BC%9A%E4%BA%A7%E2%BD%A3%E5%8E%9F%E5%9B%A0%E3%80%81%E5%8D%B1%E5%AE%B3%E3%80%81%E9%81%BF%E5%85%8D%E2%BD%85%E6%B3%95"><span class="toc-number">1.3.9.</span> <span class="toc-text">野指针与悬空指针：产⽣原因、危害、避免⽅法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88-Wild-Pointer"><span class="toc-number">1.3.10.</span> <span class="toc-text">野指针 (Wild Pointer)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.3.10.1.</span> <span class="toc-text">1. 产生原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%B1%E5%AE%B3"><span class="toc-number">1.3.10.2.</span> <span class="toc-text">2. 危害</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%81%BF%E5%85%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.10.3.</span> <span class="toc-text">3. 避免方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88-Dangling-Pointer"><span class="toc-number">1.3.11.</span> <span class="toc-text">悬空指针 (Dangling Pointer)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0-1"><span class="toc-number">1.3.11.1.</span> <span class="toc-text">1. 产生原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%B1%E5%AE%B3-1"><span class="toc-number">1.3.11.2.</span> <span class="toc-text">2. 危害</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%81%BF%E5%85%8D%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.3.11.3.</span> <span class="toc-text">3. 避免方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.12.</span> <span class="toc-text">总结与对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%AF%B9%E2%BB%AC%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81pragma-pack%E3%80%81%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D"><span class="toc-number">1.3.13.</span> <span class="toc-text">字节对⻬：原理、pragma pack、性能影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">面向对象高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF-Inheritance"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 继承 (Inheritance)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E7%BB%A7%E6%89%BF%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-public-protected-private"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">a. 继承访问控制 (public&#x2F;protected&#x2F;private)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E8%99%9A%E7%BB%A7%E6%89%BF-Virtual-Inheritance-%E4%B8%8E-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF-Diamond-Problem"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">b. 虚继承 (Virtual Inheritance) 与 菱形继承 (Diamond Problem)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E6%80%81-Polymorphism"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 多态 (Polymorphism)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81-Static-Polymorphism-vs-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81-Dynamic-Polymorphism"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">a. 静态多态 (Static Polymorphism) vs 动态多态 (Dynamic Polymorphism)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">b. 虚函数实现机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8B%E5%85%83-Friend"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 友元 (Friend)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0-Friend-Function"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">a. 友元函数 (Friend Function)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%8F%8B%E5%85%83%E7%B1%BB-Friend-Class"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">b. 友元类 (Friend Class)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E7%A0%B4%E5%9D%8F%E5%B0%81%E8%A3%85%E6%80%A7%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">c. 破坏封装性的权衡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-Operator-Overloading"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. 运算符重载 (Operator Overloading)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E8%A7%84%E5%88%99"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">a. 规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%B8%B8%E8%A7%81%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">b. 常见重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-Copy-Constructor"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">c. 拷贝构造函数 (Copy Constructor)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3C-%EF%BC%88C-11-14-17%EF%BC%89%E5%BC%95%E5%85%A5%E7%9A%84%E8%BF%99%E4%BA%9B%E9%9D%A9%E5%91%BD%E6%80%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.</span> <span class="toc-text">现代C++（C++11&#x2F;14&#x2F;17）引入的这些革命性特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-Smart-Pointers"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 智能指针 (Smart Pointers)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#make-shared-%E5%92%8C-make-unique"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">make_shared 和 make_unique</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89-Move-Semantics"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 移动语义 (Move Semantics)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-Rvalue-References"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">a. 右值引用 (Rvalue References)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-std-move-%E8%AF%AD%E4%B9%89"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">b. std::move 语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">c. 移动构造函数和移动赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91-Perfect-Forwarding"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">d. 完美转发 (Perfect Forwarding)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F-Lambda-Expressions"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. Lambda 表达式 (Lambda Expressions)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E8%AF%AD%E6%B3%95"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">a. 语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8-Capture-List"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">b. 捕获列表 (Capture List)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">c. 应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-auto-%E5%92%8C-decltype-Type-Deduction"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. auto 和 decltype (Type Deduction)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-auto"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">a. auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-decltype"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">b. decltype</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-constexpr-Constant-Expressions"><span class="toc-number">1.5.5.</span> <span class="toc-text">5. constexpr (Constant Expressions)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-constexpr-%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">a. constexpr 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-constexpr-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">b. constexpr 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B-Template-Metaprogramming"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">c. 模板元编程 (Template Metaprogramming)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%B5%8B%E8%AF%95"><span class="toc-number">1.6.</span> <span class="toc-text">小测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%B3%E6%80%BB%E6%B5%8B%E9%AA%8C%EF%BC%88%E9%97%AD%E5%8D%B7%EF%BC%8C%E9%99%90%E6%97%B6-30-min-%F0%9F%98%84%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">十关总测验（闭卷，限时 30 min 😄）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%AD%94%E6%A1%88-%E8%AF%84%E5%88%86%E7%BB%86%E5%88%99"><span class="toc-number">1.6.2.</span> <span class="toc-text">标准答案 + 评分细则</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/21/DeferredGS-%E5%92%8C-3DGS-DR%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/" title="DeferredGS 和 3DGS-DR技术对比"><img src="/2025/09/21/DeferredGS-%E5%92%8C-3DGS-DR%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/boy.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DeferredGS 和 3DGS-DR技术对比"/></a><div class="content"><a class="title" href="/2025/09/21/DeferredGS-%E5%92%8C-3DGS-DR%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/" title="DeferredGS 和 3DGS-DR技术对比">DeferredGS 和 3DGS-DR技术对比</a><time datetime="2025-09-21T12:54:26.000Z" title="发表于 2025-09-21 20:54:26">2025-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/" title="C++核心语言特性"><img src="/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/joker.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++核心语言特性"/></a><div class="content"><a class="title" href="/2025/09/20/C-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/" title="C++核心语言特性">C++核心语言特性</a><time datetime="2025-09-20T13:09:58.000Z" title="发表于 2025-09-20 21:09:58">2025-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/3DGS-DR%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/" title="3DGS-DR部署及训练教程"><img src="/2025/09/19/3DGS-DR%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/pipeline.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3DGS-DR部署及训练教程"/></a><div class="content"><a class="title" href="/2025/09/19/3DGS-DR%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/" title="3DGS-DR部署及训练教程">3DGS-DR部署及训练教程</a><time datetime="2025-09-19T12:29:28.000Z" title="发表于 2025-09-19 20:29:28">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/" title="设计模式的原则"><img src="/2025/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/design.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式的原则"/></a><div class="content"><a class="title" href="/2025/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/" title="设计模式的原则">设计模式的原则</a><time datetime="2025-09-19T11:05:22.000Z" title="发表于 2025-09-19 19:05:22">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="简单工厂模式"><img src="/2025/09/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/asl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单工厂模式"/></a><div class="content"><a class="title" href="/2025/09/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="简单工厂模式">简单工厂模式</a><time datetime="2025-09-19T06:17:45.000Z" title="发表于 2025-09-19 14:17:45">2025-09-19</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 贺腾</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/bg-player.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>